<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="GENERATOR" CONTENT="Globetrotter 1.1.1">
<META HTTP-EQUIV="AUTHOR" CONTENT="David G. Kay">
<META HTTP-EQUIV="UPDATED" CONTENT="Wednesday, January 19, 2000 3:52 PM">
<TITLE>Asst. 1 * Scheme Introduction</TITLE>
<META HTTP-EQUIV="X-GLOBETROTTERDATA" CONTENT="644EC08E">
<META HTTP-EQUIV=KEYWORDS CONTENT="Programming languages, homework, Scheme">
<META HTTP-EQUIV="DESCRIPTION" CONTENT="Assignment 1, Scheme Introduction, for ICS 141, an undergraduate course in the concepts of programming languages taught by David G. Kay in the Department of Information and Computer Science, University of California, Irvine.">
<META HTTP-EQUIV="COPYRIGHT" CONTENT="Copyright &#169; 2000 by David G. Kay.  All rights reserved.">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME="_top"></A>
<P>
<IMG SRC="asst_1_scheme_introduc_files/sidebar_76.gif" WIDTH=468 HEIGHT=78>
<BR>
<FONT FACE="AGaramond" SIZE=4><B>About the assignments in ICS 141:</B> 
This course teaches not only new concepts but also new ways of thinking.
 Learning to think in new ways usually requires practice-- actually <I>doing</I>
the new things a few times (or more).  The homeworks are your opportunity
to get that practice.  Don&#39;t just say to yourself, &quot;Let me just
get the answer down and turn it in; I&#39;ll learn how to do it later.&quot;
 Keep working (by yourself, with the instructor or TAs, or with your classmates)
until you can produce the answers on your own, without help.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>It&#39;s no secret that some of the problems
we assign this quarter are the same as we assigned last quarter.  It is
entirely possible for you to find the answers from someone who took the
course before and just copy them down and turn them in.  But besides being
academically dishonest, it also won&#39;t prepare you to do similar problems
on the exams, so your course grade will suffer.  Give the assignments the
time and attention they require, and enjoy stretching your &quot;mental
muscles.&quot;</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Due date:</B>  This assignment is due on
Monday, January 24, by 3:00 PM.  Deposit your assignment in the locking
drop box in room CS 189.  The due date is closer than it seems; be sure
to get started this week so you can ask questions in discussion on Friday.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Summary:</B>  For this assignment you will
become acquainted with running the Scheme interpreter and the basic patterns
of recursive list processing code in Scheme.  A few of the problems will
seem familiar to those who took ICS 22 here from me; I apologize for the
repetition but your work back then will pay off now.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Part I (Readings and review questions):</B>
 Each chapter of Sebesta ends with two sets of exercises, one called &quot;review
questions&quot; and one called &quot;problem set.&quot;  Each set is numbered
starting from 1, so be careful to verify which set we&#39;re asking for
on each assignment.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>You should know the answers to the review
questions listed below, but you do not have to turn them in.  This list
should help you identify some of the more important concepts in the text.
 (On the other hand, don&#39;t infer that topics we skip or omit are entirely
<I>un</I>important.)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Chapter 1:  1-11, 13, 15-17, 19-25, 27-32.
 Come back to these questions at the end of the course, as you review for
the final.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Chapter 2:  8, 14-17, 21, 26-30, 35-38, 42,
43, 46.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Chapter 14:  1, 4, 6-9, 14.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Part II:</B>  In Chapter 2 of Sebesta,
answer in one or two brief sentences each of the following questions in
the problem set on page 104:  6, 7, 8, 9, and 14.  (Note that these are
questions from the &quot;problem set,&quot; not from the &quot;review questions.&quot;)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Feel free to try some of the exercises we
don&#39;t assign, but if you get stuck, ask us before spending too much
time on any problem; not all of them address issues that will be important
to us.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Part III:</B>  We cover Scheme in ICS 141
for two main reasons:  To illustrate concepts of functional programming,
including higher-order functions, and to give you experience learning a
new language that&#39;s significantly different from what you already know.
 Learning to think in a new way isn&#39;t easy; some frustration is inevitable
as you stretch your mind in new directions.  But middle school and high
school students learn this material (see </FONT><FONT FACE="Courier New"><A HREF="http://www.schemers.com">www.schemers.com</A></FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">www.cs.rice.edu/CS/PLT/Teaching/</FONT><FONT FACE="AGaramond" SIZE=4>),
so you can, too.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Scheme language details:</B>  Writing textbooks
is hard work, so maybe we can forgive Sebesta missing a few details about
the current status of the Scheme language standard:
<BR>
-- The two boolean constants are </FONT><FONT FACE="Courier New">#t</FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">#f</FONT><FONT FACE="AGaramond" SIZE=4>.
 </FONT><FONT FACE="Courier New">NIL</FONT><FONT FACE="AGaramond" SIZE=4>
is no longer used, and while the empty list counts as false, it&#39;s bad
programming practice to use it that way.
<BR>
-- Many Scheme implementations allow </FONT><FONT FACE="Courier New">first</FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">rest</FONT><FONT FACE="AGaramond" SIZE=4>
in place of the historically interesting but hopelessly non-mnemonic </FONT><FONT FACE="Courier New">car</FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">cdr</FONT><FONT FACE="AGaramond" SIZE=4>.
 If yours doesn&#39;t, you can just say </FONT><FONT FACE="Courier New">(define
first car)</FONT><FONT FACE="AGaramond" SIZE=4> and </FONT><FONT FACE="Courier New">(define
rest cdr)</FONT><FONT FACE="AGaramond" SIZE=4>.
<BR>
-- Some Scheme implementations allow curly braces or square brackets instead
of parentheses, as a visual aid to matching pairs up.  That&#39;s not standard;
you should just use parentheses and let your environment do the matching
for you.
<BR>
-- There are two equivalent styles for defining functions, which I&#39;ll
call the prototype form and the lambda form.  Sebesta uses the prototype
form, which is shorter and which illustrates what a call might look like:
</FONT><FONT FACE="Courier New">(define (cube x) (* x x x))</FONT><FONT FACE="AGaramond" SIZE=4>.
 I prefer the lambda form, which doesn&#39;t hide the underlying lambda
expression and which is consistent in form with other uses of </FONT><FONT FACE="Courier New">define</FONT><FONT FACE="AGaramond" SIZE=4>:
 </FONT><FONT FACE="Courier New">(define&#160;cube&#160;(lambda&#160;(x)
(* x x x)))</FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Scheme implementations:</B>  The NT machines
in the labs have an implementation of Scheme called EdScheme.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>For use at home, you can download a limited-time
version of EdScheme for free from </FONT><FONT FACE="Courier New"><A HREF="http://www.schemers.com">www.schemers.com</A></FONT><FONT FACE="AGaramond" SIZE=4>;
you can also purchase a copy for about 50% off (see us for details).  We
also recommend DrScheme, another implementation from Rice University that&#39;s
available entirely for free on most every platform (</FONT><FONT FACE="Courier New">www.cs.rice.edu/CS/PLT/packages/drscheme/</FONT><FONT FACE="AGaramond" SIZE=4>).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>Problems:</B>  For most of these problems,
we&#39;ll ask you to print out the transcript window showing your interaction
with the Scheme interpreter.  You&#39;ll probably want to produce a separate
transcript for turning in, rather than printing out pages and pages showing
all your experimentation.  But don&#39;t worry if your transcript contains
a few typos.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(a)</B>  Get used to the Scheme environment.
 Try some expressions like </FONT><FONT FACE="Courier New">(* 123 456)</FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">(expt 2 100)</FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">(/ 3.14159265 2)</FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Type in some definitions of symbols in the
global environment, like </FONT><FONT FACE="Courier New">(define pi 3.14159265)</FONT><FONT FACE="AGaramond" SIZE=4>,
and then try </FONT><FONT FACE="Courier New">(/ pi 2)</FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Type in a function definition like this one:<A NAME="_14_5735"></A></FONT></P>
<P>
<CODE><FONT FACE="Courier New">(define fact                            
     ; Compute n! (n factorial).
<BR>
&#160;&#160; (lambda (n)                                ; 0! is 1 by definition
<BR>
&#160;&#160;  &#160; (cond                                   ; The extra
horizontal space
<BR>
&#160;&#160;  &#160;  &#160; ((&lt;= n 0)  1 )                       ; isn&#39;t
needed; it just lines
<BR>
&#160;&#160;  &#160;  &#160; (else      (* n (fact (- n 1)))))))  ; up the
cond clause parts.</FONT></CODE></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Notice how the environment indents and highlights
blocks of code so you don&#39;t get the parentheses confused.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Make sure you know how to save your code in
a file and load that file into Scheme for evaluation.  EdScheme doesn&#39;t
automatically re-evaluate changes you make in your code, any more than Visual
C++ does (you have to recompile there, too).
<BR>
Try some compound expressions, like </FONT><FONT FACE="Courier New">(gcd
(fact 100) (expt 2 1000))</FONT><FONT FACE="AGaramond" SIZE=4> and</FONT><FONT>
</FONT><FONT FACE="Courier New">(fact (fact 5))</FONT><FONT FACE="AGaramond" SIZE=4>
and </FONT><FONT FACE="Courier New">(first&#160;(rest &#39;(Huey Dewey Louie)))</FONT><FONT FACE="AGaramond" SIZE=4>.
 </FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>What is the value produced by </FONT><FONT FACE="Courier New">(/
(fact 5) (expt 7 2))</FONT><FONT FACE="AGaramond" SIZE=4>?  This result
is called &quot;exact representation&quot;--it looks unusual to us, but
it&#39;s useful in further calculations because nothing is lost by rounding
off to a decimal representation.  On the other hand, evaluate </FONT><FONT FACE="Courier New">(output-fixed-point
(/ (fact 5) (expt 7 2)) 15 10)</FONT><FONT FACE="AGaramond" SIZE=4>.  (The
15 is the total size in characters of the result; the 10 is the number of
digits to the right of the decimal point.)  The code for </FONT><FONT FACE="Courier New">output-fixed-point</FONT><FONT FACE="AGaramond" SIZE=4>
is available on Masterhit, the NT lab server.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>What happens when you evaluate</FONT><FONT>
</FONT><FONT FACE="Courier New">(fact (fact 500))</FONT><FONT FACE="AGaramond" SIZE=4>?</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Play around more with EdScheme, trying other
expressions.  Experiment with the list operators--</FONT><FONT FACE="Courier New">cons</FONT><FONT FACE="AGaramond" SIZE=4>,</FONT><FONT FACE="Courier New">
first</FONT><FONT FACE="AGaramond" SIZE=4>,</FONT><FONT FACE="Courier New">
rest</FONT><FONT FACE="AGaramond" SIZE=4>,</FONT><FONT FACE="Courier New">
list</FONT><FONT FACE="AGaramond" SIZE=4>,</FONT><FONT FACE="Courier New">
append</FONT><FONT FACE="AGaramond" SIZE=4>,</FONT><FONT FACE="Courier New">
null?</FONT><FONT FACE="AGaramond" SIZE=4>--until you&#39;re comfortable
with how they work.  You can look at the online help (available under the
Help menu or question-mark button) for some more information.  To understand
what a function does, be sure you understand what kinds of data it expects
as its arguments (atoms? lists? numbers?) and what kind of data it returns.
 The function </FONT><FONT FACE="Courier New">cons</FONT><FONT FACE="AGaramond" SIZE=4>,
for example, takes any expression as its first argument and a list as its
second argument, and it returns a list.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>You don&#39;t have to turn anything in for
this part (<B>III (a)</B>) of the lab.  But of course if you short-change
the time you spend building familiarity, you&#39;ll have much more trouble
later on.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(b)</B>  This function, called Ackerman&#39;s
function, grows really fast:<A NAME="_14_8111"></A>
<BR>
</FONT><CODE><FONT FACE="Courier New">(define A
<BR>
&#160; (lambda (x y)
<BR>
&#160;   (cond ((= x 0) (+ 1 y))
<BR>
&#160;         ((= y 0) (A (- x 1) 1))
<BR>
&#160;         (else (A (- x 1)
<BR>
&#160;                  (A x (- y 1)))))))
<BR>
</FONT></CODE><FONT FACE="AGaramond" SIZE=4><B>(b.1)  </B>Type it in and
try it out (with very small arguments).  Then print out the Transcript window
showing what you did.  (But you don&#39;t have to print out results that
show pages and pages of solid digits.)</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(b.2)</B>  Rewrite Ackerman&#39;s function
on paper using standard mathematical notation.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c)</B>  What&#39;s the longest number
you can generate in the Scheme you&#39;re using, without running out of
memory and taking no more than 60 seconds of processor time?  Generating
the big numbers is one part of the question; counting the digits is another.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.1)</B>  Try using </FONT><FONT FACE="Courier New">(string-length
(number-&gt;string </FONT><FONT FACE="AGaramond" SIZE=4><I><U>your-big-number</U></I></FONT><FONT FACE="Courier New">))</FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.2)</B>  Try to approximate it using
the log base 10.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.3)</B>  Try to do it using some tool(s)
other than Scheme (or any programming language).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.4)</B>  Using your wristwatch (or slow,
measured counting), time how long it takes for Scheme to calculate and display
your big number.  Now, time how long it takes to calculate the big number
<I>and then</I> its length (by nesting the expression to generate the big
number inside the length-calculating expression from part <B>(c.1)</B> or
<B>(c.2)</B>).  You&#39;d expect the second to take longer, but on some
Scheme systems it doesn&#39;t.  Does it on your system?  Why might the generate-and-calculate-length
task take <I>less</I> time?</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(c.5)</B>  Type up your answers to these
questions and print a transcript showing what you did.  Again, don&#39;t
print more than a page or two of solid digits.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4><B>(d)</B>  Write each of the following functions
in Scheme.  For each, pay attention to the type of value that&#39;s returned:
 Is it a list, a single item, a number, a boolean?  If you&#39;re new to
recursive thinking, it will take you a while to start seeing the patterns;
that&#39;s why there are so many exercises (and even this many may not be
enough).</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Go back and read what the course reference
sheet says about collaboration.  It&#39;s good to work with your classmates,
but remember that the goal is that you be able to write routines like this
independently.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(member? A B)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>
(true) if </FONT><FONT FACE="Courier" SIZE=2><TT>A</TT></FONT><FONT FACE="AGaramond" SIZE=4>
occurs in the list </FONT><FONT FACE="Courier" SIZE=2><TT>B</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
and</FONT><FONT FACE="AGaramond"> </FONT><FONT FACE="Courier" SIZE=2><TT>#f</TT></FONT><FONT FACE="AGaramond" SIZE=4>
(false) if it doesn't.  (Sebesta solves this in the text, but try it yourself
first.)
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(member? 'a '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#f</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(member? 'a '(b a t t y))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(member? '(b (c)) '(a b (b (c)) d
(b (c))))</TT></FONT><FONT FACE="AGaramond" SIZE=4> returns </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(member? '(b (c)) '(a b (c)))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#f</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(find-all-evens A)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
takes a list of numbers and returns a list containing all the numbers from
the original list that are even.  The predefined predicate </FONT><FONT FACE="Courier" SIZE=2><TT>even?</TT></FONT><FONT FACE="AGaramond" SIZE=4>
is useful here.
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(find-all-evens '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>()</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(find-all-evens '(3 9 7))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>()</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(find-all-evens '(1 2 3 4 5))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(2 4)</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(find-all-evens '(3 2 7 2 6))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(2 2 6)</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(all-even? A)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
takes a list of numbers and returns </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>
if they're all even, and </FONT><FONT FACE="Courier" SIZE=2><TT>#f</TT></FONT><FONT FACE="AGaramond" SIZE=4>
otherwise.
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(all-even? '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(all-even? '(3 5 7 2 6))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#f</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(all-even? '(2 8 0 4 88))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(count-all-matches A B)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns the number of times </FONT><FONT FACE="Courier" SIZE=2><TT>A</TT></FONT><FONT FACE="AGaramond" SIZE=4>
occurs in the list </FONT><FONT FACE="Courier" SIZE=2><TT>B</TT></FONT><FONT FACE="AGaramond" SIZE=4>.
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(count-all-matches 'a '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>0</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(count-all-matches 'a '(a b a c a
d))</TT></FONT><FONT FACE="AGaramond" SIZE=4> returns </FONT><FONT FACE="Courier" SIZE=2><TT>3</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(count-all-matches 'a '(a b (a) c
(a d)))</TT></FONT><FONT FACE="AGaramond" SIZE=4> returns </FONT><FONT FACE="Courier" SIZE=2><TT>1</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(count-all-matches '(a (b)) '(a b
(a (b)) a (b) (a (b)) ((a (b)))))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>2</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(subst A B C)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>C</TT></FONT><FONT FACE="AGaramond" SIZE=4>
with all occurrences of </FONT><FONT FACE="Courier" SIZE=2><TT>A</TT></FONT><FONT FACE="AGaramond" SIZE=4>
changed to </FONT><FONT FACE="Courier" SIZE=2><TT>B</TT></FONT><FONT FACE="AGaramond" SIZE=4>.
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(subst 'x 'y '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>()</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(subst 'a 'b '(a c e))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(b c e)</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(subst 'a 'b '(b c d))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(b c d)</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(subst 'a '(a b) '(a b r a))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>((a b) b r (a b))</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(subst '(a b c) 'abc '(w x (a b c)
y (a b c) z))</TT></FONT><FONT FACE="AGaramond" SIZE=4> returns </FONT><FONT FACE="Courier" SIZE=2><TT>(w
x abc y abc z)</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(first-atom A)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns the first atom in the list </FONT><FONT FACE="Courier" SIZE=2><TT>A</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
no matter how deeply nested.  Use the predefined predicates </FONT><FONT FACE="Courier" SIZE=2><TT>pair?</TT></FONT><FONT FACE="AGaramond" SIZE=4>
and</FONT><FONT FACE="Courier" SIZE=2><TT> null?</TT></FONT><FONT FACE="AGaramond" SIZE=4>
to test whether something is an atom or not.
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(first-atom '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>()</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(first-atom '(a b c))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>a</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(first-atom '(((a b) c)))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>a</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(first-atom '( () a b c))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>()</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
which is easy because </FONT><FONT FACE="Courier" SIZE=2><TT>(atom? '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
is </FONT><FONT FACE="Courier" SIZE=2><TT>#t</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="Courier" SIZE=2><TT>(atomize A)</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns a list of all the atoms in </FONT><FONT FACE="Courier" SIZE=2><TT>A</TT></FONT><FONT FACE="AGaramond" SIZE=4>,
no matter how deeply nested.  (Hint:  Use the predefined function </FONT><FONT FACE="Courier" SIZE=2><TT>(append
L1 L2)</TT></FONT><FONT FACE="AGaramond" SIZE=4> to join the atoms in </FONT><FONT FACE="Courier" SIZE=2><TT>(first
A)</TT></FONT><FONT FACE="AGaramond" SIZE=4> with the atoms in </FONT><FONT FACE="Courier" SIZE=2><TT>(rest
A)</TT></FONT><FONT FACE="AGaramond" SIZE=4>.)
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(atomize '())</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>()</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(atomize '(a b c))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(a b c)</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(atomize '((a b) c))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(a b c)</TT></FONT><FONT FACE="AGaramond" SIZE=4>;
<BR>
</FONT><FONT FACE="Courier" SIZE=2><TT>(atomize '(((a) () (b c)) (d e)))</TT></FONT><FONT FACE="AGaramond" SIZE=4>
returns </FONT><FONT FACE="Courier" SIZE=2><TT>(a () b c d e)</TT></FONT><FONT FACE="AGaramond" SIZE=4>.</FONT></P>
<P>
<FONT FACE="AGaramond" SIZE=4>Again, print out a transcript showing your
definitions and some tests indicating that they&#39;re right.</FONT></P>
<BR CLEAR=ALL>
</BODY>
</HTML>

