<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Generator" CONTENT="Microsoft Word 97">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.01 [en] (Win95; U) [Netscape]">
   <TITLE>Domains of Concern in Software Architectures</TITLE>
</HEAD>
<BODY>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=+1>Domains of Concern in Software
Architectures</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=+1>and Architecture Description
Languages</FONT></FONT></B></CENTER>
<P>
<CENTER><FONT FACE="Variable Width">
<a href="http://www.ics.uci.edu/~neno/">Nenad Medvidovic</a> and 
<a href="http://www.ics.uci.edu/~dsr/">David S. Rosenblum</a></FONT></CENTER>

<CENTER><I><FONT FACE="Variable Width">
<a href="http://www.ics.uci.edu/index.html">Department of Information and Computer Science</a></FONT></I></CENTER>

<CENTER><I><FONT FACE="Variable Width">
<a href="http://www.uci.edu/">University of California, Irvine</a></FONT></I></CENTER>

<CENTER><I><FONT FACE="Variable Width">Irvine, California 92697-3425, U.S.A.</FONT></I></CENTER>

<CENTER><I><FONT FACE="Variable Width">{neno,dsr}@ics.uci.edu</FONT></I></CENTER>


<P><B><FONT FACE="Variable Width">Abstract</FONT></B>

<P><I><FONT FACE="Variable Width">Software architectures shift the focus of developers
from lines-of-code to coarser-grained elements and their interconnection
structure. Architecture description languages (ADLs) have been proposed
as domain-specific languages for the domain of software architecture. There
is still little consensus in the research community on what problems are
most important to address in a study of software architecture, what aspects
of an architecture should be modeled in an ADL, or even what an ADL is.
To shed light on these issues, we provide a framework of </FONT>architectural
domains, or areas of concern in the study of software architectures. We
evaluate existing ADLs with respect to the framework and study the relationship
between architectural and application domains. One conclusion is that,
while the architectural domains perspective enables one to approach architectures
and ADLs in a new, more structured manner, further understanding of architectural
domains, their tie to application domains, and their specific influence
on ADLs is needed.</I>

<P><B>Keywords -</B><I> software architecture, architecture description
language, domain, domain-specific language, architectural domain</I>

<P>
<HR>
<P>
<B>Contents<BR>
<UL>
<LI><a href="#1">1. Introduction</a>
<LI><a href="#2">2. Overview of ADLs</a>
  <UL> 
  <LI><a href="#2.1">2.1. Definitions of Architecture and Style</a>
  <LI><a href="#2.2">2.2. Definition of ADLs</a>
  <LI><a href="#2.3">2.3. Categorizing ADLs</a>
  <LI><a href="#2.4">2.4. Applications of ADLs</a>
  <LI><a href="#2.5">2.5. Architecture vs. Design</a>
  </UL>
<LI><a href="#3">3. Architectural Domains</a>
  <UL>
  <LI><a href="#3.1">3.1. Representation</a>
  <LI><a href="#3.2">3.2. Design Process Support</a>
  <LI><a href="#3.3">3.3. Analysis</a>
    <UL>
    <LI><a href="#3.3.1">3.3.1. Static Analysis</a>
    <LI><a href="#3.3.2">3.3.2. Dynamic Analysis</a>
    </UL> 
  <LI><a href="#3.4">3.4. Evolution</a>
    <UL>
    <LI><a href="#3.4.1">3.4.1. Specification-Time Evolution</a>
    <LI><a href="#3.4.2">3.4.2. Execution-Time Evolution</a>
    </UL> 
  <LI><a href="#3.5">3.5. Refinement</a>
  <LI><a href="#3.6">3.6. Traceability</a>
  <LI><a href="#3.7">3.7. Simulation/Executability</a>
  </UL>
<LI><a href="#4">4. ADL Support for Architectural Domains</a>
  <UL>
  <LI><a href="#4.1">4.1. Representation</a>
  <LI><a href="#4.2">4.2. Design Process Support</a>
  <LI><a href="#4.3">4.3. Analysis</a>
    <UL>
    <LI><a href="#4.3.1">4.3.1. Static Analysis</a>
    <LI><a href="#4.3.2">4.3.2. Dynamic Analysis</a>
    </UL> 
  <LI><a href="#4.4">4.4. Evolution</a>
    <UL>
    <LI><a href="#4.4.1">4.4.1. Specification-Time Evolution</a>
    <LI><a href="#4.4.2">4.4.2. Execution-Time Evolution</a>
    </UL> 
  <LI><a href="#4.5">4.5. Refinement</a>
  <LI><a href="#4.6">4.6. Traceability</a>
  <LI><a href="#4.7">4.7. Simulation/Executability</a>
  <LI><a href="#4.8">4.8. Summary</a>
  </UL>
<LI><a href="#5">5. Architectural vs. Application Domains</a>
<LI><a href="#6">6. Conclusions</a>
<LI><a href="#7">7. Acknowledgements</a>
<LI><a href="#8">8. References</a>
<LI><a href="#Footnotes">Footnotes</a>
</UL>
</B><P>
<HR>

<P><a name="1"><B><FONT FACE="Variable Width">1. Introduction</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Software architecture is an aspect
of software engineering directed at reducing costs of developing applications
and increasing the potential for commonality among different members of
a closely related product family [<a href="#PW92">PW92</a>, 
<a href="#GS93">GS93</a>]. Software development based
on common architectural idioms has its focus shifted from lines-of-code
to coarser-grained architectural elements and their overall interconnection
structure. This enables developers to abstract away the unnecessary details
and focus on the "big picture:" system structure, high level communication
protocols, assignment of software components and connectors to hardware
components, development process, and so on.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Many researchers have realized that,
to obtain the benefits of an architectural focus, software architecture
must be provided with its own body of specification languages and analysis
techniques [<a href="#Gar95">Gar95</a>, <a href="#GPT95">GPT95</a>, 
<a href="#Wolf96">Wolf96</a>]. Such languages are needed to demonstrate
properties of a system upstream, thus minimizing the costs of errors. They
are also needed to provide abstractions adequate for modeling a large system,
while ensuring sufficient detail for establishing properties of interest.
A large number of <I>architecture description languages</I> (ADLs) has
been proposed, each of which embodies a particular approach to the specification
and evolution of an architecture. Examples are 
Rapide [<a href="#LKA+95">LKA+95</a>, <a href="#LV95">LV95</a>], 
Aesop [<a href="#GAO94">GAO94</a>], 
MetaH [<a href="#Ves96">Ves96</a>], 
UniCon [<a href="#SDK+95">SDK+95</a>], 
Darwin [<a href="#MDEK95">MDEK95</a>, <a href="#MK96">MK96</a>], 
Wright [<a href="#AG94a">AG94a</a>, <a href="#AG94b">AG94b</a>], 
C2 [<a href="#MTW96">MTW96</a>, <a href="#MORT96">MORT96</a>,  
<a href="#Med96">Med96</a>], and 
SADL [<a href="#MQR95">MQR95</a>]. 
Recently, initial work has been done on an architecture interchange language, 
ACME [<a href="#GMW95">GMW95</a>, <a href="#GMW97">GMW97</a>], which is 
intended to support mapping of architectural specifications
from one ADL to another, and hence provide a bridge for their different
foci and resulting support tools.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>There is still very much a lack of
consensus in the research community on what an ADL is, what aspects of
an architecture should be modeled by an ADL, and what should be interchanged
in an interchange language. This divergence has resulted in a wide variation
of approaches found in this first generation of ADLs. Perhaps even more
significantly, there is a wide difference of opinions as to what problems
are most important to address in a study of software architecture.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>In our previous research, we have provided
a foundation for understanding, defining, classifying, and comparing ADLs
[<a href="#Med97">Med97</a>, <a href="#MT97">MT97</a>]. In this paper, we build upon those results by identifying
and characterizing <I>architectural domains</I>, the problems or areas
of concern that need to be addressed by ADLs. Understanding these domains
and their properties is a key to better understanding the needs of software
architectures, architecture-based development, and architectural description
and interchange. A study of architectural domains is also needed to guide
the development of next-generation ADLs.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>This paper presents a framework of
architectural domains. We demonstrate that each existing ADL currently
supports only a small subset of these domains, and we discuss possible
reasons for that. Finally, we consider the relationship between architectural
domains and application domains.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>While we draw from previous ADL work
and reference a number of ADLs, the most significant contribution of this
paper is the framework of architectural domains. It provides structure
to a field that has been approached largely in an ad-hoc fashion thus far.
The framework gives the architect a sound foundation for selecting an ADL
and orients discourse away from arguments about notation and more towards
solving important engineering problems.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The remainder of the paper is organized
as follows. <a href="#2">Section 2</a> provides a short discussion of ADLs. 
<a href="#3">Section 3</a> presents
and motivates each architectural domain, while <a href="#4">Section 4</a> discusses the
support for architectural domains in existing ADLs. <a href="#5">Section 5</a> expounds
on the relationship between application domains and architectural domains.
Discussion and conclusions round out the paper.</FONT></FONT>

<P><a name="2"><B><FONT FACE="Variable Width">2. Overview of ADLs</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>To properly enable further discussion,
several definitions are needed. In this section, we define software architectures,
architectural styles, and ADLs.<a name = "foot1-txt"><a href="#foot1"><FONT SIZE=-1>[Footnote 1]</FONT></a> We categorize ADLs, differentiate them

from other, similar notations, and discuss examples of use of ADLs in actual
projects. Finally, we provide a short discussion on our use of the terms
"architecture" and "design."</FONT></FONT>

<P><a name="2.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>2.1. Definitions of Architecture and Style</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>There is no standard definition of architecture,
but we will use as our working definition the one provided by Garlan and
Shaw [<a href="#GS93">GS93</a>]:</FONT></FONT>
<DIR><FONT FACE="Variable Width"><FONT SIZE=+0><I>[</I>Software architecture <I>is
a level of design that] goes beyond the algorithms and data structures
of the computation: designing and specifying the overall system structure
emerges as a new kind of problem. Structural issues include gross organization
and global control structure; protocols for communication, synchronization,
and data access; assignment of functionality to design elements; physical
distribution; composition of design elements; scaling and performance;
and selection among design alternatives.</I></FONT></FONT></DIR>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>Architectural style </I>is "a set of
design rules that identify the kinds of components and connectors that
may be used to compose a system or subsystem, together with local or global
constraints on the way the composition is done" [<a href="#SC96">SC96</a>].</FONT></FONT>

<P><a name="2.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>2.2. Definition of ADLs</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Loosely defined, "an <I>ADL </I>for software
applications focuses on the high-level structure of the overall application
rather than the implementation details of any specific source module" 
[<a href="#Ves93">Ves93</a>].
ADLs provide both a concrete syntax and a conceptual framework for modeling
a software system's <I>conceptual </I>architecture.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The building blocks of an architectural
description are</FONT></FONT>
<UL>
<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>components </I>- units of computation
or data stores;</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>connectors </I>- architectural building
blocks used to model interactions among components and rules that govern
those interactions; and</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>architectural configurations </I>-
connected graphs of components and connectors that describe architectural
structure.</FONT></FONT></LI>
</UL>
<FONT FACE="Variable Width"><FONT SIZE=+0>An ADL must provide the means for their
<I>explicit </I>specification; this criterion enables one to determine
whether or not a particular notation is an ADL. In order to infer any kind
of information about an architecture, at a minimum, <I>interfaces </I>of
constituent components must also be modeled formally. Without this information,
an architectural description becomes but a collection of (interconnected)
identifiers.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>An ADL's conceptual framework typically
subsumes a formal semantic theory. That theory is part of the ADL's underlying
framework for characterizing architectures; it influences the ADL's suitability
for modeling particular kinds of systems (e.g., highly concurrent systems)
or particular aspects of a given system (e.g., its static properties).
Examples of formal specification theories are 
Petri nets [<a href="#Pet62">Pet62</a>], 
Statecharts [<a href="#Har87">Har87</a>], 
partially-ordered event sets [<a href="#LVB+93">LVB+93</a>], 
communicating sequential processes (CSP) [<a href="#Hoa85">Hoa85</a>], 
model-based formalisms (e.g., 
CHemical Abstract Machine [<a href="#IW95">IW95</a>], 
Z [<a href="#Spi89">Spi89</a>]), 
algebraic formalisms (e.g., Obj [<a href="#GW88">GW88</a>]), and
axiomatic formalisms (e.g., Anna [<a href="#Luc87">Luc87</a>]).</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Finally, even though the suitability
of a given language for modeling architectures is independent of whether
and what kinds of <I>tool support </I>it provides, an accompanying toolset
will render an ADL both more usable and useful. Furthermore, capabilities
provided by such a toolset are often a direct reflection of the ADL's intended
use.</FONT></FONT>

<P><a name="2.3"><B><FONT FACE="Variable Width"><FONT SIZE=+0>2.3. Categorizing ADLs</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Existing languages that are commonly referred
to as ADLs can be grouped into three categories, based on how they model
configurations:</FONT></FONT>
<UL>
<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>implicit configuration languages </I>model
configurations implicitly through interconnection information that is distributed
across definitions of individual components and connectors;</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>in-line configuration languages </I>model
configurations explicitly, but specify connector information only as part
of the configuration, "in line";</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>explicit configuration languages </I>model
both components and connectors separately from configurations.</FONT></FONT></LI>
</UL>
<FONT FACE="Variable Width"><FONT SIZE=+0>The first category, implicit configuration
languages, are, by definition given in this paper, not ADLs, although they
may serve as useful tools in modeling certain aspects of architectures.
An example of an implicit configuration language is 
ArTek [<a href="#TLPD95">TLPD95</a>]. In
ArTek, there is no configuration specification; instead, each connector
specifies component ports to which it is attached.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The focus on conceptual architecture
and explicit treatment of connectors as first-class entities differentiate
ADLs from module interconnection languages (MILs) 
[<a href="#DK76">DK76</a>, <a href="#PN86">PN86</a>], programming
languages, and object-oriented notations and languages (e.g., Unified Method
[<a href="#BR95">BR95</a>]). MILs typically describe the uses relationships among modules in
an <I>implemented </I>system and support only one type of connection 
[<a href="#AG94a">AG94a</a>, <a href="#SG94">SG94</a>]. 
Programming languages describe a system's implementation, whose
architecture is typically implicit in subprogram definitions and calls.
Explicit treatment of connectors also distinguishes ADLs from OO languages,
as demonstrated in [<a href="#LVM95">LVM95</a>].</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>It is important to note, however, that
there is less than a firm boundary between ADLs and MILs. Certain ADLs,
e.g., Wright and Rapide, model components and connectors at a high level
of abstraction and do not assume or prescribe a particular relationship
between an architectural description and an implementation. We refer to
these languages as being <I>implementation independent</I>. On the other
hand, several ADLs, e.g., UniCon and MetaH, enforce a high degree of fidelity
of an implementation to its architecture. Components modeled in these languages
are directly related to their implementations, so that a module interconnection
specification may be indistinguishable from an architectural description
in such a language. These are <I>implementation constraining </I>languages.</FONT></FONT>

<P><a name="2.4"><B><FONT FACE="Variable Width"><FONT SIZE=+0>2.4. Applications of ADLs</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>ADLs are special purpose notations whose
very specific foci render them suitable for powerful analyses, simulation,
and automated code generation. However, they have yet to find their place
in mainstream software development. Although current research is under
way to bridge the gap that separates ADLs from more widely used design
notations [<a href="#RMRR97">RMRR97</a>], only a small number of existing ADLs have been applied
to large-scale, "real-world" examples to date. What these examples do demonstrate
is the potential for effective use of ADLs in software projects.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Wright was used to model and analyze
the <I>Runtime Infrastructure </I>(RTI) of the Department of Defense (DoD)
<I>High-Level Architecture for Simulations </I>(HLA) 
[<a href="#All96">All96</a>]. The original
specification for RTI was over 100 pages long. Wright was able to substantially
condense the specification and reveal several inconsistencies and weaknesses
in it.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>SADL was applied to an operational
power-control system, used by the Tokyo Electric Power Company. The system
was implemented in 200,000 lines of Fortran 77 code. SADL was used to formalize
the system's reference architecture and ensure its consistency with the
implementation architecture.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Finally, Rapide has been used in several
large-scale projects thus far. A representative example is the X/Open Distributed
Transaction Processing (DTP) Industry Standard. The documentation for the
standard is over 400 pages long. Its reference architecture and subsequent
extensions have been successfully specified and simulated in 
Rapide [<a href="#LKA+95">LKA+95</a>].</FONT></FONT>

<P><a name="2.5"><B><FONT FACE="Variable Width"><FONT SIZE=+0>2.5. Architecture vs. Design</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Given the above definition of software
architectures and ADLs, an issue worth addressing is the relationship between
architecture and design. Current literature leaves this question largely
unanswered, allowing for several interpretations:</FONT></FONT>
<UL>
<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>architecture and design are the same;</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>architecture is at a level of abstraction
above design, so it is simply another step (artifact) in a software development
process; and</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>architecture is something new and is somehow
different from design (but just how remains unspecified).</FONT></FONT></LI>
</UL>
<FONT FACE="Variable Width"><FONT SIZE=+0>All three interpretations are partially
correct. To a large extent, architectures serve the same purpose as design.
However, their explicit focus on connectors and configurations distinguishes
them from traditional software design. At the same time, as a (high level)
architecture is refined, connectors lose prominence by becoming distributed
across the (lower level) architecture's elements. Such a lower level architecture
may indeed be considered to be a design. Keeping this relationship in mind,
for reasons of simplicity we will simply refer to architectures as "high
level," "low level," and so forth, in the remainder of the paper, while
"design" will only refer to the process that results in an architecture.</FONT></FONT>

<P><a name="3"><B><FONT FACE="Variable Width">3. Architectural Domains</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>ADLs typically share syntactic constructs
that enable them to model components and component interfaces, connectors,
and configurations.<a name = "foot2-txt"><a href="#foot2"><FONT SIZE=-1>[Footnote 2]</FONT></a> A much greater source of divergence are the different
ADLs' conceptual frameworks, and, consequently, their support for modeling
architectural semantics. ADL developers typically have decided to focus
on a specific aspect of architectures, or an <I>architectural domain</I>,
which guides their selection of an underlying semantic model and a set
of related formal specification notations. These formal notations, in turn,
restrict the types of problems for which the ADL is suitable.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>This relationship between an architectural
domain and candidate formal notations is rarely straightforward or fully
understood. In the absence of objective criteria, ADL researchers are forced
to base their decisions on intuition, experience, and biases arising from
past research accomplishments. Unfortunately, intuition can often be misleading
and experience insufficient in a young discipline such as software architectures.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>In this paper, we attempt to fill this
void. The remainder of this section motivates and formulates a framework
for classifying the problems on which architectural models focus (architectural
domains), shown in <a href="#Fig.1">Figure 1</a>. Architectural domains represent broad classes
of problems and are likely to be reflected in many ADLs and their associated
formal specification language constructs. Their proper understanding is
thus necessary. Furthermore, heuristics may be developed over time that
will enable easier interchange of architectures modeled in ADLs that focus
on particular architectural domains. Finally, such a framework can be used
as a guide in developing future ADLs.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=-1>&nbsp;</FONT></FONT>

<P>
<a name="Fig.1"><img src=fig1.jpg border=2>
<P><FONT SIZE=+0><FONT FACE="Variable Width"><B>Figure 1: </B></FONT>Architectural domains.</FONT><FONT SIZE=+0></FONT>

<P><a name="3.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.1. Representation</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>A key role of an explicit representation
of an architecture is to aid understanding and communication about a software
system among different stakeholders. For this reason, it is important that
architectural descriptions be simple, understandable, and possibly graphical,
with well understood, but not necessarily formally defined, semantics.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Architectural models typically comprise
multiple views, e.g., high level graphical view, lower level view with
formal specifications of components and connectors, conceptual architecture,
one or more implementation architectures, corresponding development process,
data or control flow view, and so on. Different stakeholders (e.g., architects,
developers, managers, customers) may require different views of the architecture.
The customers may be satisfied with a high-level, "boxes and arrows" description,
the developers may want detailed component and connector models, while
the managers may require a view of the development process.</FONT></FONT>

<P><a name="3.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.2. Design Process Support</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Software architects decompose large, distributed,
heterogeneous systems into smaller building blocks. In doing so, they have
to consider many issues, make many decisions, and utilize many design techniques,
methodologies, and tools.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Modeling architectures from multiple
perspectives, discussed in the previous subsection, is only one way of
supporting software architects' cognitive processes. Others include delivering
design guidance in a timely and understandable fashion, capturing design
rationale, and revisiting past design steps.</FONT></FONT>

<P><a name="3.3"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.3. Analysis</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Architectures are often intended to model
large, distributed, concurrent systems. The ability to evaluate the properties
of such systems upstream, at the architectural level, can substantially
lessen the number of errors passed downstream. Given that unnecessary details
are abstracted away in architectures, the analysis task may also be easier
to perform than at source code level.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Analysis of architectures may be performed
statically, before execution, or dynamically, at runtime. Certain types
of analysis can be performed both statically and dynamically.</FONT></FONT>

<P><a name="3.3.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.3.1. Static Analysis</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Examples of static analysis are internal
consistency checks, such as whether appropriate components are connected
and their interfaces match, whether connectors enable desired communication,
whether constraints are satisfied, and whether the combined semantics of
components and connectors result in desired system behavior. Certain concurrent
and distributed aspects of an architecture can also be assessed statically,
such as the potential for deadlocks and starvation, performance, reliability,
security, and so on. Finally, architectures can be statically analyzed
for adherence to design heuristics and style rules.</FONT></FONT>

<P><a name="3.3.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.3.2. Dynamic Analysis</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Examples of dynamic analysis are testing,
debugging, assertion checking, and assessment of the performance, reliability,
and schedulability of an executing architecture. Saying that an architecture
is executing can mean two different things:</FONT></FONT>
<UL>
<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>the system built based on the architecture
is executing, or</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>the runtime behavior of the architecture
itself is being simulated.</FONT></FONT></LI>
</UL>
<FONT FACE="Variable Width"><FONT SIZE=+0>Clearly, certain analyses, such as performance
or reliability, are more meaningful or even only possible in the former
case. However, an implementation of the system may not yet exist. Furthermore,
it may be substantially less expensive to perform dynamic analyses in the
latter case, particularly when the relationship between the architecture
and the implemented system is well understood.</FONT></FONT>

<P><a name="3.4"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.4. Evolution</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Support for software evolution is a key
aspect of architecture-based development. Architectures evolve to reflect
evolution of a single software system; they also evolve into families of
related systems. As design elements, individual components and connectors
within an architecture may also evolve.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Evolution of components, connectors,
and architectures can occur at specification time or execution time.</FONT></FONT>

<P><a name="3.4.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.4.1. Specification-Time Evolution</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>If we consider components and connectors
to be types which are instantiated every time they are used in an architecture,
their evolution can be viewed simply in terms of subtyping. Since components
and connectors are modeled at a high level of abstraction, flexible subtyping
methods may be employed. For example, it may be useful to evolve a single
component in multiple ways, by using different subtyping mechanisms (e.g.,
interface, behavior, or a combination of the two) 
[<a href="#MORT96">MORT96</a>].</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>At the level of architectures, evolution
is focused on incremental development and support for system families.
Incrementality of an architecture can further be viewed from two different
perspectives. One is its ability to accommodate addition of new components
and the resulting issues of scale; the other is specification of incomplete
architectures.</FONT></FONT>

<P><a name="3.4.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.4.2. Execution-Time Evolution</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Explicit modeling of architectures
is intended to support development and evolution of large and potentially
long-running systems. Being able to evolve such systems during execution
may thus be desirable and, in some cases, necessary. Architectures exhibit
dynamism by allowing replication, insertion, removal, and reconnection
of architectural elements or subarchitectures during execution.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Dynamic changes of an architecture
may be either planned at architecture specification time or unplanned.
Both types of dynamic change must be constrained to ensure that no desired
architectural properties are violated.</FONT></FONT>

<P><a name="3.5"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.5. Refinement</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>The most common argument for creating
and using formal architectural models is that they are necessary to bridge
the gap between informal, "boxes and arrows" diagrams and programming languages,
which are deemed too low-level for designing a system. Architectural models
may need to be specified at several levels of abstraction for different
purposes. For example, a high level specification of the architecture can
be used as an understanding and communication tool; a subsequent lower
level may be analyzed for consistency of interconnections; an even lower
level may be used in a simulation. Therefore, correct and consistent refinement
of architectures to subsequently lower levels of abstraction is imperative.
Note that, in this sense, code generation is simply a special case of architectural
refinement.</FONT></FONT>

<P><a name="3.6"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.6. Traceability</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>As discussed above, a software architecture
often consists of multiple views and may be modeled at multiple levels
of abstraction (<a href="#Fig.2">Figure 2</a>). We call a particular view of the architecture
at a given level of abstraction (i.e., a single point in the two-dimensional
space of <a href="#Fig.2">Figure 2</a>) an "architectural cross-section." It is critical for
changes in one cross-section to be correctly reflected in others. A particular
architectural cross-section can be considered "dominant," so that <I>all
</I>changes to the architecture are made to it and then reflected in others.
However, changes will more frequently be made to the most appropriate or
convenient cross-section. Traceability support will hence need to exist
across all pertinent cross-sections.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>One final issue is the consistency
of an architecture with system requirements. Changes to the requirements
must be appropriately reflected in the architecture; changes to the architecture
must be validated against the requirements. Therefore, even though system
requirements are in the problem domain, while architecture is in the solution
domain, traceability between the two is crucial. For purposes of traceability,
requirements can be considered to be at a very high level of architectural
abstraction, as shown in <a href="#Fig.2">Figure 2</a>.</FONT></FONT>

<P><FONT FACE="Courier"><FONT SIZE=-1>&nbsp;</FONT></FONT>

<P>
<a name="Fig.2"><img src=fig2.jpg border=2>
<P><FONT SIZE=+0><FONT FACE="Variable Width"><B>Figure 2: </B></FONT>Two-dimensional
space of architectural views and levels of abstraction. The vertical axis
is a set of discrete values with a nominal ordering. The horizontal axis
is a continuum with an ordinal ordering of values, where system requirements
are considered to be the highest level of abstraction and source code the
lowest. One possible dominant cross-section (graphical view of the high
level architecture) is shown.</FONT><FONT SIZE=+0></FONT>

<P><a name="3.7"><B><FONT FACE="Variable Width"><FONT SIZE=+0>3.7. Simulation/Executability</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Static architectural models are useful
for establishing static properties of the modeled system. Certain dynamic
properties may also be predicted with static models, but only if specific
assumptions hold. For example, if the architect can correctly predict execution
time and criticality of each component, then schedulability of the encompassing
architecture can be evaluated.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>On the other hand, other dynamic properties,
such as reliability, may by definition require a running system. Also,
developers may want to produce an early prototype to, e.g., attempt allocation
of architectural elements to components of the physical system. Other stakeholders
(e.g., customers or managers) may want to verify early on that the architecture
conforms to their wishes. Simulating the dynamic behavior of a high level
architecture may thus be preferred to implementing the system: it is a
quicker, cheaper, and more flexible way of arriving at the desired information.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>A special case of architectural simulation
is the execution of the complete implemented system. The ultimate goal
of any software design and modeling endeavor is to produce such a system.
An elegant and effective architectural model is of limited value, unless
it can be converted into a running application. A simulation can only partially
depict the final system's dynamic behavior. Manually transforming an architecture
into a running system may result in many, already discussed problems of
consistency and traceability between the architecture and its implementation.
Techniques, such as refinement and traceability discussed above, must be
employed to properly accomplish this task.</FONT></FONT>

<P><a name="4"><B><FONT FACE="Variable Width">4. ADL Support for Architectural Domains</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>In the previous section, we motivated
and described different architectural domains in terms of their characteristics
and needs of software architectures. Another way of viewing architectural
domains is in terms of modeling languages and specific language features
needed to support different domains. At the same time, a useful way of
understanding and classifying architecture modeling languages is in terms
of architectural domains they are intended to support. For these reasons,
this section studies the kinds of language facilities that are needed to
support each architectural domain, as well as the specific features existing
ADLs employ to that end. Our hope is that this discussion will shed light
on the relationships among different architectural domains (and their resulting
ADL features) and point out both where they can be effectively combined
and where we can expect difficulties.</FONT></FONT>

<P><a name="4.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.1. Representation</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Ideally, an ADL should make the structure
of a system clear from a configuration specification alone, i.e., without
having to study component and connector specifications. Architecture descriptions
in <I>in-line configuration ADLs</I>, such as Darwin, MetaH, and Rapide
tend to be encumbered with connector details, while <I>explicit configuration
ADLs</I>, such as ACME, Aesop, C2, SADL, UniCon, and Wright have the best
potential to facilitate understandability of architectural structure.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>One common way of facilitating understandability
and communication is by providing a graphical notation, in addition to
the textual notation. However, this is only the case if there is a precise
relationship between a graphical description and the underlying semantic
model. For example, Aesop, C2, Darwin, MetaH, Rapide, and UniCon support
such "semantically sound" graphical notations, while ACME, SADL, and Wright
do not.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>ADLs must also be able to model the
architecture from multiple perspectives. As discussed above, several ADLs
support at least two views of an architecture: textual and graphical. Each
of these ADLs also allows both top-level and detailed views of composite
elements. Aesop, MetaH, and UniCon further distinguish different types
of components and connectors iconically.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Support for other views is sparse.
C2 provides a view of the development process that corresponds to the architecture
[<a href="#RR96">RR96</a>]. Darwin's <I>Software Architect's Assistant</I>
[<a href="#NKM96">NKM96</a>] provides
a hierarchical view of the architecture which shows all the component types
and the "include" relationships among them in a tree structure. Rapide
allows visualization of an architecture's execution behavior by building
its simulation and animating its execution. Rapide also provides a tool
for viewing and filtering events generated by the simulation.</FONT></FONT>

<P><a name="4.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.2. Design Process Support</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>As the above examples of C2's, Darwin's,
and Rapide's support tools indicate, language features can only go so far
in supporting software architects. Adequate tools are also needed. A category
of tools that is critical for adequately supporting the design process
are <I>active specification tools</I>; they can significantly reduce the
cognitive load on architects.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Only a handful of existing ADLs provide
tools that actively support specification of architectures. In general,
such tools can be proactive or reactive. UniCon's graphical editor is proactive.
It invokes UniCon's language processing facilities to <I>prevent </I>errors
during design. Reactive specification tools detect <I>existing </I>errors.
They may either only inform the architect of the error (<I>non-intrusive</I>)
or also force the architect to correct it before moving on (<I>intrusive</I>).
An example of the former is C2's design environment, <I>Argo</I>, while
MetaH's graphical editor is an example of the latter.</FONT></FONT>

<P><a name="4.3"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.3. Analysis</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>The types of analyses for which an ADL
is well suited depend on its underlying semantic model, and to a lesser
extent, its specification features. The semantic model will largely influence
whether the ADL can be analyzed statically or dynamically, or both. For
example, Wright, which is based on communicating sequential processes (CSP)
[<a href="#Hoa85">Hoa85</a>], allows static deadlock analysis of individual connectors and components
attached to them. On the other hand, Rapide architectures, which are modeled
with partially ordered event sets (posets) 
[<a href="#LVB+93">LVB+93</a>], can be analyzed dynamically.</FONT></FONT>

<P><a name="4.3.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.3.1. Static Analysis</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The most common type of static analysis
tools are language parsers and compilers. Parsers analyze architectures
for syntactic correctness, while compilers establish semantic correctness.
All existing ADLs have parsers. Darwin, MetaH, Rapide, and UniCon also
have compilers, which enable these languages to generate executable systems
from architectural descriptions. Wright does not have a compiler, but it
uses FDR [<a href="#For92">For92</a>], a model checker, to establish type conformance.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>There are numerous other possible types
of static analysis of architectures. Several examples are provided by current
ADLs. Aesop provides facilities for checking for type consistency, cycles,
resource conflicts, and scheduling feasibility in its architectures. C2
uses critics to establish adherence to style rules and design guidelines.
MetaH and UniCon both currently support schedulability analysis by specifying
non-functional properties, such as criticality and priority. Finally, given
two architectures, SADL can establish their relative correctness with respect
to a refinement map.</FONT></FONT>

<P><a name="4.3.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.3.2. Dynamic Analysis</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The ability to analyze an architecture
dynamically directly depends on the ADL's ability to model its dynamic
behavior. To this end, ADLs can employ specification mechanisms, such as
event posets, CHAM, or temporal logic, which can express dynamic properties
of a system. Another aspect of dynamic analysis is enforcement of constraints
at runtime.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Most existing ADLs tend to view architectures
statically, so that current support for dynamic modeling and analysis is
scarce. Darwin enables dynamic analysis of architectures by instantiating
parameters and components to enact "what if" scenarios. Similarly, Rapide
<I>Poset Browser</I>'s event filtering features and <I>Animation Tools
</I>facilitate analysis of architectures through simulation. Rapide's <I>Constraint
Checker </I>also analyzes the conformance of a Rapide simulation to the
formal constraints defined in the architecture. Finally, runtime systems
of those ADLs that provide architecture compilation support can be viewed
as dynamic analysis facilities.</FONT></FONT>

<P><a name="4.4"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.4. Evolution</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>An architecture can evolve in two different
dimensions:</FONT></FONT>
<UL>
<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>evolution of individual components and
connectors, where the structure of the architecture is not affected, although
its behavior may be; and</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0>evolution of the entire architecture,
which affects both the structure and behavior of an architecture.</FONT></FONT></LI>
</UL>
<FONT FACE="Variable Width"><FONT SIZE=+0>Evolution in these two dimensions can
occur both at architecture specification time and while the architecture
is executing.<a name="foot3-txt"><a href="#foot3"><FONT SIZE=-1>[Footnote 3]</FONT></a></FONT></FONT>

<P><a name="4.4.1"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.4.1. Specification-Time Evolution</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>ADLs can support specification-time
evolution of individual components and connectors with subtyping. Only
a subset of existing ADLs provide such facilities, and even their evolution
support is limited and often relies on the chosen implementation (programming)
language. The remainder of the ADLs view and model components and connectors
as inherently static.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Aesop supports behavior-preserving
subtyping of components and connectors to create substyles of a given architectural
style. Rapide allows its interface types to inherit from other types by
using OO methods, resulting in structural subtyping. ACME also supports
structural subtyping via its <I>extends </I>feature. C2 provides a more
sophisticated subtyping and type checking mechanism. Multiple subtyping
relationships among components are allowed: name, interface, behavior,
and implementation subtyping, as well as their combinations 
[<a href="#MORT96">MORT96</a>].</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Specification-time evolution of complete
architectures has two facets: support for incremental development and support
for system families. Incrementality of an architecture can be viewed from
two different perspectives. One is its ability to accommodate addition
of new components to the architecture. In general, <I>explicit configuration
ADLs </I>can support incremental development more easily and effectively
than <I>in-line configuration ADLs</I>; ADLs that allow variable numbers
of components to communicate through a connector are well suited for incremental
development, particularly when faced with unplanned architectural changes
[<a href="#Med97">Med97</a>].</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Another view of incrementality is an
ADL's support for incomplete architectural descriptions. Incomplete architectures
are common during design, as some decisions are deferred and others have
not yet become relevant. However, most existing ADLs and their supporting
toolsets have been built to prevent precisely these kinds of situations.
For example, Darwin, MetaH, Rapide, and UniCon compilers, constraint checkers,
and runtime systems have been constructed to raise exceptions if such situations
arise. In this case, an ADL, such as Wright, which focuses its analyses
on information local to a single connector is better suited to accommodate
expansion of the architecture than, e.g., SADL, which is very rigorous
in its refinement of <I>entire </I>architectures.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Still another aspect of static evolution
is support for application families. In [<a href="#MT96">MT96</a>], we showed that the number
of possible architectures in a component-based style grows exponentially
as a result of a linear expansion of a collection of components. All such
architectures may not belong to the same logical family. Therefore, relying
on component and connector inheritance, subtyping, or other evolution mechanisms
is insufficient. An obvious solution, currently adopted only by ACME, is
to provide a language construct that allows the architect to specify the
family to which the given architecture belongs.</FONT></FONT>

<P><a name="4.4.2"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.4.2. Execution-Time Evolution</FONT></FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>There are presently two approaches
to supporting evolution of architectures at execution time. The first is
what Oreizy calls "constrained dynamism": all runtime changes to the architecture
must be known a priori and are specified as part of the architectural model
[<a href="#Ore96">Ore96</a>].</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Two existing ADLs support constrained
dynamism. Rapide supports conditional configuration; its <I>where </I>clause
enables a form of architectural rewiring at runtime, using the <I>link
</I>and <I>unlink </I>operators. Darwin allows runtime replication of components
using the <I>dyn </I>operator.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The second approach to execution time
evolution places no restrictions at architecture specification time on
the kinds of allowed changes. Instead, the ADL has an architecture modification
feature, which allows the architect to specify changes while the architecture
is running.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Darwin and C2 are the only ADLs that
support such "pure dynamism" [<a href="#Ore96">Ore96</a>]. Darwin allows deletion and rebinding
of components by interpreting Darwin scripts. C2 specifies a set of operations
for insertion, removal, and rewiring of elements in an architecture at
runtime [<a href="#Med96">Med96</a>]. C2's <I>ArchShell </I>tool enables arbitrary interactive
construction, execution, and runtime-modification of C2-style architectures
by dynamically loading and linking new architectural elements 
[<a href="#Ore96">Ore96</a>, <a href="#MOT97">MOT97</a>].
An issue that needs further exploration is constraining pure dynamic evolution
to ensure that the desired properties of architectures are maintained.</FONT></FONT>

<P><a name="4.5"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.5. Refinement</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>ADLs provide architects with expressive
and semantically elaborate facilities for specification of architectures.
However, an ADL must also enable correct and consistent refinement of architectures
to subsequently lower levels of abstraction, and, eventually, to executable
systems.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>An obvious way in which ADLs can support
refinement is by providing patterns, or maps, that, when applied to an
architecture, result in a related architecture at a lower level of abstraction.
SADL and Rapide are the only two ADLs that provide such support. SADL uses
maps to enable correct architecture refinements across styles, while Rapide
generates comparative simulations of architectures at different abstraction
levels. Both approaches have certain drawbacks, indicating that a hybrid
approach may be useful.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Garlan has recently argued that refinement
should not be consistent with respect to a single (immutable) law, but
rather with respect to particular properties of interest, be they conservative
extension (SADL), computational behavior (Rapide), or something entirely
different, such as performance [<a href="#Gar96">Gar96</a>]. This may be a good starting point
towards a successful marriage of the two approaches.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Several ADLs take a different approach
to refinement: they enable generation of executable systems directly from
architectural specifications. These are typically the i<I>mplementation
constraining languages</I>, such as MetaH and UniCon. These ADLs assume
the existence of a source file that corresponds to a given architectural
element. This approach makes the assumption that the relationship between
elements of an architectural description and those of the resulting system
will be 1-to-1. Given that architectures are intended to describe systems
at a higher level of abstraction than source code modules, this can be
considered only a limited form of refinement.</FONT></FONT>

<P><a name="4.6"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.6. Traceability</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>While the problem of refinement essentially
focuses only on one axis of <a href="#Fig.2">Figure 2</a> (the horizontal axis) and one direction
(left to right), traceability may need to cover a large portion of the
two-dimensional space and is applicable in both directions. This presents
a much more difficult task, indicating why this is the architectural domain
in which existing ADLs are most lacking.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The relationships among architectural
views (vertical axis) are not always well understood. For example, ADLs
commonly provide support for tracing changes between textual and graphical
views, such that changes in one view are automatically reflected in the
other; however, it may be less clear how the data flow view should affect
the process view. In other cases, changes in one view (e.g., process) should
never affect another (e.g., control flow). An even bigger hurdle is providing
traceability support across <I>both </I>architectural views and levels
of abstraction simultaneously. Finally, although much research has been
directed at methodologies for making the transition from requirements to
design (e.g., OO), this process is still an art form. Further research
is especially needed to understand the effects of changing requirements
on architectures and vice versa.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Traceability is particularly a problem
in the way implementation constraining languages approach code generation,
discussed in the previous subsection. These ADLs provide no means of guaranteeing
that the source modules which are supposed to implement architectural components
will do so correctly. Furthermore, even if the specified modules currently
implement the needed behavior correctly, there is no guarantee that any
future changes to those modules will be traced back to the architecture
and vice versa.</FONT></FONT>

<P><a name="4.7"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.7. Simulation/Executability</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>As with dynamic analysis 
(<a href="#4.3.2">Section 4.3.2</a>),
simulating an architecture will directly depend upon the ADL's ability
to model its dynamic behavior. Currently, Rapide is the only ADL that can
simulate the architecture itself, by generating event posets. Other ADLs
enable generation of running systems corresponding to the architecture.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>MetaH and UniCon require preexisting
component implementations in Ada and C, respectively, in order to generate
applications. Darwin can also construct executable systems in the same
manner in C++, and Rapide in C, C++, Ada, VHDL, or its executable sublanguage.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>C2 and Aesop provide class hierarchies
for their concepts and operations, such as components, connectors, and
interconnection and message passing protocols. These hierarchies form a
basis from which an implementation of an architecture may be produced.
Aesop's hierarchy has been implemented in C++, and C2's in C++, Java, and
Ada.</FONT></FONT>

<P><a name="4.8"><B><FONT FACE="Variable Width"><FONT SIZE=+0>4.8. Summary</FONT></FONT></B>
<P>
<FONT FACE="Variable Width"><FONT SIZE=+0>Existing ADLs span a broad spectrum in
terms of the architectural domains they support. On the one hand, languages
like SADL and Wright have very specific, narrow foci. On the other, C2,
Rapide, and Darwin support a number of architectural domains. Certain domains,
e.g., evolution, refinement, and traceability are only sparsely supported,
indicating areas around which future work should be centered. A more complete
summary of this section is given in <a href="#Table1">Table 1</a> below.</FONT></FONT>
<P>
<CENTER><TABLE BORDER CELLPADDING=2 WIDTH="625" >
<TR>
<TD VALIGN=TOP COLSPAN="10"> <a name="Table1">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Table 1: ADL Support for Architectural
Domains</FONT></FONT></B></CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER>&nbsp;<B><FONT SIZE=-1>ARCH.</FONT></B></CENTER>

<CENTER><B><U><FONT SIZE=-1>DOMAIN</FONT></U></B></CENTER>

<CENTER><B><FONT SIZE=-1>ADL</FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Represent.</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Design</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Process</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Support</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Static</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Analysis</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="9%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Dynamic</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Analysis</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="10%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Spec-Time</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Evolution</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="10%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Exec-Time</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Evolution</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="10%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Refinement</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Trace.</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Simulation/</FONT></FONT></B></CENTER>

<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Executability</FONT></FONT></B></CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>ACME</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>explicit config.;
"weblets"</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>application
families</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>rep-maps across
levels</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Aesop</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>explicit config.;
graphical notation; types distinguished iconically</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>syntax directed
editor; specialized editors for visualization classes</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; style-specific
compiler; type, cycle, resource conflict, and scheduling feasibility checker</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>behavior-preserving
subtyping of components and connectors</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1><I>build </I>tool
constructs system glue code in C for pipe-and-filter style</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>C2</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>explicit config.;
graphical notation; process view; simulation; event filtering</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>non-intrusive,
reactive design critics and to-do lists in Argo</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; critics
to establish adherence to style rules and design heuristics</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>event filtering</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>multiple subtyping
mechanisms; allows partial architectures</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>pure dynamism:
element insertion, removal, and rewiring</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>class framework
enables generation of C/C++, Ada, and Java code</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Darwin</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>implicit config.;
graphical notation; hierarchical system view</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>automated addition
of ports; propagation of changes across bound ports; property dialogs</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; compiler</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>"what if" scenarios
by instantiating parameters and dynamic components</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>constrained
dynamism: runtime replication of components and conditional configuration</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>compiler generates
C++ code</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>MetaH</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>implicit config.;
graphical notation; types distinguished iconically</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>intrusive,
reactive graphical editor</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; compiler;
schedulability, reliability, and security analysis</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>compiler generates
Ada code (C code generation planned)</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Rapide</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>implicit config.;
graphical notation; animated simulation; event filtering</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; compiler;
constraint checker to ensure valid mappings</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>event filtering
and animation</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>inheritance
(structural subtyping)</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>constrained
dynamism: conditional configuration and dynamic event generation</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>refinement
maps enable comparative simulations of architectures at different levels</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical;</FONT></FONT></CENTER>


<P><FONT FACE="Variable Width"><FONT SIZE=-1>constraint checking across refinement</FONT></FONT>&nbsp;
<BR><FONT FACE="Variable Width"><FONT SIZE=-1>levels</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>simulation
by generating event posets; system construction in C/C++, Ada, VHDL, and
Rapide</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>SADL</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>explicit config.</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; relative
correctness of architectures w.r.t. a refinement map</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>component and
connector refinement via pattern maps</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>maps enable
correct refinements across levels</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%"><FONT FACE="Variable Width"><FONT SIZE=-1>refinement</FONT></FONT>&nbsp;
<BR><FONT FACE="Variable Width"><FONT SIZE=-1>across levels</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>UniCon</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>explicit config.;
graphical notation</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>proactive GUI
editor invokes language checker</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; compiler;
schedulability analysis</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%">
<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>textual</FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>&lt;-></FONT></FONT></CENTER>

<CENTER><FONT FACE="Variable Width"><FONT SIZE=-1>graphical</FONT></FONT></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>compiler generates
C code</FONT></FONT></TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="7%">
<CENTER><B><FONT FACE="Variable Width"><FONT SIZE=-1>Wright</FONT></FONT></B></CENTER>
</TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>explicit config.</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="11%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>parser; model
checker for type conformance; deadlock analysis of connectors</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="9%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>type conformance
for behaviorally related protocols</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="10%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="8%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>

<TD VALIGN=TOP WIDTH="12%"><FONT FACE="Variable Width"><FONT SIZE=-1>none</FONT></FONT></TD>
</TR>
</TABLE></CENTER>

<P><a name="5"><B><FONT FACE="Variable Width">5. Architectural vs. Application Domains</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Over the past decade there has been
interest in relating architectures, which are in the solution domain, to
the problem (or application) domain, leading to the notion of <I>domain-specific
software architectures (DSSAs) </I>[<a href="#Tra95">Tra95</a>]. A DSSA provides a single (generic)
<I>reference architecture</I>, which reflects the characteristics of a
particular problem domain, and which is instantiated for each specific
application in that domain. <I>Architectural styles</I>, discussed in 
<a href="#2">Section 2</a>,
provide another way of relating the problem and solution spaces. Styles
are largely orthogonal to DSSAs: a single style may be applicable to multiple
application domains; on the other hand, a single DSSA may use multiple
styles.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Any attempt to further explore and
perhaps generalize the relationship between architectural and application
domains would be greatly aided by a classification of application domains.
We are unaware of any such classification, although Jackson identified
a number of <I>domain characteristics </I>that could serve as a starting
point for one [<a href="#Jac95">Jac95</a>]:</FONT></FONT>
<UL>
<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>static </I>vs. <I>dynamic </I>domains,
with the latter being application domains having an element of time, events,
and/or state;</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>one-dimensional </I>vs. <I>multi-dimensional
</I>domains;</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>tangible </I>vs. <I>intangible </I>domains,
with the latter typically involving machine representations of abstractions
(such as user interfaces);</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>inert </I>vs. <I>reactive </I>vs. <I>active
</I>dynamic domains; and</FONT></FONT></LI>

<LI>
<FONT FACE="Variable Width"><FONT SIZE=+0><I>autonomous </I>vs. <I>programmable
</I>vs. <I>biddable </I>active dynamic domains.</FONT></FONT></LI>
</UL>
<FONT FACE="Variable Width"><FONT SIZE=+0>Given these application domain characteristics,
one can easily identify a number of useful relationships with architectural
domains. For instance, support for evolution, executability and dynamic
analysis are more important for dynamic domains than for static domains.
As another example, reactive domains are naturally supported by a style
of representation (e.g., Statecharts [<a href="#Har87">Har87</a>]) that is different from that
in active domains (e.g., CHAM [<a href="#IW95">IW95</a>]). As we deepen our understanding of
architectural domains, we will be able to solidify our understanding of
their relationship with application domains.</FONT></FONT>

<P><a name="6"><B><FONT FACE="Variable Width">6. Conclusions</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Software architecture research has
been moving forward rapidly. A number of ADLs and their supporting toolsets
have been developed; many existing styles have been adopted and new ones
invented. Theoretical underpinnings for the study of software architectures
have also begun to emerge in the form of definitions 
[<a href="#PW92">PW92</a>, <a href="#GS93">GS93</a>] and formal
classifications of styles [<a href="#SC96">SC96</a>] and 
ADLs [<a href="#Med97">Med97</a>, <a href="#MT97">MT97</a>].</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>This body of work reflects a wide spectrum
of views on what architecture is, what aspects of it should be modeled
and how, and what its relationship is to other software development concepts
and artifacts. This divergence of views has also resulted in a divergence
of ADLs' conceptual frameworks (as defined in <a href="#2">Section 2</a>). Such fragmentation
has made it difficult to establish whether there exists in ADLs a notion
similar to computational equivalence in programming languages. Furthermore,
sharing support tools has been difficult.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>ACME has attempted to provide a basis
for interchanging architectural descriptions across ADLs. However, ACME
has thus far been much more successful at achieving architectural interchange
at the syntactic (i.e., structural) level, than at the semantic level.
Although some of the ACME team's recent work looks encouraging, this still
remains an open problem. One of the reasons ACME has encountered difficulties
is precisely the fact that there is only limited agreement in the architecture
community on some fundamental issues, the most critical of which is what
problems architectures should attempt to solve.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>This paper presents an important first
step towards a solution to this problem. We have recognized that the field
of software architecture is concerned with several domains and that every
ADL reflects the properties of one or more domains from this set. Architectural
domains thus provide a unifying view to what had seemed like a disparate
collection of approaches, notations, techniques, and tools. The task of
architectural interchange can be greatly aided by studying the interrelationships
among architectural domains. Existing ADLs can be better understood in
this new light and new ADLs more easily developed to solve a specific set
of problems.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Much further work is still needed,
however. Our current understanding of the relationship between architectural
domains and formal semantic theories (<a href="#2">Section 2</a>) is limited. Also, we need
to examine whether there exist techniques that can more effectively support
the needs of particular architectural domains than those provided by existing
ADLs. Finally, a more thorough understanding of the relationship between
architectural and application domains is crucial if architecture-based
development is to fulfill its potential.</FONT></FONT>

<P><a name="7"><B><FONT FACE="Variable Width">7. Acknowledgements</FONT></B>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>We would like to thank Richard Taylor,
Peyman Oreizy, Jason Robbins, David Redmiles, and David Hilbert for their
participation in numerous discussions of issues concerning ADLs. We also
thank the DSL reviewers for their helpful reviews.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Effort partially sponsored by the Defense
Advanced Research Projects Agency, and Rome Laboratory, Air Force Materiel
Command, USAF, under agreement numbers F30602-94-C-0218 and F30602-97-2-0021.
The U.S. Government is authorized to reproduce and distribute reprints
for Governmental purposes notwithstanding any copyright annotation thereon.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>Approved for Public Release - Distribution
Unlimited.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>The views and conclusions contained
herein are those of the authors and should not be interpreted as necessarily
representing the official policies or endorsements, either expressed or
implied, of the Defense Advanced Research Projects Agency, Rome Laboratory
or the U.S. Government.</FONT></FONT>

<P><FONT FACE="Variable Width"><FONT SIZE=+0>This material is also partially based
on work supported by the National Science Foundation under Grant No. CCR-9701973.</FONT></FONT>

<P><a name="8"><B><FONT FACE="Variable Width">8. References</FONT></B>
<P>
<DL COMPACT>
<FONT FACE="Variable Width"><FONT SIZE=+0>

<DT><a name="AG94a">[AG94a] 
<DD>R. Allen and D. Garlan. Formal
Connectors. Technical Report, CMU-CS-94-115, Carnegie Mellon University,
March 1994.

<DT><a name="AG94b">[AG94b] 
<DD>R. Allen and D. Garlan. Formalizing
Architectural Connection. In <I>Proceedings of the Sixteenth International
Conference on Software Engineering</I>, pages 71-80, Sorrento, Italy, May
1994.</FONT></FONT>

<DT><a name="All96">[All96] 
<DD>R. Allen. HLA: A Standards
Effort as Architectural Style. In A. L. Wolf, ed., <I>Proceedings of the
Second International Software Architecture Workshop (ISAW-2)</I>, pages
130-133, San Francisco, CA, October 1996.

<DT><a name="BR95">[BR95] 
<DD>G. Booch and J. Rumbaugh. <I>Unified
Method for Object-Oriented Development</I>. Rational Software Corporation,
1995.

<DT><a name="DK76">[DK76] 
<DD>F. DeRemer and H. H. Kron. Programming-in-the-large
versus Programming-in-the-small. <I>IEEE Transactions on Software Engineering</I>,
pages 80-86, June 1976.

<DT><a name="For92">[For92] 
<DD><I>Failures Divergence Refinement:
User Manual and Tutorial</I>. Formal Systems (Europe) Ltd., Oxford, England,
October 1992.

<DT><a name="GAO94">[GAO94] 
<DD>D. Garlan, R. Allen, and J.
Ockerbloom. Exploiting Style in Architectural Design Environments. In <I>Proceedings
of SIGSOFT'94: Foundations of Software Engineering</I>, pages 175-188,
New Orleans, Louisiana, USA, December 1994.

<DT><a name="Gar95">[Gar95] 
<DD>D. Garlan, editor. <I>Proceedings
of the First International Workshop on Architectures for Software Systems</I>,
Seattle, WA, April 1995.

<DT><a name="Gar96">[Gar96] 
<DD>D. Garlan. Style-Based Refinement
for Software Architecture. In A. L. Wolf, ed., <I>Proceedings of the Second
International Software Architecture Workshop (ISAW-2)</I>, pages 72-75,
San Francisco, CA, October 1996.

<DT><a name="GMW95">[GMW95] 
<DD>D. Garlan, R. Monroe, and D.
Wile. ACME: An Architectural Interconnection Language. Technical Report,
CMU-CS-95-219, Carnegie Mellon University, November 1995.

<DT><a name="GMW97">[GMW97] 
<DD>D. Garlan, R. Monroe, and D.
Wile. ACME: An Architecture Interchange Language. Submitted for publication,
January 1997.

<DT><a name="GPT95">[GPT95] 
<DD>D. Garlan, F. N. Paulisch,
and W. F. Tichy, editors. <I>Summary of the Dagstuhl Workshop on Software
Architecture</I>, February 1995. Reprinted in ACM Software Engineering
Notes, pages 63-83, July 1995.

<DT><a name="GS93">[GS93] 
<DD>D. Garlan and M. Shaw. <I>An
Introduction to Software Architecture: Advances in Software Engineering
and Knowledge Engineering</I>, volume I. World Scientific Publishing, 1993.

<DT><a name="GW88">[GW88] 
<DD>J. A. Goguen and T. Winkler.
Introducing OBJ3. Technical Report SRI-CSL-88-99. SRI International, 1988.

<DT><a name="Har87">[Har87] 
<DD>D. Harel. Statecharts: A Visual
Formalism for Complex Systems. <I>Science of Computer Programming</I>,
1987.

<DT><a name="Hoa85">[Hoa85] 
<DD>C. A. R. Hoare. <I>Communicating
Sequential Processes</I>. Prentice Hall, 1985.

<DT><a name="IW95">[IW95] 
<DD>P. Inverardi and A. L. Wolf.
Formal Specification and Analysis of Software Architectures Using the Chemical
Abstract Machine Model. <I>IEEE Transactions on Software Engineering</I>,
pages 373-386, April 1995.

<DT><a name="Jac95">[Jac95]
<DD>M. Jackson. <I>Software Requirements
and Specifications: A Lexicon of Practice, Principles and Prejudices</I>.
Addison-Wesley, 1995.

<DT><a name="LKA+95">[LKA+95] 
<DD>D. C. Luckham, J. J. Kenney,
L. M. Augustin, J. Vera, D. Bryan, and W. Mann. Specification and Analysis
of System Architecture Using Rapide. <I>IEEE Transactions on Software Engineering</I>,
pages 336-355, April 1995.

<DT><a name="Luc87">[Luc87] 
<DD>D. Luckham. <I>ANNA, a language
for annotating Ada programs: reference manual</I>, volume 260 of <I>Lecture
Notes in Computer Science</I>. Springer-Verlag, Berlin, 1987.

<DT><a name="LV95">[LV95] 
<DD>D. C. Luckham and J. Vera. An Event-Based Architecture Definition Language. <I>IEEE Transactions on Software
Engineering</I>, pages 717-734, September 1995.

<DT><a name="LVB+93">[LVB+93] 
<DD>D. C. Luckham, J. Vera, D.
Bryan, L. Augustin, and F. Belz. Partial Orderings of Event Sets and Their
Application to Prototyping Concurrent, Timed Systems. <I>Journal of Systems
and Software</I>, pages 253-265, June 1993.

<DT><a name="LVM95">[LVM95] 
<DD>D. C. Luckham, J. Vera, and
S. Meldal. Three Concepts of System Architecture. Unpublished Manuscript,
July 1995.

<DT><a name="Med96">[Med96] 
<DD>N. Medvidovic. ADLs and Dynamic
Architecture Changes. In A. L. Wolf, ed., <I>Proceedings of the Second
International Software Architecture Workshop (ISAW-2)</I>, pages 24-27,
San Francisco, CA, October 1996.

<DT><a name="Med97">[Med97] 
<DD>N. Medvidovic. A Classification
and Comparison Framework for Software Architecture Description Languages.
Technical Report, UCI-ICS-97-02, University of California, Irvine, January
1997.

<DT><a name="MDEK95">[MDEK95] 
<DD>J. Magee, N. Dulay, S. Eisenbach,
and J. Kramer. Specifying Distributed Software Architectures. In <I>Proceedings
of the Fifth European Software Engineering Conference (ESEC'95)</I>, Barcelona,
September 1995.

<DT><a name="MK96">[MK96] 
<DD>J. Magee and J. Kramer. Dynamic
Structure in Software Architectures. In <I>Proceedings of ACM SIGSOFT'96:
Fourth Symposium on the Foundations of Software Engineering (FSE4)</I>,
pages 3-14, San Francisco, CA, October 1996.

<DT><a name="MOT97">[MOT97] 
<DD>N. Medvidovic, P. Oreizy, and
R. N. Taylor. Reuse of Off-the-Shelf Components in C2-Style Architectures.
In <I>Proceedings of the 1997 Symposium on Software Reusability (SSR'97)</I>,
pages 190-198, Boston, MA, May 17-19, 1997. Also in <I>Proceedings of the
1997 International Conference on Software Engineering (ICSE'97)</I>, pages
692-700, Boston, MA, May 17-23, 1997.

<DT><a name="MORT96">[MORT96] 
<DD>N. Medvidovic, P. Oreizy,
J. E. Robbins, and R. N. Taylor. Using object-oriented typing to support
architectural design in the C2 style. In <I>Proceedings of ACM SIGSOFT'96:
Fourth Symposium on the Foundations of Software Engineering (FSE4)</I>,
pages 24-32, San Francisco, CA, October 1996.

<DT><a name="MQR95">[MQR95] 
<DD>M. Moriconi, X. Qian, and R.
A. Riemenschneider. Correct Architecture Refinement. <I>IEEE Transactions
on Software Engineering</I>, pages 356-372, April 1995.

<DT><a name="MT96">[MT96] 
<DD>N. Medvidovic and R. N. Taylor.
Reusing Off-the-Shelf Components to Develop a Family of Applications in
the C2 Architectural Style. In <I>Proceedings of the International Workshop
on Development and Evolution of Software Architectures for Product Families</I>,
Las Navas del Marqu&eacute;s, &Aacute;vila, Spain, November 1996.

<DT><a name="MT97">[MT97] 
<DD>N. Medvidovic and R. N. Taylor.
A Framework for Classifying and Comparing Architecture Description Languages.
To appear in <I>Proceedings of the Sixth European Software Engineering
Conference together with Fifth ACM SIGSOFT Symposium on the Foundations
of Software Engineering</I>, Zurich, Switzerland, September 22-25, 1997.

<DT><a name="MTW96">[MTW96] 
<DD>N. Medvidovic, R. N. Taylor,
and E. J. Whitehead, Jr. Formal Modeling of Software Architectures at Multiple
Levels of Abstraction. In <I>Proceedings of the California Software Symposium
1996</I>, pages 28-40, Los Angeles, CA, April 1996.

<DT><a name="NKM96">[NKM96] 
<DD>K. Ng, J. Kramer, and J. Magee.
A CASE Tool for Software Architecture Design. <I>Journal of Automated Software
Engineering (JASE), Special Issue on CASE-95</I>, 1996.

<DT><a name="Ore96">[Ore96] 
<DD>P. Oreizy. Issues in the
Runtime Modification of Software Architectures. Technical Report, UCI-ICS-96-35,
University of California, Irvine, August 1996.

<DT><a name="Pet62">[Pet62] 
<DD>C. A. Petri. Kommunikationen
Mit Automaten. PhD Thesis, University of Bonn, 1962. English translation:
Technical Report RADC-TR-65-377, Vol.1, Suppl 1, Applied Data Research,
Princeton, N.J.

<DT><a name="PN86">[PN86] 
<DD>R. Prieto-Diaz and J. M. Neighbors.
Module Interconnection Languages. <I>Journal of Systems and Software</I>,
pages 307-334, October 1989.

<DT><a name="PW92">[PW92] 
<DD>D. E. Perry and A. L. Wolf.
Foundations for the Study of Software Architectures. <I>ACM SIGSOFT Software
Engineering Notes</I>, pages 40-52, October 1992.

<DT><a name="RMRR97">[RMRR97] 
<DD>J. E. Robbins, N. Medvidovic,
D. F. Redmiles, and D. S. Rosenblum. Integrating Architecture Description
Languages with a Standard Design Method. Technical Report, UCI-ICS-97-35,
University of California, Irvine, August 1997.

<DT><a name="RR96">[RR96] 
<DD>J. E. Robbins and D. Redmiles.
Software architecture design from the perspective of human cognitive needs.
In <I>Proceedings of the California Software Symposium (CSS'96)</I>, Los
Angeles, CA, USA, April 1996.

<DT><a name="SC96">[SC96] 
<DD>M. Shaw and P. Clements. Toward
Boxology: Preliminary Classification of Architectural Styles. In A. L.
Wolf, ed., <I>Proceedings of the Second International Software Architecture
Workshop (ISAW-2)</I>, pages 50-54, San Francisco, CA, October 1996.

<DT><a name="SDK+95">[SDK+95] 
<DD>M. Shaw, R. DeLine, D. V.
Klein, T. L. Ross, D. M. Young, and G. Zelesnik. Abstractions for Software
Architecture and Tools to Support Them. <I>IEEE Transactions on Software
Engineering</I>, pages 314-335, April 1995.

<DT><a name="SG94">[SG94] 
<DD>M. Shaw and D. Garlan. Characteristics
of Higher-Level Languages for Software Architecture. Technical Report,
CMU-CS-94-210, Carnegie Mellon University, December 1994.

<DT><a name="Spi89">[Spi89] 
<DD>J. M. Spivey. <I>The Z notation:
a reference manual</I>. Prentice Hall, New York, 1989.

<DT><a name="TLPD95">[TLPD95] 
<DD>A. Terry, R. London, G. Papanagopoulos,
and M. Devito. The ARDEC/Teknowledge Architecture Description Language
(ArTek), Version 4.0. Technical Report, Teknowledge Federal Systems, Inc.
and U.S. Army Armament Research, Development, and Engineering Center, July
1995.

<DT><a name="Tra95">[Tra95] 
<DD>W. Tracz. DSSA (Domain-Specific
Software Architecture) Pedagogical Example. <I>ACM SIGSOFT Software Engineering
Notes</I>, July 1995.

<DT><a name="Ves93">[Ves93] 
<DD>S. Vestal. A Cursory Overview
and Comparison of Four Architecture Description Languages. Technical Report,
Honeywell Technology Center, February 1993.

<DT><a name="Ves96">[Ves96] 
<DD>S. Vestal. MetaH Programmer's
Manual, Version 1.09. Technical Report, Honeywell Technology Center, April
1996.

<DT><a name="Wolf96">[Wolf96] 
<DD>A. L. Wolf, editor. <I>Proceedings
of the Second International Software Architecture Workshop (ISAW-2)</I>,
San Francisco, CA, October 1996.

</FONT></FONT>
</DL>

<P>
<HR>
<P><a name="Footnotes"><B><FONT FACE="Variable Width">Footnotes</FONT></B>
<P>
<DL>
<DT><a name="foot1"><a href="#foot1-txt">[Footnote 1]</a>
<DD>This section is condensed from a detailed exposition on
ADLs given in [<a href="#Med97">Med97</a>] and [<a href="#MT97">MT97</a>], where we provided a 
definition of ADLs and devised a classification and comparison 
framework for them.

<P>
<DT><a name="foot2"><a href="#foot2-txt">[Footnote 2]</a>
<DD>One can think of these syntactic features as equivalent to a 
"boxes and arrows" graphical notation with little or no underlying 
semantics.

<P>
<DT><a name="foot3"><a href="#foot3-txt">[Footnote 3]</a>
<DD>Saying that an architecture is "executing" can mean either 
that the architecture is being simulated or that the executable 
system built based on that architecture is running.
</DL>

</BODY>
</HTML>

