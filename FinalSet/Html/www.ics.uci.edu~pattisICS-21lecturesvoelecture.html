<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
  <title>Variables and Operators</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Variables, Operators, and Expressions</h1>
<p>
<h2>Introduction to Computer Science I-III
<br>
ICS-21/-22/-23
<br>
</h2>
<p>
</center>



<!-- Introduction -->

<a name="Introduction"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
  In this lecture we will first learn how to declare and visualize variables
    storing any type of data (both primitive and reference types).
  Then, we will learn a variety of operators (arithmetic, relational, logical,
    textual, and state-change) and methods that compute results (produce more
    values) from such data.
  Along the way, we will introduce new terminology for discussing operators
    and methods generally.
  <p>
  Finally, we will learn how to combine literals, variables, operators, and
    methods (which are like function calls) to build arbitrarily complicated
    expresions (formulas that Java can evaluate).
  We being by examining the structure and evaluation process for expressions,
    including the concepts of operator precedence and operator associativity.
  Then we will learn how to build oval diagrams: the main analytic tool that
    we will use to investigate/understand large expressions (along with our
    knowledge of prototypes).
  We should understand how to translate complicated formulas into their
    equivalent Java expressions and verify that the translation is correct.
</td>
</tbody>
</table>



<!-- Declaring Variables -->

<a name="Declarations">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Declaring Variables</b></td>
<td width ="80%">
  Programs declare variables to store/remember information; they manipulate
     (examine and update) this information when they run.
  Simple variables typically store some value input by the user, or some value
    calculated by the program from user-inputs.
  When a program runs, the values in some of its variables change: thus, the
    value stored in a variable can <b>vary</b> as the program runs.
<p>
  The EBNF rules for variable declaration appear below.
  Each declaration is a statement -a complete command to the computer- which
    the computer executes.
  We will cover many of Java's other statements in the next lecture.
  <p>
&nbsp &nbsp <i>primitive-type</i> &nbsp<= int | double | boolean | char<br> 
&nbsp &nbsp <i>reference-type</i> <= String | ... (we will learn others soon)<br> 
&nbsp &nbsp <i>type</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
       <= <i>primitive-type</i> | <i>reference-type</i><br>
  <br> 
&nbsp &nbsp <i>expression</i> <= <i>literal</i> | ... (we will generalize this rule later)<br> 
  <br> 
&nbsp &nbsp <i>variable-declarator</i> &nbsp<= <i>identifier</i> [=<i>expression</i>]<br> 
&nbsp &nbsp <i>variable-declarators</i> <= <i>variable-declarator</i>{,<i>variable-declarator</i>}<br> 
  <br>
&nbsp &nbsp <i>local-variable-declaration-statement</i> <= <i>type</i> <i>variable-declarators</i> ;<br> 
  <p>
  Declarations are simple statements, which means that they end with a
   semicolon (see the last rule above).
  Variables are always declared with a type (e.g., a primitive type like
    <b>int</b> or a reference type like <b>String</b>), one or more names
    (an identifier that the programmmer chooses) which can be optionally
     initialized to store a specified value.
  <p>
  The simplest form of a declaration is <b>int sum;</b> which declares one
     variable named <b>sum</b> to be of the type <b>int</b>, meaning that
     <b>sum</b> stores only <b>int</b> values.
  Again, notice the semicolon ending this statement.
  When a variable is declared this way, the value that it initially stores is
    undefined.
  We will have more to say about what Java does with undefined variables later;
    it is not a mistake to declare certain variables without initializing
     them.
  <p>
  If we want to declare a variable and at the same time initialize it, we can
    write something like <b>int gamesPlayed = 0;</b> explicitly telling Java
    to declare the variable named <b>gamesPlayed</b> and store zero as its
    value initially.
  <p>
  In fact, we can declare a few variables in the same declaration: e.g., 
    <b>double angle, magnitude;</b> declares two variables, both of type
    <b>double</b> and both storing undefined values.
  In multi-variable declarations, all the variables are declared to be of
    the same type -the one type that starts the declaration.
  <p>
  If we want to declare and initialize multiple variables in a single
    declaration (using the repetition in the <i>variable-declarators</i>
    EBNF rule), we must explicitly specify the initial value <b>for each
    variable</b>.
  For example, <b>int n = 0, sum = 0;</b> initializes each variable to zero.
  WARNING: <b>int n,sum = 0;</b> initializes <b>sum</b> to zero, but leaves
    <b>n</b> uninitialized; making this mistake is common for beginning
    programmers.
  In fact, Java always executes declarations with multiple variables as a
     sequence of  declarations of single variables.
   So executing <b>int n,sum = 0;</b> is equivalent to executing
   <b>int n;</b> then <b>int sum = 0;</b>, which makes this problem more
   obvious.
  <p>
  Java imposes a syntax constraint on initialized variables: the declared
     <i>type</i> of the variable (specified at the start of the declaration)
    must be compatible with the type of the <i>expression</i>.
  We will discuss "compatibility" more, when we discuss implicit conversions;
    for now, assume that compatible means that the two types must be the same.
  <p>
  So in the declaration <b>int n = true;</b> although the EBNF rules are
    correctly followed, the Java compiler will detect and report a syntax
    constraint error because <b>true</b> (a <b>boolean</b> literal) is not an
    <b>int</b> value; likewise <b>boolean atCapacity = 0;</b> exhibits the
    same kind of error in reverse.
  <p>
  To be truthful, Java will in fact automatically convert an <b>int</b> value
    into a <b>double</b> if necessary , so <b>double x = 1;</b> is legal, and
    is treated as equivalently to <b>double x = 1.;</b>
  More obscurely, Java will automatically convert a <b>char</b> value into an
    <b>int</b> value (and vice-versa) if necessary.
  We will learn more about 
  <a href="#ImplicitConversion" target="main">implicit type conversion</a>
    later in this lecture. 
  <p>
  Programmers often use line-oriented comments (here called side-bar comments)
     in declarations to document some interesting facet of a variable that is
     not captured by even a well-chosen name.
  For example, in the declarations statements
  <pre><b>    double  tankSize;        //Gallons
    double  mileage;         //Miles/Gallon</b></pre>
  Here the programmer has used the comments to describe the units of the
    quantity the variable stores.
  Extending the variable name to <b>tankSizeInGallons</b> is probably making
    it a bit too long.
  Note that for this style of declaration/comment, we declare just one variable
    per declaration statement.
  Pragmatically, most declarations declare just one variable.
</td>
</tbody>
</table>


<a name="DrawingDeclarations">
<hr align="left" width="33%">

<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Drawing Declarations<br>(primitive and reference types)</b></td>
<td width ="80%">
  Throughout the semester, we will learn a variety of graphic aids to help us
    understand and analyze the meanings of Java language constructs.
  We will start here, learning how to draw simple pictures that illustrate the
     meanings of declarations.
  Some students fail to appreciate the power of such simple pictures, when
    drawn correctly: but time and time again these pictures -often used in much
    more complicated contexts, as in class instance variables- can provide
    insight into the meaning/semantics of the Java language, as we will see
    repeatedly.
  <p>
  To illustrate the meaning of a declaration, we draw a box: we label the box
    on the top left with the variable's type and on the top right with the
    variable's name; we store the initial value (if any) inside the box; if
    the declarator specifies no initialization option, we write a question
    mark inside the box.
  So, we always write something in each box: a value of the right type or a
    question mark (not a <b>char</b> or <b>String</b> literal: just a question
    mark).
  <p>
  There are two major categories of types in Java: primitive and reference.
  All primitive types are fixed in the language, named by keywords; we will
    learn more about, and repeatedly use the primitive types <b>int</b>,
    <b>double</b>, <b>boolean</b>, and <b>char</b>. 
  All reference types come from class libraries that are written by
    programmers
  Right now, the only reference type that we currently know is <b>String</b>,
     which is declared in the standard Java library.
  We will learn about other reference types soon, and how to declare our own
    new reference types a bit later.
  The <b>String</b> reference type is special, because it is the only
    one that also has literal values..
  <p>
  The only difference between primitive and reference types is what can appear
    inside the box in the picture of a variable.
  Variables declared of a primitive type store values; variables declared of a
    reference type store references.
  For a variable of a primitive type, we write in its box either a question
    mark or a literal of the declared  type.
  For a variable of a reference type, we write in its box either a question
    mark, the literal value <b>null</b> (usable for all reference types: it
    means that the variable refers to nothing), or an arrow (called a
    reference) that leads to an <b>object</b> (an oval labelled by the same
    type) that stores a collection of data (for <b>String</b>s, the collection
    of characters that comprise the <b>String</b>'s value).
  <p>
  We will learn much much more about primitive and reference types later.
  For now, it is critical just that you understand, given a declaration, how
    to illustrate its meaning with a picture.
  The pictures below illustate the meaning of the following declarations.
  <pre><b>    int     a;
    int     b = 0;
    boolean c = false;
    String  d;
    String  e = null;
    String  f = "Hello";
  </b></pre>
  <p>
<img src="images/declarations.gif"></image><p>
  We will explore such illustrations further when we learn about
    <b>state-change</b> operators in this lecture.
  We will extend the use of such illustrations later when we learn about using
    other kinds of variables: <b>parameter</b> variables declared in methods;
    <b>instance</b> variables declared in bjects constructed from classes.
</td>
</tbody>
</table>



<!-- Operator Prototypes -->

<a name="Prototypes">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Operator Prototypes and Signatures<br>(introducing exceptions)</b></td>
<td width ="80%">
   There are two aspects to describing operators in Java.
   <ol>
     <li>Describe their syntax via <b>prototypes</b>
         <ul>
           <li>what <b>type</b> of operand(s) they work on
           <li>what <b>type</b> of result they produce
           <li>whether they can throw any exceptions
         </ul>
     <li>Describe their semantics/meaning in English
         <ul>
           <li>how they compute the value of the result from the operand(s)
           <li>under what conditions they throw an exception
         </ul>
   </ol>
  We can specify the syntax of a prototype formally as
  <p>
  <i>return-type</i> &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp 
       &nbsp<= <i>type</i><br> 
  <i>operand-types</i> &nbsp &nbsp &nbsp &nbsp <= <i>type</i>{,<i>type</i>}<br> 
  <i>exception-identifier</i> <= ArithmeticException | ... (we will learn more more later)<br> 
  <i>exception-types</i> &nbsp &nbsp &nbsp 
       <= <i>exception-identifier</i>{,<i>exception-identifier</i>}<br> 
  <br>
  <i>prototype</i> <= <i>return-type</i> <i>operator</i> ([<i>operand-types</i>]) [throws <i>exception-types</i>]<br> 
  <p>
   So, prototypes start with the type of the result returned by the operator,
     followed by the operator itself, followed by a pair of parentheses
     (with the type(s) of the operand(s), if any, separated by commas, on the
      inside).
   For example, each of the following lines specifies an operator prototype:
   <pre><b>      int     + (int,int)
      double  - (double)
      int     * (int,int)
      double  * (double,double)</b></pre>
   The first prototype means that when Java adds two <b>int</b>s (with the
      <b>+</b> operator), the result is an <b>int</b>.
   The second prototype means that when Java negates a <b>double</b> (with the
     <b>-</b> operator), the result is a <b>double</b>.
   The third prototype means that when Java multiplies two <b>int</b>s (with
     the <b>*</b> operator), the result is an <b>int</b>.
   The fourth prototype meants that when Java multiplies two <b>double</b>s
    (with the <b>*</b> operator), the result is a <b>double</b>.
   <p>
   Of course, we already know the semantics/meanings of addition, negation,
     and multiplication in mathematics, so we do not need to discuss them here.
   We will soon see prototypes for more interesting operators, such as
   <pre><b>      boolean <  (int,int)
      boolean && (boolean,boolean)</b></pre>
   The first prototype means that when Java compares two <b>int</b>s (with the
      <b>&lt</b> operator), the result is a <b>boolean</b>; you probably
      already know the semantics of this kind of comparison too.
   The second prototype means that when Java <b>and</b>s together (that is how
     the <b>&&</b> operator is pronounced) two <b>boolean</b>s, the result is
     a <b>boolean</b>; if you have studied logic or truth tables (which we
     will do below) you might know the semantics of this operation too (what
     result is produced from what operands).
   <p>
   As we learn these and more operators in Java, we will first present their
     syntax (with prototypes) and then their semantics (using English and other
     tools).
   <p>
   Finally, some operators specify that they throw exceptions.
   An operator throws an exception if it cannot correctly compute a result
      for its operand(s).
   For example, integer division (the <b>/</b> operator in Java) cannot compute
     a result if its denominator is zero.
   A prototype indicates this information by using the keyword <b>throws</b>
     followed by the identifier <b>ArithmeticException</b> (about which we will
     learn many more details later).
   So the prototype for integer division is fully written as
   <pre><b>      int / (int,int) throws ArithmeticException</b></pre>
   <p>
   A signature is a subset of the information in a prototype; it includes just
     the information about the types of operands (not the return type and not
     the exceptions).
  We can specify the syntax of a signature formally (reusing some of the EBNF
     rules written above) as
  <p>
  <i>signature</i> <= <i>operator</i> ([<i>operand-types</i>])<br> 
  <p>
  In fact, using this EBNF rule, we could rewrite the <i>prototype</b> rule as
    simply
  <p>
  <i>prototype</i> <= <i>return-type</i> <i>signature</i> [throws <i>exception-types</i>]<br> 
  <p>
</td>
</tbody>
</table>



<!-- Terminology -->

<a name="Terminology">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Operator Terminology</b></td>
<td width ="80%">
  A bit of terminology will make it easier to discuss and explore operators.
  <ul>
    <li>Number of Prototypes
      <ul><li>An operator is <b>overloaded</b> if it has more than one
                prototype: e.g, the <b>*</b> operator above has one prototype
                for <b>int</b> operands and one for <b>double</b> operands,
                hence it is overloaded.
          <li>The term overloaded is not a "bad" term; in fact, most Java
                operators are overloaded.
          <li>Overloaded operators must have different signatures: i.e.,
                either a different number of operands or the same number but
                with different types for some operands.
          <li>Given this restriction, Java can use the types of the operands to
                 determine which prototype to use.
          <li>Note that we cannot have the following two prototypes for
               the <b>/</b><br>
               &nbsp &nbsp int &nbsp &nbsp &nbsp &nbsp/ (int,int)<br>
               &nbsp &nbsp double  / (int,int)</b><br>
              because they both have the same signature: <b>/ (int,int)</b>
      </ul>
    <li>Number of Operands
      <ul><li><b>Unary</b> operators have one operand (e.g., the negate
              operator; think of a <b>un</b>icycle, with one wheel).
          <li><b>Binary</b> operators have two operands (e.g., the multiply
              operator; think of a <b>bi</b>cycle, with two wheels).</ul>
    <li>Operator Location
      <ul><li><b>Infix</b> operators are written in-between their operands
             (e.g., <b>3*5</b>; infix operators are binary).
          <li><b>Prefix</b> operators are written before their operand
             (e.g., <b>-5</b>; prefix operators are unary).
          <li><b>Postfix</b> operators are written after their operand
             (e.g., <b>Count++</b>; postfix perators are unary)</ul>
  </ul>
  It is important to gain an intuitive understanding of these terms now,
    because we will use them repeatedly throughout the semester.
</td>
</tbody>
</table>



<!-- Operators in Java -->

<a name="Operators"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Operators in Java</b></td>
<td width ="80%">
  Java contains a large number of operators, but most fall into only a few categories.
  <pre><b>    Arithmetic          +  -  *  /  %
    Relational          ==  !=  <  >  <=  >=
    Logical             !  &&  ||
    State Change        ++  --  =  +=  -=  /=  %=  ...
    Textual             +</b></pre>
  In this lecture we will examine each of these categories of operators, first
    examining their syntax (with prototypes) and then examining their 
    semantics (using English, operand/result tables, etc.)
  Although there are other operators in Java, these are by far the most
    common and useful ones.
</td>
</tbody>
</table>



<!-- + Operator -->

<a name="+Operator"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The + Operator: Add/Catenate</b></td>
<td width ="80%">
  The <b>+</b> operator is overloaded in Java, with the following arithmetic
    prototypes.
  <pre><b>    int    + (int)
    double + (double)
    int    + (int,int)
    double + (double,double)</b></pre>
  Let us take a look at the semantics of each of these prototypes.
  We say that "Java evaluates operators, to produce results from operands."
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Prototype</th><th>Semantics</th><th>Examples</th>
  </thead>
  <tbody>
  <tr valign="top"><td><pre><b>int    + (int)</b></pre></td>
    <td>A unary prefix operator; its result is the same as its operand.</td>
    <td><b>+7</b> evaluates to <b>7</b></td>
  <tr valign="top"><td><pre><b>double + (double)</b></pre></td>
    <td>A unary prefix operator; its result is the same as its operand.</td>
    <td><b>+7.25</b> evaluates to <b>7.25</b></td>
  <tr valign="top"><td><pre><b>int    + (int,int)</b></pre></td>
    <td>A binary infix operator; its result is the sum of its operands.</td>
    <td><b>3+5</b> evaluates to <b>8</b></td>
  <tr valign="top"><td><pre><b>double + (double,double)</b></pre></td>
    <td>A binary infix operator; its result is the sum of its operands.</td>
    <td><b>2.4+5.1</b> evaluates to <b>7.5</b></td>
  </tbody>
  </table>
  <p>
  The <b>+</b> operator is also a textual operator (called catenate), with the
    following further prototypes (so it is highly overloaded).
  Notice that in each case at least one operand is a <b>String</b> and the
    final result is always a <b>String</b> too.
  <pre><b>    String + (String,int)
    String + (String,double)
    String + (String,boolean)
    String + (String,char)
    String + (String,String)
    String + (int,String)
    String + (double,String)
    String + (boolean,String)
    String + (char,String)</b></pre>
  Semantically, the <b>(String,String)</b> case is the simplest; it builds
    a <b>String</b> containing all the characters in the first operand followed
    by all of the characters in the second operand.
  For example, <b>"Hi"+"Low"</b> evaluates to <b>"HiLow"</b>.
  Next simplest is catenation of a <b>String</b> and <b>char</b> (regardless of
    the order).
  For example, <b>'a'+"String"</b> evaluates to <b>"aString"</b>.
  In the other cases, the value (whether its type is <b>int</b>, <b>double</b>,
    or <b>boolean</b>) is first automatically converted into an
   <i>equivalent</i> <b>String</b> and then is catenated to the other operand
     (which is already a <b>String</b>).
  For example, <b>12+" in a dozen"</b> evaluates to
    <b>"12 in a Dozen"</b> because the <b>int</b> value <b>12</b> is first
       automatically converted into the <b>String</b> value <b>"12"</b>.
  <p>    
  Note that <b>1+1</b> results in <b>2</b> while <b>"1"+1</b> and <b>1+"1"</b>
    both result in <b>"11"</b>.
  <p>
  Finally, note that <b>true+" is a boolean"</b> results in
    <b>"true is a boolean"</b> because the <b>boolean</b> value <b>true</b> is
    first automatically converted into the <b>String</b> value <b>"true"</b>.
  <p>
  Using <b>+</b> for catenation is very common in Java, when outputing various
     types of information to the console.
  You will become very familiar with this operator when you start writing
    programs.
</td>
</tbody>
</table>



<!-- - Operator -->

<a name="-Operator"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The - Operator: Negate/Subtract</b></td>
<td width ="80%">
  The <b>-</b> operator is overloaded in Java, with the following prototypes.
  <pre><b>    int    - (int)
    double - (double)
    int    - (int,int)
    double - (double,double)</b></pre>
  Let us take a look at the semantics of each of these prototypes.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Prototype</th><th>Semantics</th><th>Examples</th>
  </thead>
  <tbody>
  <tr valign="top"><td><pre><b>int    - (int)</b></pre></td>
    <td>A unary prefix operator; its result is the negated value of its operand.</td>
    <td><b>-7</b> evaluates to negative <b>7</b></td>
  <tr valign="top"><td><pre><b>double - (double)</b></pre></td>
    <td>A unary prefix operator; its result is the negated value of its operand.</td>
    <td><b>-7.25</b> evaluates to negative <b>7.25</b></td>
  <tr valign="top"><td><pre><b>int    - (int,int)</b></pre></td>
    <td>A binary infix operator; its result is the difference between its first and second operands.</td>
    <td><b>8-3</b> evaluates to <b>5</b></td>
  <tr valign="top"><td><pre><b>double - (double,double)</b></pre></td>
    <td>A binary infix operator; its result is the difference between it first and second operands.</td>
    <td><b>7.5-2.4</b> evaluates to <b>5.1</b></td>
  </tbody>
  </table>
  <p>
  Note that in Java, writing <b>-6</b> means negate the literal <b>6</b>.
  Recall that all literals are non-negative, so <b>-6</b> technically is not
    a literal: it is an operator and a literal; still, we will write <b>-6</b>
    and often pretend it is purely a value (for example, when writing values
    inside variables).
  Seem confusing? Don't worry about this detail too much: don't let this
    weird tree stop you from seeing the forest.
</td>
</tbody>
</table>



<!-- * Operator -->

<a name="*Operator"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The * Operator: Multiply</b></td>
<td width ="80%">
  The <b>*</b> (multiply) operator is overloaded in Java, with the following prototypes.
  <pre><b>    int    * (int,int)
    double * (double,double)</b></pre>
  Note that unlike <b>+</b> and <b>-</b> there is no unary version of the <b>*</b> operator.
  Let us take a look at the semantics of each of these prototypes.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Prototype</th><th>Semantics</th><th>Examples</th>
  </thead>
  <tbody>
  <tr valign="top"><td><pre><b>int    * (int,int)</b></pre></td>
    <td>A binary infix operator; its result is the product of its operands.</td>
    <td><b>3*5</b> evaluates to <b>15</b></td>
  <tr valign="top"><td><pre><b>double * (double,double)</b></pre></td>
    <td>A binary infix operator; its result is the product of its operands.</td>
    <td><b>4.2*5.8</b> evaluates to <b>24.36</b></td>
  </tbody>
  </table>
  <p>
  Note that unlike mathematics, there is no "implicit" multiplication in Java.
  Assuming that we declare <b>int A,B;</b> then <b>3A</b> and <b>3(A+B)</b>
    are NOT LEGAL expressions: they would have to be written explicitly with the <b>*</b>
    operator as <b>3*A</b> and <b>3*(A+B)</b>.
  We will study expressions (with arbitrarily complicated combinations of the operators that
    we are discussing here) later in this lecture.
</td>
</tbody>
</table>



<!-- / Operator -->

<a name="DivideOperator"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The / Operator: Divide</b></td>
<td width ="80%">
  The <b>/</b> (divide) operator is overloaded in Java, with the following prototypes.
  <pre><b>    int    / (int,int)       throws ArithmeticException
    double / (double,double)</b></pre>
  Note that like the <b>*</b> operator, there is no unary version of the
     <b>/</b> operator.
  Let us take a look at the semantics of each of these prototypes.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Prototype</th><th>Semantics</th><th>Examples</th>
  </thead>
  <tbody>
  <tr valign="top"><td><pre><b>int    / (int,int)</b></pre></td>
    <td>A binary infix operator; its result is (the integer part of) the first
          operand divided by the second (ignore the remainder).
        If the second operand is <b>0</b>, this operator throws an
          exception.</td>
    <td><b>13/5</b> evaluates to <b>2</b></td>
  <tr valign="top"><td><pre><b>double / (double,double)</b></pre></td>
    <td>A binary infix operator; its result is the first operand divided by
          the second.
        If the second operand is <b>0.</b>, this operator returns the result
           <b>Infinity</b>
           (if the first operand is positive), or <b>-Infinity</b> (if the
            first operand is negative),
          or <b>NaN</b> (Not a Number, if the first operand is also zero).</td>
    <td><b>13./5.</b> evaluates to <b>2.6</b></td>
  </tbody>
  </table>
  <p>
  Here are the first "nonintuitive" semantics for a Java arithmetic operator.
  When Java divides two <b>int</b> values (<b>13</b> by <b>5</b>) the prototype
    tells us that the result must be an <b>int</b>.
  So, Java takes the "mathematical" answer, <b>2.6</b> (the one that is
    intuitive to us)  and <b>truncates</b> it (throws away <b>.6</b> the
    non-integral part).
  Only when two <b>double</b> values are divided does Java keep the decimal
    part in the returned result.
  Students find this difference strange and nonintuitive; they often aren't
    careful, when using the <b>/</b> operator in their programs, to distinguish
    between <b>int</b> and <b>double</b> operands.
  <p>
  Finally, if the second operand to the <b>/</b> operator (with <b>int</b>
    operands) is zero, the operator does not compute a result, but instead
    throws an exception.
  Throwing an exception is like throwing up your hands and saying, "I cannot
     do the computation".
  At the end of our study of Java statements, we will learn how catch (handle)
    thrown exceptions, so throwing an exception doesn't mean that the program
    must stop.
  <p>
  The case for the result of the division of two <b>double</b> values is
    stranger.
  There is a long and tortured history of how computers should deal with this,
    and  related, problems involving anomalous operations on
    <b>double</b> values, which was finally resolved in the IEEE 754 standard.
  We will ignore this issue now, and the problem shouldn't come up in simple
     programs; but remember that if you print a <b>double</b> and it appears
     as <b>Infinity</b>, <b>-Infinity</b> or <b>NaN</b> it means you divided
     by zero, which probably means you made a mistake in your program.
</td>
</tbody>
</table>



<!-- % Operator -->

<a name="%Operator"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The % Operator: Remainder</b></td>
<td width ="80%">
  The <b>%</b> (remainder) operator is overloaded in Java with the following
    two prototypes.
  <pre><b>    int % (int,int) throws ArithmeticException
    double % (double,double)</b></pre>
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Prototype</th><th>Semantics</th><th>Examples</th>
  </thead>
  <tbody>
  <tr valign="top"><td><pre><b>int % (int,int)</b></pre></td>
    <td>A binary infix operator; its result is the <b>remainder</b> left when
          the first operand is divided by the second.
        Technically, the result's sign is the same sign of its first operand;
          the result's magnitude is the same as the remainder when the absolute
          values of its operands are divided.
        If the second operand is <b>0</b>, this operator throws the
          <b>ArithmeticException</b>.</td>
    <td><b>13%5</b> evaluates to <b>3</b>, because <b>5</b> goes into <b>13</b>
          just <b>2</b> times (<b>13/5</b> evaluates to <b>2</b>) leaving a
          remainder of <b>3</b>; <b>-13%5</b> evaluates to <b>-3</b>
          because the sign of its first operand is negative and its magnitude
          is the same as <b>13%5</b>; <b>13%-5</b> evaluates to <b>3</b>
          because the sign of its first operand is positive and its magnitude
          is the same as <b>13%5</b>; <b>-13%-5</b> evaluates to <b>-3</b>
          because the sign of its first operand is negative and its magnitude
          is the same as <b>13%5</b></td>
  </tbody>
  <tr valign="top"><td><pre><b>double % (double,double)</b></pre></td>
    <td>This space intentionally left blank.</td>
    <td>This space intentionally left blank.</td>
  </table>
  <p>
  Although most students have never seen this operator in mathematics (but
    have seen remainders in long division), it is sometimes useful in Java
    programming (and certainly not that hard to understand, at least in the
    case of non-negative integers).
  Therefore, you must know its prototype and semantics for non-negative
    integers only.
  <p>
  Obviously the <b>/</b> and <b>%</b> operators (with <b>int</b> operands) are
    related: we can call <b>/</b> the <b>quotient</b> operator and <b>%</b>
    the remainder operator.
  Generally: <b>x%y</b>, when both are non-negative integers, returns the same
     value as <b>x-(x/y)*y</b>: try evaluating this second formula for a few
     values (remember to truncate after division).
  <p>
  Two interesting facts are that if we declare <b>x</b> to be an <b>int</b>
    and store a non-negative value in it, <b>x%10</b> is the last digit of that
    number and <b>x/10</b> is every digit but the last one.
  For example, if we declare <b>int x = 4125;</b> then <b>x%10</b> evaluates to
    <b>5</b> and <b>x/10</b> evaluates to <b>412</b>.
  You must be able to understand and use both "division" operators in your
     program.
  <p>
  Finally, as with the <b>/</b> operator, the <b>%</b> operator throws the
    <b>ArithmeticException</b> if its second operand is zero.
</td>
</tbody>
</table>


<!-- Relational Operators -->

<a name="RelationalOperators">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Relational Operators<br>(for primitive types only)</b></td>
<td width ="80%">
  Java includes sixth relational operators (<b> == </b> &nbsp <b> != </b>
    &nbsp <b> < </b> &nbsp <b> <= </b> &nbsp <b> > </b> &nbsp <b> >= </b>).
  The first pair are known as the equality operators, the final four are
    known as the inequality operators.
  The equality operators are overloaded for all pairs of the same
      <b>primitive</b> type; the inequality operators are
      overloaded likewise, except <b>not</b> for the <b>boolean</b> type.
  The result produced by each is a <b>boolean</b> value.
  While only the prototypes of the <b>==</b> operator are shown below, the
    other relational operators have similar prototypes too.
  <p> 
  Note the <b>==</b> computes "is equal to" and <b>!=</b> computes
    "is not equal to"; <b>&lt</b> computes "is less than"; <b>&lt;=</b>
    computes
    "is less than or equal to"; <b>&gt</b> computes "is greather than";
    <b>&gt=</b> computes "is greater than or equal to". 
  <pre><b>    boolean == (int,int)
    boolean == (double,double)
    boolean == (boolean,boolean)
    boolean == (char,char)</b></pre>
  So each relational operator compares two values of the same type and produces
    a <b>boolean</b> result.
  We must learn to think of an operator like <b>&lt</b> just as we would think
    about an operator like <b>+</b>.
  Both take two operands and computes a result (in the former case a
    <b>boolean</b>; in the later case some numeric value).
  So we say <b> 3 < 5 </b> computes the result <b>true</b> just as we would
    say <b> 3 + 5 </b> computes the result <b>8</b>.
  We must learn to think of all Java operators, regardless of their operand
    and result types, as computing a value in this way.
  <p>
  Semantically, these operators work as we would expect on numeric
    (<b>int</b> and <b>double</b>) values.
  <p>
  Again, one can compare <b>boolean</b> values with <b>==</b> and </b>!=</b>
    but not the other four relational operators.
  <p>
  For the text type <b>char</b>, the values compare according to their ASCII
    values: each <b>char</b> value can convert to/from a small <b>int</b>
    according to the
     <a href="../../../common/handouts/ascii.html">ASCII</a> conversion table.
  You should certainly NOT memorize the ASCII table, but programmers should
    know that <b>'0'<'1'<...<'9' < 'A'<'B'<...<'Z' < 'a'<'b'<...<'z'</b>
    in ASCII.
  <p>
  The inequality operators do NOT work at all for reference types.
  The equality operators do NOT work in a straightforward way for
    variables/values of the type <b>String</b>, which you should recall is a
    class type and not a primitive type.
  We will discuss later various methods for comparing <b>String</b> values. 
</td>
</tbody>
</table>



<!-- Logical Operators -->

<a name="LogicalOperators">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Logical Operators</b></td>
<td width ="80%">
  Java includes three logical operators (<b> ! </b> &nbsp <b> && </b> &nbsp
    <b> || </b>) which are not overloaded: each has just one prototype, with
    <b>boolean</b> operands and a <b>boolean</b> result.
  The <b>!</b> operator is read "not"; the <b>&&</b> operator is read "and";
    the <b>||</b> operator is read "or".
  <pre><b>    boolean !  (boolean)
    boolean && (boolean, boolean)
    boolean || (boolean, boolean)</b></pre>
  Semantically, these operators are described by the following truth table.
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead>
  <tr align="center">
  <th><i>A</i></th><th><i>B</i></th><th><i>A</i> && <i>B</i></th><th><i>A</i> || <i>B</i></th><th>!<i>B</i></th>
  </thead>
  <tbody> 
  <tr align="center"><td><b>false</b></td><td><b>false</b></td><td><b>false</b></td><td><b>false</b></td><td><b>true</b></td>
  <tr align="center"><td><b>false</b></td><td><b>true</b></td><td><b>false</b></td><td><b>true</b></td><td><b>false</b></td>
  <tr align="center"><td><b>true</b></td><td><b>false</b></td><td><b>false</b></td><td><b>true</b></td><td></td>
  <tr align="center"><td><b>true</b></td><td><b>true</b></td><td><b>true</b></td><td><b>true</b></td><td></td>
  </td>
  </tbody>
  </table>
  <p>
  Programmers must memorize these tables to be able to analyze expressions
    that use these operators.
  Here are some short-cuts.
  Note that the result of the <b>&&</b> operator is <b>true</b> only when both
    of its operands are <b>true</b>.
  Note that the result of the <b>||</b> operator is <b>false</b> only when
    both of its operands are <b>false</b>.
  Note that the <b>!</b> operator just has one operand, so it looks a bit
    different in the truth table.
</td>
</tbody>
</table>


<!-- Implicit Conversion -->

<a name="ImplicitConversion"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Implicit Conversion</b></td>
<td width ="80%">
  What is Java to make of <b>3 + 5.2</b>?
  We have seen that the arithmetic <b>+</b> operator has two binary
    prototypes, in which either both operands are <b>int</b> or both are
    <b>double</b>.
  In fact, there are actually two different circuits in computers for
    arithmetic: one for adding pairs of <b>int</b>s and one for adding pairs
    of <b>double</b>s.
  Every addition must go through one of these two circuits.
  <p>
  Java could just rejectusing this combination of operator and operands.
  Instead, when Java sees a binary operator with one <b>int</b> operand and one
    <b>double</b> operand, it automatically converts the <b>int</b> value into
    a <b>double</b> and then uses the <b>double</b>-operands prototype of
    <b>+</b>(and its related circuit) to do the  addition.
  This is called <b>implicit conversion</b>.
  Java does implicit conversion (always <b>int</b> to <b>double</b>) whenever
    a binary arithmetic operator has different numeric types for its operands.
  <p>
  Java performs one other implicit conversion when necessary: a <b>char</b> is
    implicitly converted to an <b>int</b> (according to its value in the ASCII
    table).
  So in <b>'A'+1</b>, the <b>char 'A'</b> is first implicitly converted to the
    <b>int 65</b> so that it can be added to the <b>int 1</b> finally producing
    an <b>int</b> result of <b>66</b>.
  In fact, in the expression <b>1.5+'A'</b>, <b>'A'</b> is first implicitly
    converted to the <b>int 65</b> and then implicitly converted to the
    <b>double 65.</b> finally producing an <b>double 66.5</b> as a result.
  <p>
  Finally, the expression <b>'5'-'0'</b> implicitly converts both <b>char</b>
    values to <b>int</b> (<b>53</b> and <b>48</b> respectively: see the ASCII
    table) and then performs subtraction: the result in this case is the
    <b>int 5</b>.
  In fact, if we declare <b>char d = '8';</b> (or initialize it by any other 
    character that is a digit), then writing <b>d-'0'</b> results in an
    <b>int</b> equivalent to the digit (in this case <b>8</b>).
  Note that the ASCII value of <b>'8'</b> is <b>56</b> and of <b>'0'</b> is
   <b>48</b>.
  <p>
  Collectively, these implicit conversion are called promotion, which always
    works in just one way: <b>char</b> promoted to <b>int</b> promoted to
    <b>double</b>.
  No promotion loses information: every <b>char</b> can be represented as an
    equivalent <b>int</b> and every <b>int</b> can be represented as a
    equivalent <b>double</b>.
  Notice that the remaining primitive type, <b>boolean</b>,
   plays no part in promotion.
</td>
</tbody>
</table>



<!-- State Change Operators -->

<a name="StateChangeOperators">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>State-Change Operators<br>(primitive types)</b></td>
<td width ="80%">
  Most operators in Java just examine their operands and produce a result
    (e.g., <b>*</b> produces a result that is the product of its two operands).
  But, there is a special category of Java operators that not only produce a
    result, but also change the state of one of its operands (which is
    restricted, by a syntax constraint,  to be the name of a variable).
  Operators in this category are called <i>state-change</i> operators.
  <p>
  The most common state-change operator in Java is the <b>=</b> operator. 
  The <b>=</b> operator (known as the <i>assignment</i> or <i>stores</i>
    operator) is overloaded for each of the primitive types that we know in
    Java, with the following prototypes.
  <pre><b>   int     = (int    , int)
   double  = (double , double)
   boolean = (boolean, boolean)
   char    = (char   , char)  </b></pre>
  For these binary operators, Java restricts the first operand to be the name
    of a variable:  so <b>x=0</b> is a legal expression but <b>0=x</b> is
    illegal, according to this restriction.
  <p>
  Semantically, the value of the right operand (which can be any expression) is
    stored into the variable specified by the left operand (which is restricted
    to be a variable name), <b>AND</b> this value is also the result of the
    expression.
  So, we can use state-change operators to change the state (value) stored in
    any variable.
  <p>
  For example, if we declare <b>int x = 0;</b> and then evaluate the
    expression <b>x = x+1</b> Java first computes <b>x+1</b> (we will soon
    learn that <b>=</b> has is lower precedence than <b>+</b>, so the
    <b>+</b> operator is evaluated first) whose result is <b>1</b>, then Java
    uses the <b>=</b> operator, which changes the value stored in <b>x</b> to
    <b>1</b>; the result (of the entire expression) is <b>1</b> also.
  If we evaluate the expression <b>x = x+1</b> again, Java changes the value
     stored in <b>x</b> to <b>2</b>; the result (of the entire expression) is
    <b>2</b> also.
    char   += (char,char)</b></pre>
  As with other state-chance operators, there is a syntax constraint that the
    first operand is the name of a variable.
  <p>
  Semantically, the expression <b>x+=<i>e</i></b> is a simpler way to write
    <b>x = x+(<i>e</i>)</b> (and  similarly for the operators <b> -= </b>
    &nbsp <b> *= </b> &nbsp <b> /= </b> &nbsp and <b> %= </b>).
  So <b>x+=2</b> computes <b>x+2</b> and then stores the result into <b>x</b>;
   this new result is also the resuklt of the entire expression: it is
    equivalent to <b>x=x+2</b>.
  <p>
  Finally, Java includes two very special operators <b>++</b> and <b>--</b>
   (which increment and decrement variables by <b>1</b>).
  Both operators can be used in a prefix or postfix form; they are overloaded
    for the following types ( and the are restricted to operate on variables
    names only (we cannot write <b>0++</b>).
  <pre><b>    int    ++ (int)               int    -- (int)
    double ++ (double)            double -- (double)
    char   ++ (char)              char   -- (char)</b></pre>
  Semantically, for both prefix and postfix <b>++</b> the value of the variable
    gets incremented by 1; if the <b>++</b> is written before the variable
    (a prefix operator), the result of the operator is the NEW/CURRENT value
    stored in the variable; if the <b>++</b> is written after the variable
    (a postfix operator), the result of the operator is the  OLD/ORIGINAL value
     stored in  the variable.
  Likewise for <b>--</b> which subtracts 1 (decrements) from its variable.
  <p>
  If the variable is of type <b>char</b> it is changed to store the character
    one higher (for <b>++</b>) and one lower (for <b>--</b>). 
  <p>
  So, if we declare <b>int x=0, y;</b> and then write <b>y = x++</b> then
    <b>x</b> is incremented from <b>0</b> to <b>1</b>, but its result produced
    by this operator is <b>0</b> (the old/original value stored in <b>x</b>),
    which is stored into <b>y</b>, and this value (<b>0</b>) is the result of
    the entire expression.
  If we instead write <b>y = ++x</b> then <b>x</b> is incremented from
    <b>0</b> to <b>1</b>, and its result is <b>1</b> (the new/current value
    stored in <b>x</b>) which is stored into <b>y</b>, and this value
   (<b>1</b>) is the result of the entire expression.
  <p>
  While the prefix/postfix distinction for these operators may seem strange,
    they are both useful and we will see important uses of each soon.
  <p>
  To illustrate state change operators, we often use before/after pictures
   (the same kind of pictures used to illustrate variable declarations).
  For example, we can illustrate the meaning of <b>x=y</b> as follows.
  <p>
<img src="images/assignment.gif"></image><p>
  <p>
  Next, we can illustrate the meaning of <b>y=x++</b> as follows.
  <p>
<img src="images/statechange2a.gif"></image><p>
  And finally, we can illustrate the meaning of <b>y=++x</b> as follows.
  <p>
<img src="images/statechange2b.gif"></image><p>
</td>
</tbody>
</table>


<!-- == vs = -->

<a name="Equals">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>= vs ==</b></td>
<td width ="80%">
  When programming, we must be careful to distinguish the <b>=</b> operator
    from the <b>==</b> operator (many people pronounce both as "equals",
    leaving it to the hearer to disambiguate which from context; more careful 
    Java programmers pronounce the second "equals equals" or "double equals").
  After a few weeks using each, they won't seem so confusing.
  <p>
  As we have just learned, <b>=</b> is a state change operator: it changes the
     state of its left operand (which must be a variable) to store the value of
     its right operand (a value of the same type, or a value derived by
    implicit conversion); its result is also the value stored.
  Thus, a expression such as <b>x = x+1</b> serves to increment the value
    stored in <b>x</b> by 1 (yes, there are other ways to do this as well).
  <p>
  On the other hand, <b>==</b> is not a state change operator: it compares the
    two values of its operands (which must be of the same type, but neither
    has to be a variable), and its result is always of type <b>boolean</b>; it
    changes neither operand.
  An expression such as <b>x == x+1</b> is syntactically legal, but completely
    useless: it always computes the value <b>false</b> and has no other effect
    (it changes no states of any variables involved).
  <p>
  Confusing <b>=</b> and </b>==</b> is common.
  Be on the lookout for such mistakes, which can cause subtle bugs in your
   programs.
  In many cases the Java compiler will issue a warning if it suspects you have
     misused one of these operators (we will see examples in the next lecture)
</td>
</tbody>
</table>



<!-- Methods -->

<a name="Methods"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Mathematical Methods</b></td>
<td width ="80%">
  We can use a variety of mathematical <b>methods</b> (Java's name for
    functions) in Java by using the <b>Math</b> class (we will examine how to
    read classes soon, and write classes a bit later in the course).
  We will specify the syntax of methods also by using prototypes (just as we
    did with operators).
  But instead of operator tokens, these methods are named by a class name
   (e.g., <b>Math</b>) followed by the period separator, followed by the method
    name).
  When we learn more about classes, we will discuss this naming convention
    further.
  Here is a sampling of the prototypes of some useful methods in the
   <b>Math</b> class.
  <pre><b>    int    Math.abs    (int)
    double Math.abs    (double)
    int    Math.min    (int,int)
    double Math.min    (double,double)
    int    Math.max    (int,int)
    double Math.max    (double,double)
    double Math.pow    (double,double)
    double Math.sqrt   (double)
    double Math.log    (double)
    double Math.log10  (double)
    double Math.exp    (double)
    double Math.cos    (double)
    double Math.sin    (double)
    double Math.tan    (double)
    double Math.random ()</b></pre>
  Semantically
  <ul>
    <li><b>abs</b> returns the absolute value of its operand (overloaded for
      <b>int</b> and <b>double</b>).
    <li><b>min</b> returns the minimum of its two operands (overloaded for
       <b>int</b> and <b>double</b>).
    <li><b>max</b> returns the maximum of its two operands (overloaded for
       <b>int</b> and <b>double</b>).
    <li><b>pow</b> returns the first operand (which must be non-negative
       unless the second operand is integral: e.g., 3.)
       raised to the power of the second operand: <b>pow(x,3.5)</b> computes
       <b>x<sup>3.5</sup></b> if <b>x</b> is non-negative; otherwise it
       returns <b>NaN</b>. 
    <li><b>sqrt</b> returns the square root of its operand (which must be
        positive, otherwise returns <b>NaN</b>): <b>sqrt(x)</b> is better than
        <b>pow(x,.5)</b> (faster and more accurate) although  both are legal. 
    <li><b>log</b> returns the logarithm (base e) of it operand (which must be
        positive, otherwise returns <b>NaN</b>).
    <li><b>log10</b> returns the logarithm (base 10) of it operand (which must
        be positive, otherwise returns <b>NaN</b>).
    <li><b>exp</b> returns the e raised to the power of its operand.
    <li><b>cos</b> returns the cosine of its operand (which is expressed in
          radians, not degrees)
    <li><b>sin</b> returns the sine of its operand (which is expressed in
          radians, not degrees)
    <li><b>random</b> returns a random number in the range [0.,1.); e.g., this
          semi-open interval specifies that it can return the value <b>0.</b>
          but returns a value always strictly less than (never equal to)
          <b>1.</b>
  </ul>
  We call/invoke these methods by specifying their full name (class and method,
    separated by a period), and then enclosing the required operands (if any)
    in parentheses (separated by commas).
  This is the correct syntax for calling/invoking a method.
  So writing <b>Math.max(3,4)</b> results in the <b>int 4</b>.
  <p>    
  The <b>random</b> method is interesting because it is the first one that we
     have seen whose prototype specifies no operands.
  Yet, we still must call it with parentheses, as we must for all methods:
    <b>Math.random()</b>, which will effectively return a different, random,
    result each time that it is called.
  <p>
  Note that none of these methods are state-change methods; they produce values
    but do not change what is  stored in any variables used as operands.
  So, given <b>int a = 3, b = 4;</b> then <b>Math.max(a,b)</b> also results in
    the <b>int 4</b>, and neither <b>a</b> nor <b>b</b> changed: they still
    store <b>3</b> and <b>4</b> respectively.
  In fact, the Java programming language prohibits writing methods that change
    the states of their operands: this is a bit too subtle to understand here,
    but we will examine this statement and its ramifications soo.
  <p>
</td>
</tbody>
</table>



<!-- I/O -->

<a name="IO"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Input/Output</b></td>
<td width ="80%">
  Java uses two methods for outputing information onto the console:
    <b>print</b> and <b>println</b>.
  These methods have funny prefixes: <b>System.out.</b>
  When we learn more about classes and fields, we will discuss these prefixes
    further.
  For now, scan the overloaded prototypes of these methods.
  <pre><b>    void   System.out.print  (int)
    void   System.out.print  (double)
    void   System.out.print  (boolean)
    void   System.out.print  (char)
    void   System.out.print  (String)

    void   System.out.println()
    void   System.out.println(int)
    void   System.out.println(double)
    void   System.out.println(boolean)
    void   System.out.println(char)
    void   System.out.println(String)</b></pre>
  A <b>void</b> return type means that the method performs a command/action
    (in this case displaying something on the console) only: there is no
     resulting value that is returned.
  If I ask my son what he did in school today, I expect him to answer; if I 
    ask him to clean up his room, I expect no answer but just for him to
    perform an action (I actually don't expect him to clean up his room either,
    but that has to do with the semantics of my son).
  <p>
  Each of the <b>print</b> methods displays a value in the console window and 
    stays on the same line (so any subsequent output will continue to be
    displayed on that same line).
  Each of the <b>println</b> methods displays a value in the console window
    and then goes to the beginning of the next line.
  In fact, writing just <b>System.out.println()</b> in a program (supplying no
     operands to the method call) will print nothing and go to the beginning
     of the next line.
  So <pre><b>    System.out.print("A");
    System.out.println("B");
    System.out.println("C");
    System.out.print("D");
    System.out.print("E");</b></pre>
  displays the output <pre><b>    AB
    C
    DE</b></pre>
  with the next output following on the same line after <b>E</b>
  <p>
  We can also accomplish the equivalent by carefully using the newline
    escape characters: <b>System.out.print("AB\nC\nDE");</b>
  The <b>print</b> method processes the escape character <b>'\n'</b>
    by finishing the current line and starting a new line.
  <b>System.out.print("A\n\nB");</b> displays the output
  <pre><b>    A

    B</b></pre>
  <p>
  We frequently use the catenation operator (which always produces a
    <b>String</b>) inside these methods: e.g., 
  if we declare <b>int gamesPlayed = 0;</b> and then give the command <pre>
  <b>System.out.println("Games Played so far: " + gamesPlayed);</b></pre>
  Java will print <b>Games Played so far: 0</b>.
  <p>
  The <b>Prompt</b> class contains a variety of methods for inputing
    information.
  The prototypes for the simplest of these methods (there are more) are
  <pre><b>    int    Prompt.forInt    (String)
    int    Prompt.forInt    (String,int,int)
    double Prompt.forDouble (String)
    char   Prompt.forChar   (String,String)
    String Prompt.forString (String)</b></pre>
  In each case, the <b>String</b> operand specifies a message that the user
    sees, prompting  him/her as to what information to enter.
  <b>Prompt.forInt</b> is overloaded; its second version allows the programmer
    to specify the smallest and largest allowable values (if the user inputs a
    value outside this range, he/she is reprompted).
  Likewise, the second <b>String</b> in the <b>Prompt.forChar</b> method
    specifies all the characters that the user is allowed to enter (if the user
    inputs a value outside this range, he/she is reprompted).
  A typical use of a prompt method in a program might be in the initialization
    part of a declartion.
  <pre><b>int  cashToBet = Prompt.forInt("Enter amount of Cash to Bet"); 
char action    = Prompt.forChar("Action: w=withdraw d=deposit","wd");</b></pre> 
</td>
</tbody>
</table>



<!-- Experiment -->

<a name="Experiment"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Experiment</b></td>
<td width ="80%">
  If you have questions about operators, write a tiny program to perform an
    experiment to test your understanding (like performing a small physics or
    chemistry experiment).
  For example, what happens if you try to "add" two characters?
  Here is the simple code to put in a program to perform this experiment.
  <pre><b>System.out.println('A'+'B');</b></pre>
  Can you guess what answer is printed; if the answer is different from the one
    you expected, can you revise your understanding of implicit conversion and
    the semantics of the <b>+</b> operator to reconcile the result produced?
  <p>
  It is important to get into the habit early of not being shy about running
    experiments on the computer, even if they are as simple as this one.
  In fact, thinking of the simplest experiment to perform to check some Java
    features requires a deep understanding of programming.
  As I've been learning Java, I've run hundreds of these small experiments
    (including many for some of the more technical points in this lecture).
  <p>
  There should be a very low threshold for you to start an Eclipse project
    with a tiny program in it to test your understanding of Java.
</td>
</tbody>
</table>



<!-- Expressions Structure and Evaluation -->

<a name="StructureAndEvaluation"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The Structure and Evaluation of Expressions</b></td>
<td width ="80%">
   In this section we begin our examination of how to build simple and
     complicated expressions from literals, variables, operators, and methods.
   The EBNF rules specifying the structure of expressions are overly 
     complicated, so instead we will just describe their syntax in English
     (one of the few times we shall do so).
   Here are the three structural rules for expressions; each rule concerns
     the syntax of legal expressions (and their type).
  <ul>
    <li><b>S1</b>: A literal is a legal expression; its type is the type of the
          literal.
    <li><b>S2</b>: A variable is a legal expression; its type is the declared
          type of the variable.
    <li><b>S3</b>: An operator (or method) whose operands (each of which must
          be a legal expression) match any of its prototypes (possibly with the
          aid of automatic conversion) is a legal expression; its type is
          the result type specified in the prototype.
  </ul>
  So, by looking at an expression (and knowing the types of its literals and
    variables, and knowing the prototypes of its operators and methods) we can
    determine if the expression is well-formed according to the structural
    rules in Java,  and determine the type that results from evaluating the
    expression.
  To do this we (and Java) don't even have to know the values stored in its
    variables (we just need to know their types) nor the semantics of it
    operators/methods (we just need to know their prototypes).
  <p>
  For each syntax rule there is a companion semantic rule for <b>evaluating</b>
    expressions.
  In some sense, each expression is a question, "What is the value of ..."
    which Java answers by evaluating the expression.
  <ul>
    <li><b>E1</b>: A literal evaluates to itself (a trivial but noteworthy
          rule, for the sake of completeness).
    <li><b>E2</b>: A variable evaluates to the current value stored in it;
          remember evaluating expressions with state-change operators can
          change the values stored in variables.
    <li><b>E3</b>: An operator (or method)
    <ul><li>Evaluates each of its operands (which are themselves legal
              expressions).
        <li>Performs any implicit conversions (needed to match its prototype).
        <li>Applies the operator (or method) to its operands to compute its
              result, which is based on the semantics of that operator/method.
            </ul>
  </ul>
  Here, as above, <b>E1</b> and <b>E2</b> are simple rules; all the power is
    in rule <b>E3</b>.
  <p>
  For example, assume that we declare <b>int x = 3;</b> in a program and then
    want to determine whether the expression <b>3*x+1</b> is a legal expression
   (and what its resulting type and value is).
  The entire proof follows.
  <ul>
    <li>We can prove that <b>3</b> is a legal expression of type <b>int</b>
        (by <b>S1</b>); its value is <b>3</b> (by <b>E1</b>)
    <li>We can prove that <b>x</b> is a legal expression of type <b>int</b>
        (by <b>S2</b>); its value is <b>3</b> (by <b>E2</b>)
    <li>We can prove that <b>3*x</b> is a legal expression of type <b>int</b>
          (by <b>S3</b>: we just proved both <b>3</b> and <b>x</b> are legal
          expressions of type <b>int</b>, and one of the prototypes of
          <b>*</b> is <b>int * (int,int)</b>); its result type is <b>int</b>
          and its value is <b>9</b> (by <b>E3</b> and applying the semantics
          of the multiply operator).
    <li>We can prove that <b>1</b> is a legal expression of type <b>int</b>
          (by <b>S1</b>); its value is <b>1</b> (by <b>E1</b>).
    <li>Finally, we can prove that <b>3*x+1</b> is a legal expression of type
          <b>int</b> (by <b>S3</b>: we just proved both <b>3*x</b> and
          <b>1</b> are legal expressions of type <b>int</b>, and one of the
          prototypes of <b>+</b> is <b>int + (int,int)</b>); its result type
          is <b>int</b> and its values is <b>10</b> (by <b>E3</b> again,
          and applying the semantics of the add operator).
  </ul>
  In fact, these three rules allow us to identify the structure of -and
    evaluate- arbitrarily complicated expressions built from literals,
    variables, operators, and methods.
</td>
</tbody>
</table>



<!-- Oval Diagrams -->

<a name="OvalDiagrams"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Oval Diagrams</b></td>
<td width ="80%">
  To illustate that we understand how Java structures and evaluates our
    expressions (and more importantly, to give us a tool to analyze and debug
    incorrectly written expressions), we will study how to illustrate an
    expression as an <b>Oval</b> diagram.
  As we write expressions with many operators/methods mixing many types, this
    tool will become more and more important.
  <p>
  To create an oval diagram, first circle (or draw an oval around) every 
    literal and variable in the expression.
  These expressions are like atoms in chemistry: they contain no smaller
    constituents.
  Next, label their types on top and label their values (if you know them)
    on the bottom.
  Then, draw an oval around each operator (or method) and its operands; label
    the type with the result type of the matching prototype for that operator,
    and label the bottom with the result value (if you know how to compute it
    from its semantics).
  <p>
  Note that even if we do not know the values stored in variables, we can
    still produce an oval diagram that verified the legality of an expression;
    we just cannot determine what value it computed.
  The outermost oval is labelled by the type of the entire expression.
  Here is an example of an oval diagram for the previously discussed expression: <b>3*x+1</b>
<p>
<img src="images/oval1.gif"></image><p>
</td>
</tbody>
</table>



<!-- Operator Precedence -->

<a name="OperatorPrecedence"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Operator Precedence and Associativity</b></td>
<td width ="80%">
  Examine the oval diagram below.
  It has exactly the same tokens as the oval diagram above, but the ovals are
     a bit different.
  They both seem to "follow all the rules" for forming/evaluating expressions,
    but the ovals are in different positions, and they ultimately produce
    different results.
  The questions are: which oval diagram is correct (which is the way Java
     analyzes and evaluates expressions) and what extra rules do we need to
     know about to  construct correct oval diagrams?
 <p><img src="images/oval2.gif"></image><p>
</td>
</tbody>
</table>

<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  The answers have to do with the concepts of "operator precedence" and
   "operator associativity": which operators take precedence over other
    operators (which operators are circled/evaluated first) in an expression.
  We will learn that we can also use parentheses to override the standard
    operator precedence when we need to.
  Here is an operator precedence/association table that includes all the
    operators that we have learned so far (there are more in Java, and we will
    learn just a few more in this course). 
<p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead>
  <tr align="left">
  <th>Operator</th><th>Name</th><th>Precedence</th><th>Associativity</th>
  </thead>
  <tbody>
  <tr align="left"><td><pre><b>++ --</b></pre></td><td>postfix increment/decrement</td><td>15</td><td>none: all unary</td>
  <tr align="left"><td><pre><b>+ - ! ++ --</b></pre></td><td>unary plus/minus/negate<br>prefix increment/decrement</td><td>14</td><td>none: all unary</td>
  <tr align="left"><td><pre><b>(type)</b>expression</pre></td><td>casting (see below)</td><td>13</td><td>left</td>
  <tr align="left"><td><pre><b>* / %</b></pre></td><td>multiply divide remainder</td><td>12</td><td>left</td>
  <tr align="left"><td><pre><b>+ -</b></pre></td><td>add, subtract</td><td>11</td><td>left</td>
  <tr align="left"><td><pre><b>< <= > >=</b><pre><b>instanceof</b></pre></td><td>inequality relational</td><td>9</td><td>left</td>
  <tr align="left"><td><pre><b>== !=</b></pre></td><td>equality relational</td><td>8</td><td>left</td>
  <tr align="left"><td><pre><b>&&</b></pre></td><td>logical and</td><td>4</td><td>left</td>
  <tr align="left"><td><pre><b>||</b></pre></td><td>logical or</td><td>3</td><td>left</td>
  <tr align="left"><td><pre><b>= += -= *= /= %=</b></pre></td><td>state change</td><td>1</td><td>right</td>
  </td>
  </tbody>
  </table>
  <p>
  The rules for using these tables on expressions are
  <ul>
    <li>O1: When an expression contains two consecutive operators, neither
            appearing in parentheses, Java applies the higher precedence
            operator first.
    <li>O2: When an expression contains two consecutive operators, neither
            appearing in parentheses, and both have the same precedence,
            Java applies left associative operators left to right and it
            applies right associative operators right to left.
    <li>O3: Java always evaluates expressions in parentheses before it uses
            them as operands in other expressions (so we can use parentheses
            to override precedence, forcing the operators inside the
            parentheses to be evaluated before the operators outside the
            parentheses).
    <li>O4: Java always evaluates the operands of a method, in a left-to-right
            order, before it applies the method (computes the method's result).
  </ul>
  Thus, in the expression <b>3*x+1</b> we start by circling all literals and
    variables.
  Then we see two consecutive operators with no parentheses: the <b>*</b>
    operator has a higher precedence than the <b>+</b> operator, so it and its
    operands are circled first.
  Then the <b>+</b> operator and its operands are circled, completing the
    oval diagram. 
  Remember, lower precedence operators are evaluated last.
  <p>
  In the expression below <b>3*(x+1)</b> the subexpression <b>x+1</b> appears
    in parentheses.
  Again, we start by circling all literals and variables.
  Then we see two consecutive operators, but this time the second one is in
    parentheses.
  By rule O3, we must handle all the operators inside the parentheses first
    (circling the <b>+</b> operator first) and then circling the <b>*</b>
    operator last, after its operand has been circled.
  This complete this oval diagram.
  <p>
 <p><img src="images/oval3.gif"></image><p>
 In fact, the parentheses themselves are suggestive of two sides of an 
   oval; you can always draw ovals around parenthesized expressions: they
   can be used to represent the result computed by the last operator inside
   the parentheses.
</td>
</tbody>
</table>



<!-- Common Mistakes -->

<a name="CommonMistakes"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Common Mistakes</b></td>
<td width ="80%">
  Note that in the expression <b>A &nbsp / &nbsp B*C</b> it looks like
    <b>A</b> is being divided by the product <b>B*C</b>, but both operators
    have the same precedence, and are left associative, and all the redundant
    white space is meaningless once we have tokenized the expression (which is
    exactly what Java does first).
  So, this expression is equivalent to <b>(A/B)*C</b> and not <b>A/(B*C)</b>.
  If a formula has the product of <b>B</b> and <b>C</b> in the denominator,
    then according to the rules of operator precedence and associativity, we
    must use parentheses in the denominator.
  Some students, in an attempt to avoid parentheses, write this expression as
    <b>A/B/C</b>, but I think that this form is uglier and harder to
    understand.
  <p>
  Next, examine the following four expression that each attempt to compute the
    volume of  a sphere with radius <b>r</b>.
  The only difference among these expressions are the types of the literals
    used (the ones without decimal points are <b>int</b> and the ones with
    decimal points are <b>double</b>).
  Assume that we have already declared <b>double pi = 3.1416;</b>  
 <pre><b>    4./3.*pi*Math.pow(r,3.)                 4./3*pi*Math.pow(r,3.)
    4 /3.*pi*Math.pow(r,3.)                 4 /3*pi*Math.pow(r,3.)</b></pre>
  If we assume <b>double r = 2.;</b>, the correct answer is <b>33.510314</b>.
  This answer is computed by ALL BUT the bottom right expression.
  In all the correct expressions, every operator has operands that are
    <b>double</b> or implicitly converted to <b>double</b>.
  But in the bottom right expression, two <b>int</b>s are divided first,
    creating an <b>int</b> result, which is only then implicitly converted to
    a <b>double</b> before multiplying by the <b>double</b> variable <b>pi</b>
    (note <b>1 -> 1.</b> shows exactly where and when the implicit conversion
    occurs in the oval diagram below).
  The final result is an incorrect answer.
  <p>
  Thus, we can use oval diagrams not only to compute the type/value of an
    expression, we can use them to debug incorrectly formed expressions.
</td>
</tbody>
</table>

<img src="images/sphere1.gif"></image><p>

<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
One correct version of this expression (also involving implicit conversion,
   but at theright time and place) appears below.
Note that there is NO integer division in this expression.
<p>
</td>
</tbody>
</table>

<img src="images/sphere2.gif"></image><p>
</td>
</tbody>
</table>

<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>&nbsp</b></td>
<td width ="80%">
  When combining relational and logical operators, it is very easy to make
     mistakes.
  Our generally good intuition about arithmetic operators does not easily
    extend to these other kinds of operators, which are not themselves in
    the standard mathematics we've learned.
  <p>
  For example, suppose that we want to determine whether an <b>int</b> variable
    named <b>x</b> is between <b>0</b> and <b>10</b> inclusive.
  If we evaluate such an expression with <b>x</b> storing <b>5</b> the result
    should be <b>true</b>; if we evaluate such an expression with <b>x</b>
    storing <b>20</b> the result should be <b>false</b>.
  Let's examine the following expression, which looks like good mathematics, 
    with oval diagrams to see if it is  correct: <b>0 <= x <= 10</b>
  <p>
  <img src="images/badbetween.gif"></image>
  <p>
  Here the expression has two <b>&lt;=</b> operators (therefore they have the
    same precedence), and they are left associative (like the plus operators
    in <b>a+b+c</b>).
  So, Java evaluates the left operator first, which has a <b>boolean</b>
    result; but when it tries to evaluate the right operator, Java cannot find
    a prototype for it, even with implicit conversion (<b>boolean</b> values
    don't implicitly convert to anything).
  Thus, although this expression makes perfect sense to us, using notations
    from mathematics, it will be rejected by Java (at least it won't be a more
    subtle error, as was implicit conversion in the previous example).
  <p>
  The correct expression to test this condition is <b>0 <= x && x <= 10</b>,
    whose oval diagram is shown below for the two given examples.
  <p>
  <img src="images/goodbetween.gif"></image>
  <p>
  Notice that there is no need for implicit conversions in this expression.
  Generally, implicit conversion can lead to all kinds of errors, and should
    be avoided.
  When analyzing oval diagrams, play close attention to any implicit
    conversion and study carefully whether it always works correctly.
  <p>
  The following complicated oval diagram analyzes the expression<br>
    &nbsp &nbsp <b>b = (y = x++ + 1) < 8</b><br>
  which contains three state-change operators (two <b>=</b> and one
    </b>++</b>).
  <p>
  <img src="images/statechange.gif"></image>
  <p>
  Notice the precedence of these operators and the use of parentheses to force
    evaluation of the inner <b>=</b> operator (lowest precedence) before the
    <b>&lt</b> operator.
  <p>
  We will examine various more complicated expressions (including others
    having multiple state-change operators) in class and learn how to apply
    these rules to create oval diagrams for them.
  It is best for you to see the process, rather than static pictures.
  Make sure you are there, awake, and paying attention.
</td>
</tbody>
</table>



<!-- Explicit Conversion -->

<a name="ExplicitConversion">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Explicit Conversion<br>(casting)</b></td>
<td width ="80%">
  Sometimes it is useful to convert a value from one type to another.
  But, we should make the conversion <i>explicit</i>, not implicit.
  This is called <b>casting</b> in Java.
  Notice that casting is considered a high precedence operator (higher
    precedence than all the unary operators).
  <p>
  For example, it is sometimes the case that a program declares a few
    <b>int</b> counters, and then must compute ratios of these counters;
    to avoid the truncation that occurs with <b>int</b> division, we can
    explicitly convert an <b>int</b> value into a <b>double</b>.
  For example, suppose that we declared
    <b>int attendance = 78, capacity = 100;</b>
  Writing <pre><b>  (double)attendance/(double)capacity</b></pre> first
    converts each <b>int</b> value into a <b>double</b> (but there are no
    state-changes in the variables converted) and then performs <b>double</b>
    division on these values, computing an exact
    <b>double</b> answer without truncation (<b>78.</b>
  Of course, writing either <b>(double)attendance/capacity</b> or
    <b>attendance/(double)capacity</b> would work too; if one of <b>/</b>'s
    operands is a <b>double</b> then Java will implicitly convert the other to 
    a <b>double</b>.
  We might as well write both casts, though, to make all the conversions that 
   occur more clear.
  <p>
  Note that <b>(double)(attendance/capacity)</b> does NOT do the job.
  It first performs integer division, so it is equivalent to
    <b>(double)(0)</b> whose result is <b>0.</b> 
  <p>
  Sometimes casts are necessary to satisfy syntax constraints.
  Suppose that we wanted to generate a random integer between 1 and 6 and
    store it in the variable named <b>choice</b>.
  We CANNOT write <b>int choice = 1 + 6*Math.random();</b>
  In this expression Java would implicitly convert <b>6</b> to a <b>double</b>
    to perform the multiplication (returning a <b>double</b> result), and then 
    Java would implicitly convert <b>1</b> to a <b>double</b> to perform the
    addition (returning a <b>double</b> result); finally, we cannot store a
    <b>double</b> value into an <b>int</b> variable.
  <p>
  Instead, we can write this expression correctly as
     <b>int choice = 1 + (int)(6*Math.random());</b>
  In this case, the compiler will report no syntax constraint error because we
   have explicitly casted <b>(6*Math.random())</b> to an <b>int</b>
  Thus, the value ultimately stored in <b>choice</b> is a integer from
   <b>1</b> to <b>6</b> inclusive.
  Casting does not change the values stored in any variables.
  <p>
  Write an oval diagram for the expression above, and compute the result stored
    into <b>choice</b> for different random numbers between <b>0</b> (which
    can be generated) and <b>1</b> (which cannot be generated); try a few
    values including <b>0</b> and something a tad less than <b>1</b>.
  Use other oval diagrams to understand why
    <b>1 + 6*(int)Math.random()</b> and
    <b>1 + (int)6*Math.random()</b> do not always compute correct results.
    Does <b>(int)(1 + 6*Math.random())</b> work; use an oval diagram to find
      out.
</td>
</tbody>
</table>



<!-- Expression Pragmatics -->

<a name="ExpressionPragmatics"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Expression Pragmatics</b></td>
<td width ="80%">
  Write expressions correctly (for computers) and clearly (for people,
    including yourself).
  Use suggestive spacing, redundant parentheses, or both to clarify (for the
    person) the meanings of complicated expressions.
  <ul>
    <li>Suggestive Spacing: use extra whitespace around lower-precedence
          operators to suggest that they are evaluated later.
        Recall that whitespace doesn't change the meaning of a program (all the
          tokens remain the same).
    <li>Redundant Parentheses: use unneeded parentheses (they do not override
          the precedence of any operators) around higher-precedence operators
          to suggest that they are evaluated earlier.
  </ul>
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead><tr><th align="left">Expression</th><th>Suggestive Spacing</th><th>Redundant ()</th>
  </thead>
  <tbody>
  <tr valign="top"><td><pre><b>.5*A*T*T+V*T+D</b></pre></td>
    <td><pre><b>.5*A*T*T + V*T + D</b></pre></td>
    <td><pre><b>(.5*A*T*T)+(V*T)+D</b></pre></td>
  </tbody>
  </table>
  <p>
  Also, use literals of the correct type to avoid implicit conversion (which
    often leads to hard-to-find errors).
  If you want conversion to occur, use casting to make it explicit: doing so
    doesn't change how Java evaluates the expression (implicit conversion and 
    casting both do the same thing) but for anyone reading the program, the
    expression will be easier to understand.
  You can check the expressions you write by analyzing them with oval diagrams,
    evaluating them for a few different values to ensure that they compute the
    right answers.
  <p>
  Don't cast literals; when I see students write <b>(double)5</b> it pains me
    greatly: write just <b>5.</b> instead.
</tbody>
</table>



<!-- Problem Set -->

<a name="ProblemSet"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem Set</b></td>
<td width ="80%">
  To ensure that you understand all the material in this lecture, please solve
    the the announced problems after you read the lecture.
  <p>
  If you get stumped on any problem, go back and read the relevant part of the
     lecture.
  If you still have questions, please get help from the Instructor, a CA, a Tutor,
    or any other student.
  <ol>
    <li>Show a few different ways to declare <b>A</b> and <b>B</b> as <b>int</b> variables
          initially storing <b>0</b> and <b>1</b> respectively.
        Do it with one declaration statement; with two declaration statments; write
          slightly different variants of these that still accomplish the job.

    <p>
    <li>Both of the following are illegal declarations (according to EBNF)
<pre><b>  int x = 0, boolean isOK = false;
  int x = y = 0;</b></pre>
        Explain why.
        Write legal declarations that accomplish what these are trying to do.

    <p>
    <li>Write prototypes for each of the following methods.
        Infer the information needed in the prototype from each function's description.
       <ul>
         <li><b>countPrimesBetween</b> returns the number of primes occuring between two
                  integers: e.g., <b>countPrimesBetween(11,24)</b> evaluates to <b>5</b>,
                  because 11, 13, 17, 19, and 23 are prime.
         <li><b>distance</b> returns the euclidean distance between two points in the plane
                  (each point is represented by two <b>double</b>s).
         <li><b>inSameQuandrant</b> returns whether or not two points lie in the same
                   quadrant (each point is represented by two <b>double</b>s).
         <li><b>shuffle</b> returns the interleaved characters from its operands:
                <b>shuffle("abcd","efgh")</b> returns <b>"aebfcgdh"</b>.
       </ul>
    <p>

    <li>What are the results of each of the the following operators?
    <pre><b>    7/10   7./10   7/10.   7./10.
    7/10   57/10   157/10   2157/10
    7%10   57%10   157%10   2157%10</b></pre>
    <p>

    <li>Show the result produced by each of the following operators/methods
          (or indicate that some syntax error is present).
        If the state of some variable is changed, show that too (and indicate any
          implicit conversions). 
        Assume <b>int x = 0; String s = "ABC";</b> before each call
<pre><b>  false == false          'a' < 'Z'          'a'-'A'
  true  != true           true && false      true || false
  x++                     ++x                1 = x
  x = 1                   x == 1             x = 'A'
  Math.abs(-3.5)          Math.abs(3.5)      Math.max(3.5, 8)
  Math.sqrt(-1.)          Math.pow(-3.,2.)   Math.pow(-3.,.5)

  s = System.out.println("Hi");
</b></pre>
    <p>

    <li>Assume that we declare <b>int a = 1;</b>
        What would be stored in <b>a</b> after evaluating <b>a = a++</b>?
        What would be stored in <b>a</b> after evaluating <b>a = ++a</b>?
        What do you think the programmer is trying to accomplish?
        What is an easy way to accomplish it?
    <p>
       
    <li>What is printed in each of the following method calls.
  <pre><b>  System.out.println("" + 1 + 1 + 1);
  System.out.println(1 + 1 + 1 + "");
  System.out.println('1' + 1 + "");</b></pre>
  <p>

    <li>Analyze each of the following expressions, assuming <b>int a=1,b=2;</b> and write an
          oval diagram for each.
    <pre><b>      (a+b)/2       a+b/2
      100.*a/b      100.*(a/b)      a/b*100.</b></pre>
    <p>

    <li>Assume that we declare <b>double a,b;</b>
        evaluate the expression <b>(a+b - Math.abs(a-b))/2.</b> when
        <ul>
          <li><b>a</b> stores <b>3.</b> and <b>b</b> stores <b>5.</b>
          <li><b>a</b> stores <b>5.</b> and <b>b</b> stores <b>3.</b>
        </ul>
        Try a few other example values for <b>a</b> and <b>b</b>.
        Describe in general terms what this expression evaluates to.
    <p>
        
    <li>Assume that we declare <b>int a,b;</b> also assume that the
          method whose prototype is <b>int Util.characteristic(boolean)</b>
          returns <b>1</b> if its operand is <b>true</b> and <b>0</b> if its
          operand is <b>false</b>.
        Evaluate the expression <br>
          &nbsp &nbsp <b>Util.characteristic(a&lt;b)*a+Util.characteristic(a>=b)*b</b></br>
        when
        <ul>
          <li><b>a</b> stores <b>3</b> and <b>b</b> stores <b>5</b>.
          <li><b>a</b> stores <b>5</b> and <b>b</b> stores <b>3</b>.
        </ul>
        Try a few other example values for <b>a</b> and <b>b</b>.
        Describe in general terms what this expression evaluates to.
    <p>
        
    <li>Translate each of the following mathematical formulas (7 on the top line, 3 on the
          middle and bottom lines) into Java expressions.
        Assume that all variables (some have subscripts) are declared to be of
          type <b>double</b>.
        Writing <b>|x|</b> means the absolute value of <b>x</b>.
        Analyze each expression by writing its oval diagram.<br>
    <img src="images/formulas.gif"></image><p>
    <p>

    <li>Suppose that we declare <b>int attendance = 3000, capacity=10000;</b> the number of
          fans attending an event at a stadium and the maximum number of fans possible at that
          stadium respectively.
        Which of the following Java expressions evaluates to 30, the percentage of fans
          in the stadium? What do the "incorrect" expressions evaluate to?
        <pre><b>        attendance/capacity
        100*attendance/capacity
        100*(attendance/capacity)
        attendance/capacity*100        </b></pre>

     <li>The expression <b>x < 10 && y</b> does not compute whether <b>x</b> is less than both
           <b>10</b> and <b>y</b>.
         Show that the syntax of this expression is incorrect; how far can Java get before
           it discovers the error?
         Find a way to correctly test if <b>x</b> is less than <b>10</b> and <b>x</b> is less than <b>y</b>.
         Assume we declare <b>int x = 50, y = 20;</b>
         Draw an oval diagram that shows what value Java computes for your expression (it should
           evaluate to <b>false</b>, because <b>x</b> is not less than <b>y</b>: is that what it computes?).
     <p>

     <li>Assume that we declare <b>int x;</b>
         Write an expression whose result is <b>X</b> rounded to the nearest 10: e.g.,
           if <b>x</b> were <b>1432</b> the result would be <b>1430</b>;
           if <b>x</b> were <b>1437</b> the result would be <b>1440</b>;
           if <b>x</b> were <b>1435</b> round up so the result would be <b>1440</b> also.
         Use only the standard arithmetic operators and casting.
     <p>

     <li>Assume that we declare <b>double x;</b>
         Write an expression whose result is the <b>int</b> value closest to <b>x</b>: e.g.,
           if <b>x</b> were <b>3.2</b> the result would be <b>3</b>;
           if <b>x</b> were <b>3.9</b> the result would be <b>4</b>;
           if <b>x</b> were <b>3.5</b> round up so the result would be <b>4</b> also.
         Just casting doesn't work, because of truncation: <b>3.9</b> would be cast to <b>3</b>.
     <p>

     <li>Assume that we declare <b>int year;</b>
         Write an expression whose result is <b>true</b> whenever <b>year</b> stores a leap year
           and <b>false</b> otherwise.
         We define a leap year as any year that is a perfect multiple of of <b>4</b>, but not if it
           is a perfect multiple of <b>100</b> (unless it is also a perfect multiple of <b>400</b>).
         Note that one number is a perfect multiple of another if the remainder after division equals zero.
     <p>

     <li>Assume that we declare
         <b>int a = 2, b = 5;</b>
         What are the values of <b>a</b>, <b>b</b>, and the entire expression, after evaluating
           the expression <b>a+++b</b>; the same question, but for the expression <b>a+ ++b</b>?
     <p>

     <li>Assume that we declare <b>int x,y,z;</b>
         Write an expression that computes whether...
         <ul>
            <li>...<b>x</b> is odd
            <li>...<b>x</b> is a multiple of 20 (e.g., 20, 40, 60, ...)
         </ul>
         Assume that zero is a positive number.
         Write an expression that computes whether...
         <ul>
            <li>...<b>x</b> and <b>y</b> are both positive
            <li>...<b>x</b> and <b>y</b> have the same sign (both are positive or both are negative)
            <li>...<b>x</b> and <b>y</b> have different signs (one is positive and one is negative)
         </ul>
         Write an expression that computes whether...
         <ul>
            <li>...all three variables (<b>x</b>, <b>y</b>, and <b>z</b>) store the same value
            <li>...all three variables (<b>x</b>, <b>y</b>, and <b>z</b>) store different values (none the same)
            <li>...two variables store the same value, but the third one is different
         </ul>
       <p>

    <li>Assume that we declare <b>char c;</b>
         Write an expression that evaluates to <b>true</b> when <b>c</b> stores...
         <ul>
            <li>...a lower-case letter
            <li>...a lower-case or upper-case letter
            <li>...a character that is a digit
            <li>...an upper-case vowel
         </ul>
     <p>

     <li>Assume that we specify two points in the place with the declaration
           <b>double x1,y1, x2,y2;</b>
         Write an expression that computes...
         <ul>
            <li>...the distance between these points
            <li>...the slope of the line from the first point to the second
            <li>...whether both points lie on the same line from the origin
            <li>...whether the first point is above the second
            <li>...what quadrant the first point lies in (1st, 2nd, 3rd, or 4th)
            <li>...whether the two points lie in the same quadrant
         </ul>
     <p>

     <li>Assume that we specify a circle with the declaration 
           <b>double centerX, centerY, radius;</b>
           and a point by the declaration <b>double x,y;</b>
         Write an expression that computes whether or not the point lies inside the circle
            (including the boundary).
     <p>

     <li>Assume that specify an interval by a pair of <b>int</b> values (the ones at the beginning
           and end of the interval in the place with the declaration): <b>5</b> and <b>8</b> would
           specify the interval containing the numbers <b>5</b>, <b>6</b>, <b>7</b>, and <b>8</b>
           inclusive.
         We declare <b>int b1,e1, b2,e2;</b> to represent the beginning and end of two intervals,
           and <b>int x;</b> so represent some value.
         Note that we will guarantee that the intervals are "well formed": <b>b1 <= e1</b> and 
           <b>b2 <= e2</b>.
         <ul>
            <li>Write an expression that computes the number of values in an interval beginning with
                  <b>b1</b> and ending with <b>e1</b>.
            <li>Write an expression that computes whether...
               <ul>
                 <li>...<b>x</b> is inside the first interval
                 <li>...<b>x</b> is not inside the first interval
                 <li>...<b>x</b> is inside the first interval but not the second
                 <li>...<b>x</b> is inside either the first or second interval (or both)
                 <li>...<b>x</b> is inside either the first or second interval (but not both)
               </ul>
            <li>Write an expression that computes whether...
               <ul>
                 <li>...the first interval is the same as the second
                 <li>...the first interval ends before the second one begins
                 <li>...the first interval ends on the same value as the second one begins
                 <li>...the first interval is inside the second one
                 <li>...the first interval and the second interval overlap (at least one common value)
                 <li>...the first interval and the second interval do not overlap (no common values)
               </ul>
         </ul>
         Draw pictures to help you visualize the relationships; choose your relational and logical
           operators carefully, and try a few examples to convince yourself that your expressions are
           correct.
         For example, the following picture shows the first interval inside the second.<br>
         <img src="images/inside.gif"></image>
     <p>

     <li>Assume that we declare <b>int x,y,z;</b>
         Write an expression that computes the minimum of these three values.
         You may use the <b>Math.min</b> method.
     <p>

     <li>Assume that we declare
         <b>char d;</b> and guarantee that it stores a character corresponding
         to a digit: <b>'0'</b>, <b>'1'</b>, <b>'2'</b>, ... <b>'9'</b>.
         Write an expression that computes the <b>int</b> equivalent to that value:
           <b>0</b> for <b>'0'</b>, <b>1</b> for <b>'1'</b>, etc.
         Note that <b>(int)d</b> converts the <b>char</b> to an <b>int</b>, but not
           the right one: e.g., by the ASCII table <b>(int)'0'</b> results in <b>48</b>,
           <b>(int)'1'</b> results in <b>49</b>, ... (which should give you a clue)
     <p>

     <li>Assume that we declare
         <b>char c;</b> and guarantee that it stores a character corresponding
           to a lower-case letter: <b>'a'</b>, <b>'b'</b>, <b>'c'</b>, ... <b>'z'</b>.
         Write an expression that computes the upper case equivalent to that value:
           <b>'A'</b> for <b>'a'</b>, <b>'B'</b> for <b>'b'</b>, etc.
         Eventually, you must use casting.
     <p>

     <li>Assume that we declare
         <b>int low, high, x;</b> and that we guarantee that <b>low <= high</b>.
         Write an expression whose result is <b>low</b> if <b>x</b> is smaller than <b>low</b>,
          <b>high</b> if <b>x</b> is greater than <b>high</b>, and <b>x</b> if it is between
          these values.
          You may use the <b>Math.min</b> and the <b>Math.max</b> methods.
     <p>


 </ol>
</td>
</td>
</tbody>
</table>


</body>
</html>

