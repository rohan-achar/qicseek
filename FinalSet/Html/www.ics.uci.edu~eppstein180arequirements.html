<HTML><HEAD>
<TITLE>Game Programming</TITLE>
<META name="Owner" value="eppstein">
<META name="Reply-To" value="eppstein@ics.uci.edu">
</HEAD><BODY>
<IMG SRC="icslogo2.gif" WIDTH=472 HEIGHT=72 ALT=""><P>
<H1>ICS 180A, Spring 1997:<BR>
Strategy and board game programming</H1>

<H2>Final project requirements</H2>

Each project team must submit a printed final project report, and
demonstrate their application to me.  Project reports are due in my
mailbox in CS 448, by 5:00PM on Thursday, March 11.  Project
demonstrations will be held in the ICS labs on the third floor of the CS
building, at a date and time to be announced (likely during the
scheduled final exam time).

<P>Each project report should include the following information.

<OL>
<LI><B>Title</B>, authors, student ids, course information, and date.

<P><LI><B>Introduction</B>. What game does your project play?
Briefly describe the rules and history of the game.
Are there different variations on the rules, and if so how did you chose 
which variation to implement?
Do you know of other programs for this game, written elsewhere?
What machine or machines does your program run on?

<P><LI><B>User interface</B>.  How would a user go about playing a game 
against your program?  Include screen shots.

<P><LI><B>Search</B>.  If you use anything other than vanilla alpha-beta 
search, describe it and explain why you needed it.
What is the <I>branching factor</I> of your game (average or typical number of 
different moves available in any given position)?
How does this differ from the <I>effective branching factor</I> of your 
program (average or typical number of moves that it searches from a 
position before pruning stops the search)?
(Note, you can compute the effective branching factor by the formula 
b=x<sup>1/d</sup> where x is the total number of nodes searched and d is 
the search depth.)  Does your program always 
search to the same fixed depth, or does it use a timer to control the 
depth it searches?  How many levels deep does it typically search?
What is the total number of game positions a typical search evaluates, and 
how many evaluations per second does it perform (on whatever machine you're 
running it on; state how fast a machine this is).

<P><LI><B>Search improvements</B>.  Are you using hashing, or any search 
extensions or "extra" pruning (pruning above and beyond the normal pruning 
performed by the alpha-beta algorithm)?  If so, describe them and if 
possible say something about how much they helped improve your program's 
performance.

<P><LI><B>Evaluation function</B>.  Explain in English the terms that go 
in to your evaluation function.  Were you able to update these terms 
incrementally as moves were generated, or did you have to recompute them 
from scratch each time you evaluated a new position?  Did you try any 
other terms that turned out not to be useful? What evaluation 
terms would you add to further improve your program's performance if you 
had the time to add more terms?

<P><LI><B>Experiences</B>. What was your most interesting bug?
Which parts of the program did you find took you the most time to write?
Which parts did you find the most confusing?
What would you do differently if you were to start the same project from 
scratch?

<P><LI><B>Performance</B>. How well does your program play the game?
Does it beat you sometimes/always/never?
Include the complete moves to two games you or others have played against 
the machine, one in which you move first and one in which the machine moves 
first.  Explain any of the machine's moves that you think deserves 
explanation 
(either because you think it's a mistake, or because it's a very good and 
non-obvious move).

<P><LI><B>Source code</B>. Include a complete listing of all sources for 
your program.
</OL>

<HR>
<A HREF="/~eppstein/">David Eppstein,
<A HREF="/">Dept. Information & Computer Science</A>,
<A HREF="http://www.uci.edu/">UC Irvine</A>,
Monday, 04-Jan-1999 14:28:07 PST.
</BODY></HTML>

