<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<META NAME="GENERATOR" Content="Visual Page 2.0 for Windows">
	<TITLE>H23 Homeworks</TITLE>
</HEAD>

<BODY BGCOLOR="#99FFFF">

<P><B>H23 Homeworks:</B> Typicallyl these homeworks have a theory portion and a design or coding portion.</P>

<P><I><B>Warning:</B> Only the homework for the next assigment is guaranteed to be correct and complete. Look at
the assignment early and ask questions if you do not understand what you are supposed to do.</I></P>

<P><B>NOTE: Due Time: </B>Coding assignments are due (i.e. need to be deposited) by 10pm on tuesday of the week
that the homework is due. Work that should be handed in is due at the beginning of class on Wednesday of the week
that homework is due. Late homeworks will be marked down by 20% for each day that it is late.</P>

<P><B>Regrades: </B>For a regrade you must resubmit your homework within 1 week of receiving your score. Also you
must explain what part of your homework needs to be regraded. The entire assigment will be regraded so it is possible
to lower your score on a regrade.</P>

<P><I><BR>
</I><B>Special Homework 0: Due wednesday by 5pm.</B></P>

<P>Email your answers to me (kibler@ics.uci.edu) and cc the ta Li Zhang (lzhang1@uci.edu). Restrict your answer
to a maximum of a paragraph.</P>

<P>1. Tell me about any program that you have written purely for fun, i.e. not for any class assignment. If none,
say so.</P>

<P>2. Tell me about a program that you would like to write.</P>

<P><BR>
<I><BR>
</I><B>Homework 1:</B> Goal: <B>Review + practice object-oriented design + simple Gui interface</B></P>

<P><B>Read </B>chapter 1. chapter 1 has some useful program examples as well as a review of some basic mathematical
techniques.</P>

<P>1. . This is a finite induction problem.</P>

<P>Prove: sum(i = 1 to i = N ) { 2*i -1} = N^2.</P>

<P>2. This part requires no coding, only design. Suppose that you are coding a very limited banking systems. Customers
can only: open a savings account, close a savings account, add money to an account, and withdrawn money from an
account. You may assume that this is a new bank which begins with no customers. In the style of the lectures, define
appropriate objects and methods. You should only turn in the your final design, not the steps you used to create
the design. Also include the driver program, ie. the program which puts the objects together. This should look
like a code, but would not execute since the needed objects have not been defined. Some people like to start by
writing the driver program, guessing what objects they might need.</P>

<P>3. This part of the assigment involves writing a simple GUI interface. From the user get a file name. The file
you will use is WM.txt which is in the class folder XX. Your program will display: a) the total number of letters
(characters from a through z), b) for each letter the number of times it occurs, and c) a graphical plot of the
frequency of each letter. More specifically, you plot (i-th letter, frequency of i-th letter). Upper case letters
should be &quot;normalized&quot; to lower case letters. This can be conveniently done by transforming every read
String into a String of lower case letter via a String method.</P>

<P><BR>
<BR>
<B>Homework 2</B>: Goal: <B>Reinforce familiarity with O notation + Proofs</B></P>

<P><B>Read </B>chapter 5</P>

<P>1. Do problem 5.14, only part a. ( 6 code fragments to analyze)</P>

<P>2. Suppose T(N) = O(f(N)) and S(N) = O(g(N)).</P>

<P>a) What is T(N)*S(N)?</P>

<P>b) Prove it.</P>

<P>c) What is T(N)+S(N)?</P>

<P>d) Prove it.</P>

<P>3. Definition: A set S is convex if whenever points p and q belong to the set, then for any x between 0 and
1, the point x*p + (1-x)*q belongs to S.</P>

<P>Prove that if S1 and S2 are convex, then S1 intersect S2 is convex. The proof is straightforward, as long as
you don't lose your head. Do not attempt a geometric proof, although that might provide insight/confidence in the
result. Algebraic proofs are usually easier, once you know what might be true.</P>

<P><B>Homework 3:</B> Goal: Use <B>Gui Interface and standard Collection Classes</B></P>

<P>This assignment is somewhat similar to assignment 1, but adds the uses of Collection classes. In this assignment
you will build a Gui interface that performs a simple statistical analysis of a text document. Use the swing classes
as the awt library is deprecated. Using BorderLayout, in the north panel ask the user for a file to be processed.
In the west panel display, in sorted order, the frequency of all the words in the document. In the center panel
display a graph of the 100 most frequent words, in sorted order. The y-axis measures frequency of occurrence as
a percentage of the i-th most frequent word. So you plot the points (i-th word, frequences of i-th word). On the
north panel display the total number of words and the total number of different words.</P>

<P>You will read the file WM.txt again. One important question is: What constitutes a word? For the purposes of
this assignment a word is a sequence of characters surrounded by white-space where the first and last characters
are letters. Also you need to remove final (not internal) punctuation. Hence Jackson7 is not a word and won't be
counted. Use StringTokenizer to identify candidate words. Use a Hashtable or HashMap, provided in the Collections
package, to keep track of the number of occurences of every word. Then use TreeSet, also provided in the Collections
package, to sort the words. You will sort the words by frequency so you need to define a Comparator.</P>

<P>Start this assignment early. Do not write this is one fell swoop. Instead, start by writing a few of the simplest
throw-away programs that you can imagine that develop your understanding and confidence in individual features
of the Java language.</P>

<P><BR>
To help you with this assignment, I'm giving you a class I wrote called FileTokenizer that you might find useful.
Conceptually it is much like StringTokenizer on a file. It basically provides an iterator, but I did not make it
implement Iterator. Why not? If you find errors or improvements in this code, please let me know.</P>

<P><BR>
import java.util.*;<BR>
<BR>
class FileTokenizer <BR>
{<BR>
BufferedReader br;<BR>
String line;<BR>
StringTokenizer stok;<BR>
<BR>
FileTokenizer(String s)<BR>
<BR>
{<BR>
try<BR>
{<BR>
br = new BufferedReader(new FileReader(s));<BR>
line = br.readLine();<BR>
stok = new StringTokenizer(line);<BR>
}<BR>
catch(IOException ioe) {}; <BR>
<BR>
}<BR>
<BR>
String nextWord()<BR>
{<BR>
return stok.nextToken(); <BR>
}<BR>
boolean hasWord()<BR>
{<BR>
try{<BR>
if (stok.hasMoreElements()) return true;<BR>
line = br.readLine();<BR>
<BR>
if (line == null) return false;<BR>
<BR>
stok = new StringTokenizer(line); // misses blank lines<BR>
while ( !stok.hasMoreElements())<BR>
{<BR>
line = br.readLine();<BR>
if (line == null) return false;<BR>
stok = new StringTokenizer(line);<BR>
}<BR>
return true;<BR>
<BR>
}<BR>
catch(IOException ioe){};<BR>
return false;<BR>
}<BR>
<BR>
}</P>

<P><BR>
<B><BR>
Homework 4</B>: Goal: <B>Review and compare use of lists, stacks and arrays.</B></P>

<P><B>Due Date extended to May 8, 10pm</B></P>

<P><B>Read</B> chapter 3+ 4.3 Chapter 3 is on lists, stacks, and queues. 4.3 covers binary trees. Also read handout
on Collections.</P>

<P>In this assignment you will implement a Cache (the inteface will be defined) in 5 different ways: namely as
an array, a linked list, an ordered tree, as a linked list from the collections package (in java.util), and as
a tree from the collections package. For each implementation give an O-notation analysis. Additional compare the
implementation by generating 1,000,000 random numbers and putting them into a cache of size 1000. If these numbers
are too small (depends on your computer) you may increase them. Or run the experiment multiple times. Which implementation
of cache is performs best? What can you say about memory use, i.e. how much memory does each technique require
(give more than an O(n) analysis).</P>

<P>A Cache is a bounded, ordered container for objects. Since it only stores objects, you will actually store Double
objects. A concrete cache has a single constructor, cache(int bound) where bound is the number of elements to be
stored. Only objects that are comparable are allowed to be entered into a cache. Duplicated objects (in this case
doubles) are not stored.</P>

<P>The interface Cache has only one required method.</P>

<P>void add(Object o) .. may store the comparable object o. Object o is added if either the cache is not full or
the object o is greater than some object currently stored.</P>

<P>The constructor is Cache(int bound) where bound is the maximum number of elements to be stored.</P>

<P>It is suggested that you also define</P>

<P>Iterator iterator() .. this will allow you to view see what is stored. For this, define remove() to do nothing.
This is not trivial to define an Iterator() for Trees.</P>

<P>import java.util.*;<BR>
interface Cache<BR>
{<BR>
void add(Comparable o); // note that wrappers such as Double, Integer and the String class all implement Comparable.<BR>
}</P>

<P><BR>
You may defined additional methods, such as isFull() or remove(Object o) or whatever if you find them useful.</P>

<P>You may use your Cache class in later assignments.</P>

<P>Note: one homework has been cancelled.</P>

<P><BR>
<B>Homework 5: </B>Goals: <B>Processing files, using hashtables and a cache. Different data structures for different
goals.</B></P>

<P><B>Read </B>chapter 5 or chapter on hashing</P>

<P>The program finds interesting kmers. A kmer is contiguous string of exactly k letters. Your program will read
in two files and the size of k. Each file consists of characters from the alphabet {a,c,g,t}. The first file we
will call the family.The second file we will call the background. To create a filereader from the Masterhit directory,
you should use new File(&quot;\\\\Masterhit\\Instructional\\ics-h23\\files\\nit.txt&quot;); You may think of the
background as dna strings from the normal population and the family file as dna from people with some genetic disease.Your
program goal is to find unusual (really statistically significant) kmers that occur suprisingly often in the family
with respect to the background. For the purposes of this homework we define the unusualness of a kmer in the family
as:</P>

<P>(number of times kmer occurs in family) - ( number of times kmer occurs in background)* (size of family)/(size
of background).</P>

<P>This is the difference between he actual number of occurrences and the expected number of occurrences.</P>

<P>There are more appropriate statistical founded definitions, but involve more work and arrive at nearly the same
results.</P>

<P>This value defines how to kmers should be compared.</P>

<P>To count the number of times every kmer in a family occurs use a hashtable which is part of the collections
package (in java.util.*). For computing the background counts, you should only count the kmers that occur in the
family. Again a hashtable is suitable. If you define it properly, you can use the same hashtable as before. For
example an entry in the hashtable could consist of a pair of integers (family count, background count) and a real-values
score of the unusualness.</P>

<P>There are three major steps (b,c,d) to do this task, plus a few minor ones (a,e).</P>

<P>a) You need to read into memory two files and store them as strings. (This isn't entirely necessary, but otherwise
you will have to worry about substrings wrapping around the end of one line and the beginning of the next line).
Both files are in Masterhit\Instructional\icsh23\files. The family file is in &quot;nit.txt&quot;. This file is
in standard &quot;Fasta&quot; format, the form that molecular biologists use to store information about genes or
their surrounding regions.To process this file you need &quot;skip&quot; the comment lines. The net effect is that
you read this file and form a single long string, which should have 3500 characters. The second file is the complete
chromosome I of yeast (which has 16 chromosomes) and is called &quot;chri_230203.txt&quot;. You can guess how many
characters it has. Again you need to read the file into a single very long string. You can define the same reader
class to process either file. (I will provide that little bit of code).</P>

<P><BR>
b) computing the number of times each kmer occurs in the family ( use a Hashtable or a HashMap). You need to define
a class I call entry. Its what goes into the hashtable. The key to the entry is the kmer, a string. Since string
have good predefined hashcode you don't need to define anything special. The class entry require at least two fields:
int family count and int background count. To process the family file you consider each kmer in turn, and either
enter it into the hashtable or update the family count if it is already their. After you process the family file,
the family count will hold the number of occurrences in the family and the background count will be zero. The complexity
of all this should be <B>linear</B>. The general rule is that you also avoid processing a file. Twice through a
file is once too many.</P>

<P>The entry into the hashtable might have the fields: (string kmer, int familyCount, int backgroundCount, double
score).</P>

<P>c) computing the number of times kmers <B>in the family</B> occur in the background (use <B>the same</B> hashtable).
Processing this file is a a little different. For each kmer in the file, check to see if it occurs in the hashtable.
If it isn't there you don't care. Otherwise you update the background count.</P>

<P>d) computing unusualness and sorting the kmers by this value. Luckily hashtables have enumerators and Hashmaps
have iterators associated with them. Now you go thru the hashtable and enter the best scoring kmers into your cache
(sorted, bounded) from a previous assignment.</P>

<P>e) finally you print out the top 20 kmers from your cache with kmersize of 6 (minor step) Instead of using your
cache class, you may use TreeSet from the collections package. Actually you should print out the entry associated
with each of these kmers. So the output would look something like:</P>

<P>Kmer # of times in family # of times in background Score</P>

<P>aaaaaa 13 121 .... (not the real answer)</P>

<P>etc.</P>

<P>++++++++++++++++++ Code to follow ++++++++++++</P>

<P><BR>
Here is the code that will concatenate all the upstream regions into a single string. If you write this with s
+= br.readLine() you will have a huge (unacceptable) cost overhead. Instead (and in fact better) you could just
read in and process each upstream region. This code has worked for me, but no guarantees that is errorfree. Complaints/improvements
welcomed.</P>

<P><BR>
import java.io.*;<BR>
<BR>
class FastaReader<BR>
{<BR>
String data;<BR>
<BR>
FastaReader(String fileName)<BR>
{<BR>
try<BR>
{<BR>
File file = new File(fileName);<BR>
BufferedReader bf = new BufferedReader( new FileReader (file)); <BR>
StringBuffer sbuf = new StringBuffer((int)file.length());<BR>
<BR>
String line = bf.readLine();<BR>
while (line != null)<BR>
{ <BR>
if (line.charAt(0) != '&gt;')<BR>
sbuf.append(line);<BR>
line = bf.readLine(); <BR>
} <BR>
<BR>
data = new String(sbuf);<BR>
bf.close();<BR>
}<BR>
<BR>
catch(IOException e)<BR>
{ <BR>
System.out.println(&quot;bad file or something&quot;); <BR>
}<BR>
<BR>
}<BR>
<BR>
<BR>
}</P>

<P><BR>
.</P>

<P><BR>
<BR>
<B>Homework 6</B>: Goal: <B>Dynamic programming: the Needleman-Wunsch Algorithm.</B></P>

<P><B>Read</B> chapter 10.3 Not covered in depth in either text.</P>

<P>The Needleman-Wunsch algorithm has many applications. The most famous application is helping to discover the
function of proteins by finding similar proteins with known function. It could also be applied to spelling correction.
It is the basis of time-warping algorithms in speech recognition. Your task also includes extending the algorithm
so that it also produces an alignment. You can do this either with a graphical interface or a command line interface
or using terminal io. The input to the program consists of two strings. The output is a) the Needleman-Wunsch similarity
score and the alignment. The alignment can be illustrated via dashes, as in the following example: If using graphics,
use a fixed size font.</P>

<P>Here's an example:</P>

<P>input string1: heagawghee</P>

<P>input string2: pawheae</P>

<P>output: score = -1</P>

<P>heagawghe-e</P>

<P>--p-aw-heae</P>

<P>A dash indicates that the character was skipped. The final score is unique, but their may be several alignments
that achieve that score.</P>

<P>The Needleman-Wunsch algorithm will be discussed in class. To compute the alignment I suggest using a separate
two dimensional array to record the &quot;backpointers&quot;, although this is not necessary. One can also implement
the algorithm to use linear space, but that takes more effort and care.</P>

<P><BR>
<B>Last Assignment due June 5:  Two week assignment. A Competition! </B></P>

<P><B>Top 5 performers, scored by length of the path produced, will get double grades, i.e grade will also replace
another homework score, assuming it is a better grade. </B></P>

<P><BR>
<B>Homework 7:</B> Goal: <B>Use local improvements algorithm on the traveling salesman problem. And Graphics.</B></P>

<P><B>Read </B>Chapter 10.1 and 10.2 The topic is greedy algorithms</P>

<P>This assigment requires a graphical display. The inputs to the program are two integers. The first integer is
a seed for the random number generator and the second integer is the number of cities. The code to generate the
2-d Points is provided below. Each point will have values that range from 0 to 100. Your program should display
the initial path together with its length. There are a number of local improvements methods that you might try.
At the minimum you should implement the &quot;uncrossing&quot; heuristic. You may add other operators or approaches
as you choose. Your code will be evaluated on a random set of  40 cities. </P>

<P>The best &quot;operator&quot; I've found for improving a tour is to &quot;remove crosses&quot;. Other operators,
that are also useful , are swapping a pair of cities or moving a single city to a new point in the tour. You need
only implement the &quot;remove crosses&quot; heuristic. A formula for detecting crosses is fairly simple. Let
d[i][j] represent the distance from city i to city j. For convenience let i' and j' be the next city in the tour
(you need to worry about wrap around). Then a &quot;cross&quot; exists between i and i' and j and j' if:</P>

<P>d[i][j]+d[i'][j'] &lt; d[i][i'] + d[j][j'].</P>

<P>If you implement this with doubly linked lists, you can uncross the path with a few pointer moves. If you use
an array to store the cities, then you will need to swap a number of cities. You may use the collection class.</P>

<P>The performance measure is the length of the tour that your program finds. Your program is constrained to not
take too long, say not more than 2 cpu minutes for either problem.</P>

<P>Note the grade on the assignment is determined in the standard way, i.e. the code is correct and clean. However
for the competition, its no holds bar. The only thing that counts is the length of the tour you find. However you
would not want to double a poor grade. :)</P>

<P>Code for Generating an array of Points. Note this is like the Math functions, i.e. it is really just a long
name for a function.  may have This code guarantees that each city have unique coordinates.</P>

<P>=================== Code ===================</P>

<P>import java.util.*; // for the class Random<BR>
import java.awt.*; // for the class Point<BR>
<BR>
class PointGenerator<BR>
{ <BR>
Point[] pts;<BR>
PointGenerator(int seed, int size)<BR>
{ <BR>
pts = new Point[size];<BR>
int [] xcoord = shuffle(new Random(seed));<BR>
int [] ycoord = shuffle(new Random(seed+1));<BR>
for (int i = 0; i&lt;size; i++)<BR>
pts[i] = new Point(xcoord[i],ycoord[i]);<BR>
}<BR>
<BR>
int[] shuffle(Random r)<BR>
// returns 100 random integers with no repeats from 0..99<BR>
{<BR>
int[] ans = new int[100];<BR>
for (int i = 0; i&lt;100; i++)<BR>
ans[i] = i;<BR>
for (int i = 99, bound = 100; i&gt;0; i--, bound--)<BR>
swap(ans, i, modulo(r.nextInt(),bound));<BR>
return ans;<BR>
}<BR>
<BR>
int modulo(int i, int m) // because % doesn't compute modulo correctly<BR>
{<BR>
int temp = i%m;<BR>
if (temp&lt;0) return temp+m;<BR>
return temp;<BR>
}<BR>
<BR>
void swap(int[] a, int i, int j)<BR>
{<BR>
int temp = a[i];<BR>
a[i]= a[j];<BR>
a[j] = temp;<BR>
}<BR>
<BR>
Point[] getPoints()<BR>
{<BR>
return pts;<BR>
}<BR>
}</P>

<P>================end of code ======================= 
<HR ALIGN="CENTER">
<B>Final Exam: June 11</B></P>

<P><B>Quiz 2 gives a reasonable idea of the form of the final, except it will be longer and cover the entire course
material.</B></P>

<P><B><BR>
<BR>
<BR>
<BR>
<BR>
</B>
<HR ALIGN="CENTER">
<B><BR>
</B><BR>
<B>Homework Z:</B></P>

<P><B>Read </B>Chapter 10.1 and 10.2 The topic is greedy algorithms</P>

<P>This assigment requires a graphical display. The input to the program is the number of cities. Each city will
be placed randomly at (i,j) where i and j are between 0-100. Display the random path together with its length.
Implement two ways of solving the problem: an exhaustive method and a local improvement method. The user should
be able to specify which method. Each time a method improves the path, show the new path and the new length. Compare
the effectiveness of each method on problems of size 10. To do this run each method on 10 problems. Of course the
exhaustive method will find the best solution, but how good is the heuristic approach. Also record the amount of
time each method makes. Also try both methods on larger problems. When does the exhaustive approach fail - i.e.when
is it unable to solve the problem in a reasonable amount of time (reasonable = 1 minute)? Run the heuristic 10
times on the same problem of size 50, but randomize the initial ordering of the cities before each run.</P>

<P>The best &quot;operator&quot; I've found for improving a tour is to &quot;remove crosses&quot;. Other operators,
that are also useful , are swapping a pair of cities and moving a single city to a new point in the tour. You need
only implement the &quot;remove crosses&quot; heuristic. A formula for detecting is fairly simple. Let d[i][j]
represent the distance from city i to city j. For convenience let i' and j' be the next city in the tour (you need
to worrry about wrapping around). Then a &quot;cross&quot; exists between i and i' and j and j' if:</P>

<P>d[i][j]+d[i'][j'] &lt; d[i][i'] + d[j][j'].</P>

<P>If you implement this with doubly linked lists, you can uncross the path with a few pointer moves. If you use
an array to store the cities, then you will need to swap a number of cities.</P>

<P><BR>
<BR>
<BR>
<B>Homework X: </B>N-Queens Problem</P>

<P>This assignment requires a graphics. Optionally you may let the user choose a board size, but you can set it
at some reasonable number between 20 and 100. Display the board with a random placement of N-queens. Implement
a greedy local improvement algorithm. For each cycle of the algorithm display the number of queen moves. Provide
appropriate summary information once a solution is reached.</P>

<P><BR>
<BR>
<B>Homework X: </B>Goals: Graphics, binary search</P>

<P><B>Read </B>Appropriate chapter</P>

<P>In this assignment you will implement a gui interface that displays a polynomial and some information about
the polynomial. The input to the program is a line like: 2*x^3+5*x+3 and a pair of real numbers, say 3.1 and 6.1.
The constructor for your polynomial class is <B>Polynomial(String s).</B></P>

<P>You should define a method<B> double evaluate(double d)</B> which evaluates the polynomial on the given real
number. There is a clever way to evaluate a polynomial.</P>

<P>Your program will graph the function over the range provided. Finally your program will display a solution to
the problem of polynomial(x) = 0. To do this part of the problem you need to assume a solution exists. To solve
it, use binary search. In order to apply binary search you will need to have two values x1 and x2 in the domain
such that poly(x1) &gt; 0 and poly(x2) &lt;0, or vice versa. To find such values I suggest a simple linear search
over the domain, i.e. test poly(x[i]) and poly(x[i+1] where the x[i]'s break the domain into 100 equal sized parts.
Once these values are found, use binary search to yield an approximate solution to poly(x) = 0.</P>

<P>This following is a <B>possible </B>and simple layout for the GUI interface. The interface contains three text
fields for the inputting the polynomial ( a string) and the left and right bound. It a button that causes the graphing
of the polynomial on someJPanel.. When the polynomial is drawn, a solution to p(x) = 0 (if it has a solution) should
be indicated graphically and numerically, i.e. in a JTextField.</P>

<P>As always you should provide time and space analysis as appropraite.

</BODY>

</HTML>
