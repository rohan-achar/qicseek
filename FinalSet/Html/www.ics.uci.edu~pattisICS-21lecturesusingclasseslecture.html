<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<title>Objects, Using Class Libraries/JavaDoc</title>
</head>

<body BGCOLOR="white">

<center>
<h1>Objects, Using Class Libraries/Javadoc</h1>
<p>
<h2>Introduction to Computer Science I-III
<br>
ICS-21/-22/-23
</h2>
<p>
</center>


<!-- Introduction -->

<a name="Introduction"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Introduction</b></td>
<td width ="80%">
  In this lecture we will begin our study of object-oriented programming (OOP).
  We start by generalizing the concepts of variables and operators for
      the <b>String</b> class, which is a special example of a reference type.
  In doing so, we will examine four important technical terms (class, object,
    variable, and reference) and highlight the relationships among them.
  We also begin discussing the <b>new</b> operator, which returns a reference
    to a new object constructed from any specified class.
  <p>
  Next we will learn how to recognize and use the three fundamental features
    of classes (constructors, methods, and fields) to construct and
    manipulate a wide variety of objects.
  We will also learn how to read the Javadoc (documentation) for classes,
    which includes detailed and cross-indexed information about the use and
    meaning of each feature available in a class.
  We will examine a sampling of classes from Sun's standard Java library and
    from ICS-21/22/23's Java library, learning how to manipulate objects
    constructed from these classes in interesting ways.
  <p>
  Finally, we will examine two more classes, which perform file input/output,
     in detail: <b>TypedBufferReader</b> and <b>TypedBufferWriter</b>.
  We will reinforce the material covered earlier and learn useful patterns for 
    file input and output using these classes, including more about exception
    handling, which was briefly discussed in the previous lecture.
  <p>
  Each object is a small tool that we can use/manipulate to help us perform
    some part of a programming task.
  There are libraries of classes from which we can construct all the tools
    that we need to make it easier for us to solve programming problems.
   We will also learn how to build our own tools by learning how to write our
     own classes.
</td>
</tbody>
</table>



<!-- Types -->

<a name="Types">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Reference Types: Classes and Objects</b></td>
<td width ="80%">
  Every Java type is either a primitive type or a reference type.
  We have already learned a lot about the primitive types (<b>int</b>,
    <b>double</b>, <b>boolean</b>, and <b>char</b>) and about their literals,
    operators, and methods (in the <b>Math</b> and <b>Prompt</b> classses).
  Now we will begin learning about reference types, which are richer (there
    are thousands in the standard Java library) and more powerful (but a bit
    more complicated to use).
  <p>
  A reference type is most simply the name of a class; these names are just
    Java identifiers, which by convention start with a capital letter.
  In fact, we have already learned a bit about one reference type: the
    <b>String</b> class.
  Before exploring this class in more detail, let's discuss the fundamental
    relationship between classes and objects.
  Read and reread the following paragraphs until they make good sense; think
    of other examples, discuss this material with friends, and talk to the
    staff about it.
  <p>
  Generally, a class is like a blueprint.
  We can construct new objects from a class by using Java's <b>new</b>
    operator, which acts like a skilled worker who can read any blueprint
    and construct objects from them.
  Each object stores its own special state (information about that object),
    which may be the same or different than other objects constructed from
    the same class.
  <p>
  In Java, <b>new</b> is a unary prefix operator, which takes as an operand the
    name of any class (following the class name, inside parentheses, is any
    information that the class requires to specify the initial state of the
    object being constructed).
  We illustrate objects by ovals; each is labelled by its class name and each
    encloses its current state.
  Methods can examine and change the state of an object.
  <p>
  For example, we might have the blueprints (class) for constructing a certain
    model of a Sony radio.
  We can construct as many radios (objects) as we want from the same blueprint
    (class).
  The state of one radio (object) might be turned off; the state of two others
    might be turned on, playing 89.5 FM at volume level 2; the state of yet
    another  might be playing 503 AM at volume level 3.
  The four objects just described might be pictured informally as follows.
</td>
</tbody>
</table>
  <img src="images/sony.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  Now, let's return to the <b>String</b> class, which is part of the standard
    Java library; the state of an object constructed from this class is just
    a sequence of characters.
  What makes this class unique is that it is the only one that has
    literals: of course, all primitive types have literals, but no other
    classes do.
  When we write a <b>String</b> literal in our code, Java automatically
    constructs a new object from the <b>String</b> class with the literal
    as its contents.
  But, to construct objects from ANY OTHER CLASS in Java, we need to use the
    <b>new</b> operator.
  To get into this habit, we will redundantly write <b>new String("...")</b>
    in this lecture whenever we want to construct a new object from the 
    <b>String</b> class (even though writing just <b>"..."</b> in our
    code would accomplish almost exactly the same result -I say ALMOST because
    there is still one missing detail that is too complicated to explain here).
  <p>
  Thus, <b>new String("...")</b> is an expression that has a value: it tells
    Java to apply the <b>new</b> operator to the <b>String</b> class.
  The result returned (all operators return results) is a reference to a newly
    constructed object from the <b>String</b> class.
  The object itself, represented by a labelled oval) stores the sequence of
    characters; we can then store the reference to that object inside a
    variable that is declared to be of type <b>String</b>.
  References always appear as ARROWS: their tail is INSIDE the variable's box
    and their head POINTS TO an object (its arrow head touches the oval).
  In summary the <b>new</b> operator has two aspects to its behavior.
  <ul>
    <li>It constructs an object from a class and initializes its state.
    <li>It returns as a result a reference to the object that it constructs.
  </ul>
  <p>
  Note: objects have classes but DO NOT have names.
  Reference variables, which have names and types, store references that refer
    to objects.
  The type of a reference variable must always be compatible with the
    class of the object to which it refers.
  For simple object-oriented programming, the type will be the same as the 
   class.
  But, once we begin examining interfaces and and class hierarchies, the
    relationship between variable types and object classes will become 
    richer and more powerful, but more complicated too.
  <p>
  For now, we will keep things simple: the type of a variable will always be
    the same as the class of the object that it refers to.
  Putting all these ideas together, we can illustrate the declaration
    <b>String s = new String("Java");</b> by
</td>
</tbody>
</table>
  <img src="images/stringref.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  Here, we declare the variable <b>s</b> to be of type <b>String</b> (meaning
    it can refer to <b>String</b> objects); in addition, we initialize this
    variable to store the reference that <b>new</b> returns as a result of
    constructing the <b>String</b> object whose state is initialized to
    <b>"Java"</b>.
  Thus, there are really two initializations: the state of the object is
    initialized to <b>"Java</b> and the state of the variable is initialized
    to a reference that refers to this object.
</td>
</tbody>
</table>


<!-- Declaring Reference Variables -->

<a name="ReferenceVariables">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Declaring Reference Variables</b></td>
<td width ="80%">
  Thus, we can use the standard Java syntax for declarations to declare (and
     initialize) reference variables.
  For refrence variables, we have three different choices: we can declare the
    variable and
  <ul>
    <li> not initialize it
    <li> initialize it to the value <b>null</b>
         (a keyword, indicating that it refers to no object)
    <li> initialize it to refer to some object
         (either a <b>new</b>ly constructed object or an
           object that has already been constructed
  </ul>
  We illustrate each of these three possibilites in the code and picture below.
</td>
</tbody>
</table>
  <img src="images/declarations.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  We say that a reference variable is uninitialized, stores <b>null</b>, or
    stores a reference to an object.
  We will rarely see <b>null</b> literals in the early part of ICS-21, but
    we will see them at the end, when we start discussing arrays.
  We we will use <b>null</b> frequently in ICS-22 and ICS-23, once we start
    learning about using self-referential classes to construct linked lists.
  <p>
  We say that the <b>String</b> variable <b>s3</b> stores a reference to a
    <b>String</b> object (the object is constructed by <b>new</b>, which
    returns a reference to the object it constructed) whose state is
    initialized to <b>"abc"</b>;
  Say this sentence out loud a few times; get a feeling for these words,
    which we will use over and over again, always in the  same technical sense.
  Finally, we frequently talk about the state of an object (what information
    it stores); we will soon learn about methods that can examine and change
    the state of an object.
</td>
</tbody>
</table>
  <img src="images/nomenclature.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  All variables, primitive and reference, store state.
  But with reference variables, we speak of two states: the standard state of
    the variable (the one reference it stores) and in addition the state of the
    object (all the information it stores).
  <ol>
    <li>A variable (box) stores its state (one value); if this value is a
        non-<b>null</b> reference, it refers to an object
    <li>That object (oval) stores its state (which can comprise many values
          mixing together a variety of types).
  </ol>
  So, we must distinguish the state of the variable (a reference) from
    the state of the object it refers to (in this case, a sequence of
    characters).
  We did not have this complexity with primitive variables: they stored
     just their (single value) state directly.
  We can use reference variables to do more interesting things; but there is
    no free lunch: the penalty for usefulness is extra complexity.
  <p>
  Finally, we will also use the word <b>instance</b> as a synonym for object;
    each  object is an instance of the class from which it was constructed.
  Recall that we construct instances from a class by using the <b>new</b>
     opererator, with the name of that class and the information specifying
     the initial state of the newly constructed object.
  So, in the picture above, we can also say that the variable <b>s3</b> refers
    to an instance of the <b>String</b> class; one whose state is initialized
    to <b>"abc"</b>.
</td>
</tbody>
</table>


<!-- Constructing and Sharing -->

<a name="ConstructingSharing">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Constructing new objects; sharing old objects; the meaning of = for references</b></td>
<td width ="80%">
  We will now explore two different code fragments, and gain insight into
    the semantics of the <b>=</b> operator when applied to variables that
    store references.
  First, examine the following two declarations.
</td>
</tbody>
</table>
  <img src="images/decl1.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  Here we declare two variables.
  Into each we place a reference to a <b>new</b> object: recall that the
    expression <b>new String("...")</b> ALWAYS constructs a new object (an
    instance of the <b>String</b> class) and returns a result that is a
    reference to that object.
  The Java declarations specify to store the reference to each of these
    objects into its associated variable.
  Although each object stores the same state (the characters inside it), Java
    constructs new, distinct objects in each declaration.
  Ignore the red boxes for now.
  <p>
  Let's contrast this situation with the following two declarations
   (followed by an expression statement: we could have combined the
    second declaration and expression statement, and equivalently written
    just the declaration <b>String s2 = s1;</b>).
</td>
</tbody>
</table>
  <img src="images/decl2.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
   Here, we also declare two variables; but we construct only one <b>new</b>
     object.
   The variable <b>s2</b> originally is uninitiallized (note the <b>?</b>).
   Then <b>s1</b>'s reference (the value stored in that variable) is stored
     into <b>s2</b> as well (in the statement <b>s1 = s2</b>;) we cross out
     the <b>?</b> as well.
   So in this case, <b>s1</b> and <b>s2</b> now both refer to the same object;
     we also say that <b>s1</b> and <b>s2</b> <b>share</b> an object.
  <p>
  Note that a reference (arrow) always leads from a variable's box to an
    object's oval; it never leads to a another variable's box!    
  <p>
  One of the most important things that you will learn this quarter is the
    semantics of the <b>=</b> operator on references.
  Its use will arise, over and over again, in more and more complex
    circumstances.   
  <p>
  <b>We store/copy a reference into a variable by making that variable refer
       to the same object that the reference refers to</b>.
  <p>
  Because <b>s1</b> stores a reference to the object shown, we store that
    reference into <b>s2</b> by making <b>s2</b> refer to the same object.
  I cannot overemphasize how important it is for budding object-oriented
    programmers to memorize these semantics.
  Repeat the boldfaced sentence aloud a few times; it must become part of you.
  <p>
</td>
</tbody>
</table>



<!-- Operators and Methods -->

<a name="Methods">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Operators and Methods on Objects</b></td>
<td width ="80%">
  We have already learned that one of the overloaded prototypes of the
    <b>+</b> operator takes as operands two <b>String</b> operands.
  Now we fill in some details: it takes two references to <b>String</b>
    objects as operands and returns a result that is a reference to a new
    <b>String</b> object whose state is the catenation of the state of its
    two operands (without changing the state of either operand).
  We can illustrate this behavior with the following code and picture.
</td>
</tbody>
</table>
  <img src="images/catenate.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  Thus, operators can also construct new objects implicitly.
  The <b>+</b> operator implicitly constructs a new object whose state is
    determined by the states of its operand objects; it returns a reference to
    this new object that it constructs.
  In the code above, the reference to this object is stored into <b>s3</b> as
     an initialization in its declaration.
  <p>
  Now lets discuss generalizing method calls for reference types.
  The notation that we will discuss is the most important notational aspect of
    Object-Oriented Programming.
  We will use an analogy to discuss calling methods on the objects referred to
     by variables.
  We might say using English syntax, "John, stand up" to get the object
    referred to by the name of "John" to change his state by standing up.
  In Java syntax we would write this as the expression statement,
     <b>john.standUp();</b>
  <p>
  Likewise, we might say, "John, drink a glass of milk."
  In Java syntax we would write this as the expression statement,
    <b>john.drink(glassOfMilk);</b> where <b>glassOfMilk</b> refers to some
    other object (the glass of milk that John is supposed to drink): by
    performing this method, the state of the milk glass object becomes empty,
    while John's state becomes full.
  <p>
  Generally, we use a variable name to specify which object to call a
    method on (the object it refers to); the method is like a verb telling the
    object what to do, and the information (if any) provided in the
    parentheses corresponds to direct objects related to the verb (if it is
    a transitive verb).
  <p>
  Syntactically we write the name of the variable, followed by a
    period (a separator), followed by the name of 
    the method, all followed by a pair of open/close parentheses
    (separators/delimiters).
  If there are any operands to the method (like direct objects in English), we
    list them inside the parentheses, separated by commas (separators).
  If there are no operands, we still MUST include the open/close parentheses.
  <p>
  Let's take a look at the syntax and semantics of the <b>toUpperCase</b>
     method: it is called in the form <br>
&nbsp &nbsp <i>object-reference</i><b>.toUpperCase()</b><br>
    and returns as a result a reference to a newly constructed
    <b>String</b> object whose state is the upper-case version of the state of
    the object to which  <i>object-reference</i> refers.
  We can illustrate this behavior with the following code and picture.
</td>
</tbody>
</table>
  <img src="images/uppercase.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  The <b>toUpperCase</b> method is called on the object referred to by the
    variable <b>s1</b>; this method implicitly constructs a new object whose
    state is determined solely by the state of its <i>object-reference</i>
    (there are no other operands between the parentheses); it returns a
    reference to this new object.
  The reference to this object is stored into <b>s2</b> as an initialization
    in its declaration.
  <p>
  Instead, we might have written the code shown below.
</td>
</tbody>
</table>
  <img src="images/uppercase2.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  <p>
  Here, when the <b>toUpperCase</b> method returns its result (a reference
    to a new object), it is stored back into variable <b>s1</b>.
  Because a variable may store <b>only one</b> reference at a time, we cross
    out the other (previously stored) reference.
  What happens to the original object when, as is the case here, there are no
    references to it?
  Java can reclaim it (the storage it occupies) for use later: when
    <b>new</b> has to construct another object.
  This concept is called <b>automatic garbage collection</b> and we 
    will continue to discuss it in increasing depth throughout the 
    ICS-21//22/23 sequence.
  <p>
  Conceptually, this declaration and assignment is similar to
    <b>int i = 5; i = -i;</b>, because the variable first stores <b>5</b> and
    then the value of the <b>int</b> variable is used to compute another value
   (<b>-5</b>) which is stored back into the variable.
  Whether a variable stores a primitive value or reference, it can store only
    one values at a time; storing a new value in a variable means replacing 
    (and totally forgetting about) the  old value.
  <p>
  Let's take a look at the syntax and semantics of the <b>replace</b>
     method: it is called in the form <br>
&nbsp &nbsp <i>object-reference</i><b>.replace(</b><i>old character</i><b>,</b><i>new character</i><b>)</b><br>
    and returns as a result a reference to a newly constructed <b>String</b>
    object whose state is almost the same as the state of the
    <i>object-reference</i>, but with each occurence of <i>old character</i>
    replaced by <i>new character</i>.
  We can illustrate this behavior with the following code and picture.
</td>
</tbody>
</table>
  <img src="images/replace.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  The <b>replace</b> method is called on the object referred to by the
    variable <b>s1</b>; this method implicitly constructs a new object whose
    state is determined by the state of its <i>object-reference</i> and its
    two operands (between the parentheses); it returns a reference to this new
    object.
  The reference to this object is stored into <b>s2</b> as an initialization in
   its declaration.
  <p>
  The <b>String</b> class contains many many more methods for examining and
    creating new objects.
  For example, after the above declarations, writing <b>s2.length()</b>
    returns as a result the <b>int</b> value <b>7</b>.
  In fact, since the <b>replace</b> method itself returns a reference to a
    <b>String</b>, we can write the more complicated expression
<pre><b>  String s2 = s1.replace('d','p').toUpperCase();</b></pre>
  This is known as a <b>cascaded method call</b> (they are left associative).
  It is similar to the composition of functions in mathematics <b>g(f(x))</b>,
    which is right associative.
  When <b>replace</b> is called on the object <b>s1</b> refers to, it returns
    a reference to its result (another <b>String</b> object); at that point,
    the <b>toUpperCase</b> method is called on the reference to that object,
    which returns a reference to its result: another <b>String</b> object whose
    state is <b>"CANPIPE"</b>.
  <p>
  Note that the result here is the same as calling
    <pre><b>  String s2 = s1.toUpperCase().replace('D','P');</b></pre>
    which reverses the order of the method calls, and also changes the operands
    of <b>replace</b> to appear in upper case.
  We will discuss more <b>String</b> methods (and cascaded method calls)
    later in this lecture.
</td>
</tbody>
</table>


<!-- equality operators -->

<a name="Equality">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The == and != Operators</b></td>
<td width ="80%">
  We have now seen how the <b>+</b> operator and <b>toUpperCase</b> and
   <b>replace</b> methods work on references to <b>String</b> objects, and
   how the <b>=</b> operator works on references in general.
  <p>
  Now we will discuss the semantics of the <b>==</b> and <b>!=</b> operators
    when applied to any and all references.
  If we compare two references (typically each is stored in a variable) with
    <b>==</b>, the result is <b>true</b> when both refer to the same object
    (both variables store the same reference).
  We call <b>==</b> the "object identity" operator, because it determines
    whether or not two references refer to the same object.
  This comparision DOES NOT DEPEND ON THE STATE stored inside the objects; it
    depends only on the identity of the objects.
  <p>
  Thus, in the red box in the first picture in the previous section,
    <b>s1==s2</b> returns a result of <b>false</b>, because these variables
    store different references; i.e., refer to different objects. 
  It make NO DIFFERENCE to <b>==</b> that the states of these two different
    objects are the same.
  Likewise, in the red box in the second picture, <b>s1==s2</b> returns a
    result of <b>true</b>, because these variables do store the same reference;
    i.e., they each refer to the same object.
  <p>
  As you would suspect, the <b>!=</b> operator performs the same kind of
    comparison, but returns the opposite value: <b>true</b> if they are
    different objects and <b>false</b> if they are the same object.
  <p>
  The next section discusses how we can test something different, whether the
    STATES stored inside two objects are the same.
</td>
</tbody>
</table>


<!-- equals method -->

<a name="EqualsMethod">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>The equals Method</b></td>
<td width ="80%">
  Finally, there is an alternative way to test whether two <b>String</b>
    objects store the same STATE.
  It uses the <b>equals</b> method.
  As illustrated in the red boxes in the pictures above, both calls to this
    method return <b>true</b>: the first asks the object referred to by
    <b>s1</b> to check whether its STATE is the same as the state of the
    object referred to by <b>s2</b>; although the two objects are different,
    their STATES are the same.
  The second call asks the object referred to by <b>s1</b> to check
    whether its STATE is the same as the state of the object referred to by
    <b>s2</b>; here, <b>s1</b> and <b>s2</b> refer to the same object, so
    it is asking one object to see whetherh its STATE is the same as itself,
    which is always <b>true</b>.
  <p>
 In fact, here is a Java theorem: <b>s1 == s2</b> implies
     <b>s1.equals(s2)</b>.
  But, if  <b>s1.equals(s2)</b> evaluates to <b>true</b>, we cannot know
    whether or not <b>s1 == s2</b> also evaluates to <b>true</b>.
  Thus, the <b>==</b> operator is testing a stronger property than the 
    <b>equals</b> method.
  <p>
  In the examples above, we could also write either <b>s1.equals(s2)</b> or
    <b>s2.equals(s1)</b> to test for identical states (the object doing the
    testing and the object being tested are interchangable).
  Both method calls always produce the same result.
  <p>
  Recall that with a reference variable and object, two things are stored: the
    variable stores its state (a reference), and the reference refers to an
    object that stores its state (some information).
  It is logical that we need two different ways to compare these two different
    states for equality.
  Thus, <b>==</b> checks whether the variables store the same state;
     <b>s1.equals(s2)</b> (and <b>s2.equals(s1)</b>) checks whether the objects
     they refer to (they may or may not be the same) store the same state.
  <p>
   It is reasonable to require two different ways to check these two different
    forms of equality, but it causes lots of confusion for students just
    learning object-oriented programming.
  Try to reread this material until it becomes intuitive; we will certainly
    see many examples of their use.
  Whenever you think about testing equality, a little light should go off in
    your head that makes you pause and ask which of the two forms of equality
    to check.
  If <b>s1</b> and <b>s2</b> store references to <b>String</b> objects, you are
    much more likely ask whether they are <b>equals</b> than whether they
    are <b>==</b> (and the same is true for other classes).
  <p>
  <b>In ICS-21, you almost always want to use <b>.equals</b> to check
       for <b>String</b> equality</b>.
  Forgetting this fact will cause you to waste hours debugging your programs.
</td>
</tbody>
</table>


<a name="eqvseq">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>== vs equals<br>(one last time)</b></td>
<td width ="80%">
When comparing for equality, which must specify which equality: that of the
   <b>==</b> operator or that of the <b>equals</b> method.
We can use a simple analogy to differentiate between these two possibilities.
<p>
Imagine a house full of people and TVs.
Each person represents a reference variable; each TV represents an object; the
  channel to which the TV is tuned represents the state of the TV.
Just as each reference variable refers to an object, each person is watching
   a TV.
<p>
Assume we declare and intialize the variables <b>johnsTV</b> and <b>bobsTV</b>.
We might want to know whether John and Bob are watching the same TV: that is
  analogous to evaluating <b>johnsTV == bobsTV</b>.
We might want to know whether John and Bob are watching the same channel: that
   is analogous to evaluating <b>johnsTV.equals(bobsTV)</b> or
   <b>bobsTV.equals(johnsTV)</b>, because we don't care which TV they are
   watching (which object they are referring to), we care only whether their
   TVs are on the same channel (their objects store the same state).
<p>
Of course, if John and Bob are watching the same TV (<b>johnsTV == bobsTV</b>)
   then we know for sure that they must be watching the same channel
   (<b>johnsTV.equals(bobsTV)</b> or <b>bobsTV.equals(johnsTV)</b>) too.
</td>
</tbody>
</table>



<!-- Class Terminology -->

<a name="ClassTerminology">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Class Terminology</b></td>
<td width ="80%">
  We will now begin a more systematic examination of Java classes.
  Our focus is still on learning about classes by reading them, and using
    the knowledge that we gain to write programs that correctly construct
    and manipulate objects from these classes.
  We will identify and discus a large number of technical terms that help
    us talk precisely about classes; we will use these terms repeatedly
    during the quarter.
  <p>
  A class defines and documents three kinds of <b>members</b>.
  <ul>
    <li><b>Constructors</b>: used by <b>new</b> to create objects 
    <li><b>Methods</b>: operations we can apply to objects to examine/change
            their state
    <li><b>Fields</b>: variables inside objects that represent its state
  </ul>
  We will also further classify methods (which are by far the most interesting
     members) as either
  <ul>
    <li><b>accessors/queries</b>: examine, but DO NOT change the state of
             objects
    <li><b>mutators/commands&nbsp</b>: change the state of objects
  </ul> 
  Likewise, we will classify fields as either
  <ul>
    <li><b>instance variables</b>: each object -an instance of a class-
             stores its own instance variables
    <li><b>static fields</b>: all objects constructed from the same class
             share the same common static fields
  </ul>
  <p>
  Also of paramount importance when reading/using classes is the concept of
    <b>access modifiers</b>.
  Each member specifies its own access modifier(s), which control(s) how
    programmers can access/use it.
  In this lecture we will study the <b>public</b>, <b>private</b>,
     <b>static</b>, and <b>final</b> access modifiers (which are all Java
     keywords). 
  <ul>
    <li>A member with a <b>public</b> access modifier can be used by any
          programmer.
        Typically, most constructors and methods use the <b>public</b> access
           modifier.
    <li>A member with a <b>private</b> access modifier can be used only by the
          programmer writing the class (not by a programmer using the class).
        Typically, most instance variables use the <b>private</b> access
           modifier.
    <li>A member with a <b>static</b> access modifier is shared by every object
           in the class.
    <li>A member with a <b>final</b> access modifier is in some sense
           <i>unchangable</i>; for fields, this simply means that once the
           they are initialized, they may not be stored into again (just like
           the inclusion of <b>final</b> when declaring local variables).
        So, the Java compiler will detect and report an error if we try to
          use a state-change operator to store into a <b>final</b> field
          that has already been initialized.
 </ul>
  For programmers reading a class (to understand how to use it) only
    <b>public</b> members are important (mostly constructors and methods).
  A programmer implementing (or maintaining the implementation of) a class must
    also understand its <b>private</b> members (mosty instance variables, 
    but sometimes constructors and methods too).
</td>
</tbody>
</table>



<!-- Member EBNF -->

<a name="MemberEBNF"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>EBNF of Members</b></td>
<td width ="80%">
  We will now examine the EBNF rules governing how members are defined in
    classes.
  When we learn how to write our own classes, we will be guided by these same
    rules.
  Because there are so many, first we will look at rules describing the
     big picture.
  <p>
&nbsp &nbsp <i>access-modifiers</i> &nbsp &nbsp &nbsp &nbsp &nbsp <= [<b>public</b>|<b>private</b>] [<b>static</b>] [<b>final</b>]<br>
&nbsp &nbsp <i>member-definition</i> &nbsp &nbsp &nbsp &nbsp<= <i>constructor-definition</i> | <i>method-definition</i> | <i>field-definition</i><br>
&nbsp &nbsp <i>full-member-definition</i> <= <i>access-modifiers</i> <i>member-definition</i><br>
  <p>
  Access modifiers can actually appear in any order; but for consistency,
    we show the standard ordering here.
  We will learn about more access modifiers later, and augument this EBNF rule.
  <p>
  Next we examine the details of the constructor and method definitions; they
    are very similar and share many EBNF rules.
  They also look a lot like the definitions of prototypes.
  <p>
&nbsp &nbsp <i>parameter</i> &nbsp<= <i>type</i> <i>identifier</i><br>

&nbsp &nbsp <i>parameters</i> <= ([<i>parameter</i>{,<i>parameter</i>}])<br>

&nbsp &nbsp <i>return-type</i> <= <i>type</i> | void<p>

  <p>
&nbsp &nbsp <i>constructor-definition</i> <= <i>identifier</i> <i>parameters</i><br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
  [<b>throws</b> <i>exception-types</i>] <br> 

&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      <i>block-statement</i><p>

&nbsp &nbsp <i>method-definition</i> &nbsp &nbsp &nbsp
      <= <i>return-type</i> <i>identifier</i> <i>parameters</i><br>
&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
 [<b>throws</b> <i>exception-types</i>] <br>

&nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp &nbsp
      <i>block-statement</i>
  <p>
  The only difference in last two EBNF rules is that a
    <i>method-definition</i> must specify a <i>return-type</i> (which can be
      <b>void</b>, meaning returns nothing),
   while the <i>constructor-definition</i>  cannot specify a
     <i>return-type</i>.
  In addition, as a syntax constraint, the <i>identifier</i> naming the
    constructor MUST have the SAME NAME as the class in which it is defined.
  <p>
  Notice that these definitions look a lot like prototypes
    (especially in regards to the <i>parameters</i> rule; the only difference
    is that the parameters here have names and types, not just types)
    and each is ended by a <i>block-statement</i> indicating how to
    execute its code (when we learn how to write classes, we will focus on
    the statements inside these blocks).
  <p>
  Finally, the EBNF rules for the third member, a field definition, looks just
    like a local variable definition.
  <p>
  &nbsp &nbsp <i>field-definition</i> <= <i>type</i> <i>identifier</i> [= <i>expression</i>];
</td>
</tbody>
</table>



<!-- Static Members -->

<a name="StaticMembers"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Static Classes: Methods and Fields</b></td>
<td width ="80%">
  Members declared with the <b>static</b> access modifier are very special.
  Such members are common in very simple classes, such as <b>Math</b> and
    <b>Prompt</b>, which define ALL their members to be <b>static</b>.
  They are much rarer in the more interesting classes that we will spend most
    of our time reading and writing this quarter.
  But, classes with <b>static</b> members are very important for writing even
    tiny programs, so we describe how to use <b>static</b> members first.
  <p>
  What is most special about <b>static</b> members is how we refer to them:
    the standard way is by its class name, followed by a period, followed by 
    the member's name.
  Thus, unlike all the <b>String</b> methods that we discussed, we do not
    construct objects from these classes and call methods on the objects!
  <p>
  So, for example, the <b>Math</b> class defines the the following members
    (among  many many others)
<b><pre>  public static double sqrt    (double a)    {...}
  public static int    max     (int a, int b){...}
  public static double random  ()            {...}

  public static final double PI = 3.14159265358979323846;</pre>
</b>
  Notice that all these members are <b>public</b>, so we can access/refer to
    them.
  They are also all <b>static</b>, so we will refer to these members as
    <b>Math.sqrt</b>, <b>Math.max</b>, <b>Math.random</b>, and <b>Math.PI</b>.
  (I have elided the blocks of the three methods: we are concerned here only
     with how to call these methods, not what code is executed when we do.)
  Furthermore, the <b>sqrt</b> method returns a <b>double</b>; it has one
    <b>double</b> parameter named <b>a</b>;
    the <b>max</b> method returns an <b>int</b>; it has two <b>int</b>
     parameter named <b>a</b> and <b>b</b>.
    the <b>random</b> method returns a <b>double</b>; it has no parameters.
  <p>
  From this point onward, we will use the term <b>parameter</b> to specify
    the variable names appearing inside the parentheses defining methods
    (sometimes we call them <b>parameter variables</b>).
  When we call such a method, we will now use the term <b>arguments</b> to
    describe the values that are transmitted to the method (we will still use
    the term <b>operand</b> when discussing operators).
  So, in the expression <b>Math.max(x,7)</b> we say that the arguments to
    the <b>Math.max</b> method are <b>x</b> and <b>7</b>.
  <p>  
  Note that when we call a method, Java first evaluates its arguments; then
    it transmits these values to the method by storing them into the method's
    parameters; this is how parameters are initialized.
  So, the number of arguments in a method call must match the number of
    parameters in one of its definition (there may be many definitions,
    because the method name may be overloaded).
  Typically the statements in the elided block refers to the values stored in
    the parameters, when performing its computation.
  <p>
  So, if we write the expression <b>Math.sqrt(25.)</b>, we are calling
    the <b>static sqrt</b> method in the <b>Math</b> class and passing
    it the argument <b>25.</b>; this value is stored in the parameter
    <b>a</b>; the method then computes and returns a result of <b>5.</b>
  <p>
  Likewise, if we have declared <b>int x = 5;</b> and write the expression
    <b>Math.max(x+4,7)</b> we are calling the <b>static max</b> method
    in the <b>Math</b> class and passing it the arguments <b>9</b> (the
    value of <b>x+4</b>) and <b>7</b>; these values are stored in the
    parameters <b>a</b> and <b>b</b> respectively; then, the method computes
    and returns a result of <b>9</b>.
  <p>
  Because the method <b>random</b> has no parameters, we must call it without
    any arguments; but, we still must include the parentheses.
  The code fragment below  prints 10 random numbers.
<b><pre>  for (int i=1; i&lt;=10; i++)
    System.out.println(Math.random());</pre></b>
  <p>
  Finally, we can use the field <b>Math.PI</b> in any statement, except one
    that attempts to change its value (recall that it is declared with a
    <b>final</b> access  modifier).
  Thus, for example, we can write <b>area = Math.PI*r*r</b> but not
    <b>Math.PI = 3.0;</b> (in the latter case, the Java compiler will detect
    and report an error).
  By convention, identifiers specifying <b>static</b> fields, like <b>PI</b>
    are completely capitalized, with different words separated by the
    underscore character; but this convention is not as widely followed as
    the others we have seen (for variable/method names and class names).
  <p>
  Likewise, the <b>Prompt</b> class appears in the course library (not
    standard Java library).
  It also defines all its members to be <b>static</b>; some are
<b><pre>
  public static int forInt (String message)                   {...}
  public static int forInt (String message, int low, int high){...}</pre>
</b>
  Notice that these definitions overload the method name <b>forInt</b>,
    but as required the two signatures (parameter structures) are different.
  We might use these methods as follows
<b><pre>
  int primeCheck = Prompt.forInt("Enter number to check for primality");
  int selection  = Prompt.forInt("Enter selection,1,10);</pre></b>
  <p>
  Java knows the first use of <b>forInt</b> refers to the first definiition,
    the one with a single <b>String</b> parameter, to match the single
    <b>String</b> argument in the parenthesis.
 Java knows the second use of <b>forInt</b> refers to the second definiition,
    the one with one <b>String</b> parameter followed by two <b>int</b>
    parameters, to match the one <b>String</b> argument followed by two
    <b>int</b>arguments in the parenthesis.
</td>
</tbody>
</table>




<!-- The DiceEnsemble Class -->

<a name="DieClass"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Reading the DiceEnsemble Class</b></td>
<td width ="80%">
  We are now ready to switch our attention back to the more common and
    interesting classes in Java: classes having constructors and whose
    methods are not <b>static</b>.
  When discussing these classes, we will carefully examine their <b>public</b>
    constructors and methods; but because their fields are all <b>private</b>, 
    we will not discuss these members in detail here (but we will, when we
    learn how to write our own classes and methods).
  <p>
  We will use the definition of members in the <b>DiceEnsemble</b> class as
    our primary example in this section.
  This class is a computer model of a collection of dice.
  The objects constructed from this class perform intuitively, but the class
    is complicated enough to illustrate most interesting aspects of classes.
  <p>
  There can be any number of dice in an ensemble, and the dice can have
     any number of sides; but in this model, all the dice must have the same
     number of sides.
  The model focuses on the operations of rolling the dice and reading the 
     number of pips showing (the number of dots on the top face of a die).
  These are the typical things we do with dice in the real world.
  We cannot ask for the weight of the dice, nor their color, nor a variety
    of other properties that physical dice exhibit.
  On the other hand, we can ask any dice ensemble object how often it has
    been thrown; that part of the model exceeds what we can do with physical
    dice.
  <p>
  First, let's overview the definitions of all thirteen members in this class.
  There are (in order) two constructors, eight methods (one mutator/command and
    seven accessors/queries), and three instance variables.
  Verify that each definition matches one of the EBNF rules presented above.
</td>
</tbody>
</table>

<b><pre>
  public DiceEnsemble () 
  {...}

  public DiceEnsemble (int numberOfDice, int sidesPerDie)
    throws IllegalArgumentException
  {...}

  public DiceEnsemble roll ()
  {...}

  public int getNumberOfDice ()
  {...}

  public int getSidesPerDie ()
  {...}

  public int getPips (int dieIndex)
    throws IllegalArgumentException,IllegalStateException
  {...}

  public int getPipSum ()
    throws IllegalStateException
  {...}

  public int getRollCount ()
  {...}

  public boolean allSame ()
   throws IllegalStateException
  {...}

  public String toString ()
  {...}
    
  private int   sidesPerDie;
  private int   rollCount;
  private int[] pips;</pre></b> 
  
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  Recall that the two constructors (the first two members) specify no
    <i>return-type</i> and are named by the class name, <b>DiceEnsemble</b>;
    because there are two definitions, the constructor for this class is
    overloaded.
  <p>
  The seven methods are named <b>roll</b>, <b>getNumberOfDice</b>,
    <b>getSidesPerDie</b>, <b>getPips</b>, <b>getPipSum</b>,
    <b>getRollCount</b>, and <b>toString</b> - a very specially named method.
  Accessor/query methods are often called "getters" and their names often start
    with <b>get</b>, as most of these do; they get information about the
    state of the object that is otherwise inaccessible (see the <b>private</b>
    fields below).
  <p>
  The three fields (<b>sidesPerDie</b>, <b>rollCount</b>, and <b>pips</b>) are
    all <b>private</b> instance variables; this means that each object stores
    its own state in these variables, but users of objects constructed from
    this class cannot access the values of these variables directly by their
    names.
  <p>
  Now, let's individually explore the constructors and methods in more detail.
</td>
</tbody>
</table>



<!-- Constructors -->

<a name="Constructors"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Using Constructors</b></td>
<td width ="80%">
  Recall from our discussion of <b>String</b> that we use the <b>new</b> 
   operator to construct new objects from a class.
  We can now say more precisely that what actually follows the <b>new</b>
    operator is a constructor for the class (which, as you recall, must have
    the same name as the class).
  The information inside its parentheses are the arguments that the constructor
    needs to initialize the state of the object.
  The number, order, and types of the argument(s) must match the number, order,
    and types of the parameter(s) of a constructor; each argument is evaluated
    and transmitted to its matching parameter in the constructor, where its
    value is used to initialize the state of the object.
  <p>
  The <b>DiceEnsemble</b> class has two constructors (so construction is
    overloaded).
  As required, they have different signatures: no parameters or two <b>int</b>
    parameters.  
  They appear as
<b><pre>
  public DiceEnsemble () 
  {...}

  public DiceEnsemble (int numberOfDice, int sidesPerDie)
    throws IllegalArgumentException
  {...}</pre></b>
  Generally, constructors are easy to locate when scanning the members of a
     class, because they have the same name as the class and have no return
     types.
  Pragmatically, constructor definitions typically appear first in a class
    (although in another popular style, fields appear first and constructors
    appear second).
  The first constructor, which has no parameters, is designed always to
    return a reference to an object representing an ensemble of two,
    six-sided dice.
  <p>
  The second constructor allows the programmer to specify the number and
    sides of the dice.
  It will fail to construct an object (and instead throw
    <b>IllegalArgumentException</b>), if it is given bad arguments for either
    its <b>numberOfDice</b> or <b>sidesPerDie</b> parameter.
  (We discuss the details later, but it certainly wouldn't make sense to have
    <b>-2</b> dice in an ensemble).
  <p>
  The following examples illustrate a few different ways to construct
    <b>DiceEnsemble</b> objects.
  In each case, the signature of one of the constructors is followed: no
    parameters or two <b>int</b> parameters.  
<b><pre>  DiceEnsemble d1 = new DiceEnsemble(2,6);    //2 dice, each 6-sided
  DiceEnsemble d2 = new DiceEnsemble();       //Same as above; see Javadoc
  DiceEnsemble d3 = new DiceEnsemble(1,4096); //1 die with 4096 sides!
  DiceEnsemble d4 = new DiceEnsemble(10,2);   //10 dice, each 2-sided</pre></b>
  After construction, each <b>DiceEnsemble</b> variable stores a reference
    to a different object whose state has been initialized by the constructor.
  For example, here is a picture for variable <b>d1</b> and the object that it
    refers to.
</td>
</tbody>
</table>
  <img src="images/diceobject.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  In this picture we show the <b>private</b> instance variables for an object
    constructed from <b>DiceEnsemble</b>: <b>sidesPerDie</b>, <b>rollCount</b>,
    and <b>pips</b>.
  It is the purpose of the constructor to initialize these variables.
  We show such instance variables just like other variables: as a labelled
     box; so here there are three of them comprising the state of the object.
  <p>
  You can see that one constructor argument, the one stored in the parameter
    <b>sidesPerDie</b>, is stored directly in an instance variable with the
    same name.
  Another instance variable, <b>rollCount</b>, is always initialized to
    <b>0</b>.
  Finally, the last instance variable, <b>pips</b>, refers to an array of
    length two: it stores the number of pips on each die (shown as <b>0</b>
    here, because the dice have not been rolled yet).
  What determines the size of that array? The argument transmitted to the
    <b>numberOfDice</b> parameter.
  We will cover the details of arrays soon, learning that they are just a
    special kind of object, with their own instance variables pictured above.
  <p>
  So, instance variables are just that: variables stored locally in each 
    instance of a class (i.e., in each object).
  While every object has the same instance variables, their values depend
    on which constructor was called and which arguments it was sent.
  To further illustrate this point, here is a picture for variable <b>d4</b>
    and the object it refers to.
</td>
</tbody>
</table>
  <img src="images/diceobject2.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  Notice that this object has exactly the same instance variables, but their
    values are different because the constructor was passed different
    arguments.
  This object represents a dice ensemble with ten, two-sided dice.
</td>
</tbody>
</table>


<!-- Methods -->

<a name="UsingMethods"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Using Methods</b></td>
<td width ="80%">
  Recall from our discussion of <b>String</b> that once we have constructed
    an object, and stored a reference to it in a variable, we can use the
    variable's name to make the object do some useful work for us by calling
    one or more of its methods.
  Let's examine what some individual methods do and finally put a bunch of
    method calls together, with some control structures, to perform some
    interesting task.
  It might seem surprising, but most of the methods that we discuss are
    parameterless; actually, this happens more often than not in
    object-oriented programming.
  <p>
  First, the following methods are simple accessors/queries.
<b><pre>
  public int getNumberOfDice ()
  {...}

  public int getSidesPerDie ()
  {...}</pre></b>
  Each returns some never-changing part of the state of the object: the number
    of dice in the ensemble and the number of sides on each die in the
    ensemble.
  Calling <b>d4.getNumberOfDice()</b> returns a result of <b>10</b>;
    calling <b>d4.getSidesPerDie()</b> returns a result of <b>2</b>.
  Thus, we can always query a <b>DiceEnsemble</b> object for this information.
  <p>
  For any of the other methods to make sense, we must first examine the
    <b>roll</b> method.
  I could have made the return type of this method <b>void</b> (and sometimes
    I wish I had).
  In the discussion below, I will assume that <b>void</b> is in fact its return
    type, but I will tell to the truth about this method at the end of this
    section (when we use the return type for casecaded method calls).
  <p>
  The <b>roll</b> method has the following definition (pretend).
<b><pre>
  public void roll ()
  {...}</pre></b>
  Because its return type is <b>void</b> (keep pretending), we can guess that
    this method is a mutator/command: it returns no result, but instead changes
    the state of an object.
  So how does this class model rolling a dice ensemble: first it increments
    <b>rollCount</b> and then it generates random numbers and uses them to
    change the values in the <b>pips</b> array to correspond to the number of
    pips showing on each die.
  For example, if we called <b>d1.roll();</b> the state of the object might
    be changed (refer to the picture above for the "before" picture) to one
    where the dice show <b>5</b> and <b>3</b> as pips.
</td>
</tbody>
</table>
  <img src="images/diceobjectrolled.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
  The following methods are also accessors/queries.
  But they return information based on the state of
    a <b>DiceEnsemble</b> object that <b>roll</b> can change:
    the <b>rollCount</b> and <b>pips</b> instance variables.
<b><pre>  public int getRollCount ()
  {...}

  public int getPipSum ()
    throws IllegalStateException
  {...}

  public boolean allSame ()
   throws IllegalStateException
  {...}

  public int getPips (int dieIndex)
    throws IllegalArgumentException,IllegalStateException
  {...}</pre></b>
  The first method just returns the current value stored in the
    <b>rollCount</b> instance variable.
  Recall that this instance variable is declared <b>private</b>.
  Thus, a programmer cannot access this variable directly; but, the
    <b>getRollCount</b> method, which a programmer can access because it
    is <b>public</b>, returns whatever value is stored there.
  So, the constructor initializes this instance variable to <b>0</b>;
    the <b>roll</b> method increments it; and the <b>getRollCount</b>
    method returns its current value.
  If we call <b>getRollCount</b> before calling <b>roll</b>, it would return
    <b>0</b>.
  <p>
  The next method is the accessor/query <b>getPipSum</b>.
  Generally, it returns the sum of the pips on all the dice.
  But, if we have not yet rolled the dice, this method cannot return
    a reasonable result, so it throws the <b>IllegalStateException</b>,
    indicating that the object is in a bad state for calling
    <b>getPipSum</b>.
  <p>
  The <b>allSame</b> method works similarly.
  Generally, it returns whether or not (a <b>boolean</b>) all the pips show
    the same value (for two dice, this means we rolled a double).
  But, if we have not yet rolled the dice, this method cannot return
    a reasonable result either, so it also throws the same
    <b>IllegalStateException</b>, indicating that the object is in a bad state
    for calling <b>allSame</b>
  <p>
  The <b>getPips</b> accessor/query method is a bit more interesting, because
    it defines a parameter.
  This class numbers the dice from one up to the number of dice in the
     ensemble; this method allows a programmer to specify the index of the
     die he/she is interested in, and it returns the number of pips on that
     die.
  Once again, if we have not yet rolled the dice, this method cannot return
    a reasonable result either, so it also throws the same
    <b>IllegalStateException</b>.
  <p>
  But, we might also specify a bad <b>dieIndex</b>: a number smaller than one
    or greater than the number of dice in the ensemble; in either case,
    this method cannot return a reasonable result; in this case it is not
    the state of the object that is bad, but the value of the argument, so
    this method instead throws the <b>IllegalArgumentException</b>.
  Note that if we were using a <b>try-catch</b> statement, we might be able
    to recover from this exception by calling <b>getPips</b> again, but with
    a different argument for <b>dieIndex</b>.
  But, we cannot recover from the <b>IllegalStateException</b> by doing so:
    in this case we would have to call <b>roll</b> before doing anything else.
  Thus, having different exceptions for different problems seems reasonable.
  <p> 
  Finally, every class should have a parameterless <b>toString</b> method that
    returns a <b>String</b> representing the state of an object.
  We use this method  mostly for debugging purposes: for printing the state
    of objects while our program executes.
  If, after rolling the <b>d1</b>, we called
    <b><pre>  System.out.println("d1 = " + d1.toString());</pre></b>
   Java would print (based on the state shown in the picture above)
    <b><pre>  d1 = DiceEnsemble[sidesPerDie=6,rollCount=1,pips=[5,3]]</pre></b>
   Many <b>toString</b> methods return their result in a standard form, as
    this one does:  the class name of the object, followed by a backeted list
    of all its instance variables and their values, separated by commas.
  What is truly special about this method is that Java calls it, implicitly,
    if it ever needs to convert an object into a <b>String</b>.
  So, we can instead write just
    <b><pre>  System.out.println("d1  " + d1);</pre></b>
    and Java would still print the same thing: it will implicitly call
    <b>toString</b> on <b>d1</b> to convert it into its <b>String</b>
    representation, so that it can apply the catenate operator.
  <p>
  Now let's write some more complicated and interesting code using combinations
    of these methods.
  First, <b>getPipSum</b> is a very useful method, but we can compute its
    value with our own code, using other available methods
   (here, we do so for the object that <b>d1</b> refers to):
<b><pre>  int pipSum = 0;
  for (int i=1; i&lt;=d1.getNumberOfDice(); i++)
    pipSum += d1.getPips(i);</pre></b>
  For a final example, we can use the following code fragment to roll and
    print a sequence of dice rolls; the code prompts the user to enter the
      number of rolls to perform.
<b><pre>  DiceEnsemble dice        = new DiceEnsemble(2,6);
  int          timesToRoll = Prompt.forInt("Enter # of times to roll dice");
  for (;;) {
    dice.roll();
    if (dice.getRollCount() > timesToRoll)
      break;
    System.out.print(dice.getPipSum() + " ");  //put in a space separator
  }</pre></b>
  <p>
  If we wanted to, we could have prompted the user for the number of dice and
    and the number of sides per die too, and used these values when
    constructing the dice ensemble.
  OK, time to tell the truth abot <b>roll</b>.
  The <b>roll</b> method actually does not return <b>void</b>, but instead
    returns a reference to a <b>DiceEnsemble</b> object; in fact, it return
    a reference to the exact same <b>DiceEnsemble</b> object that it is called
    on (although the state of that object has been changed by <b>roll</b>
    before it returns its reference).
  This method now is a bit of a hybrid: it is a mutator/command, but it also
    returns a result just like an accessor/query.
  <p>
  How does this change affect what we have said?
  First, all the above code is perfectly legal.
  We can still write a <b>d1.roll()</b> as a legal expression statement; we
    just elect not to do anything with the reference tht this method returns.
  It still satisfies all the syntax constraints of an expression statement.
  <p>
  But, now we can do something that we couldn't do with a <b>void</b> method:
    we can cascade method calls.
  For example, we can replace the last two statements in the loop above with
    the single statement <b>System.out.print(dice.roll().getPipSum());</b>
  Here we call the <b>roll</b> method on the object to which <b>dice</b>
    refers; this method changes the state of that object and then returns as a
    result a reference to THE SAME OBJECT; this reference is immediately used 
    to call the <b>getPipSum</b> method on the new state of that object.
  <p>
  Generally, we can always take a <b>void</b> method and make it return a
    reference to the object that it was called on.
  Doing so will allow cascaded method calls, which might make our code easier
    to write.
  In fact, now we can rewrite this code fragment equivalently as:
<b><pre>  DiceEnsemble dice        = new DiceEnsemble(2,6);
  int          timesToRoll = Prompt.forInt("Enter # of times to roll dice");
  for (;;) {
    if (dice.roll().getRollCount() > timesToRoll)
      break;
    System.out.print(dice..getPipSum() + " ");  //put in a space separator
  }</pre></b>
or even using a <b>for</b> loop.
<b><pre>  DiceEnsemble dice = new DiceEnsemble(2,6);
  for (int timesToRoll = Prompt.forInt("Enter # of times to roll dice");
       dice.roll().getRollCount() <= timesToRoll;
       /*see continuation test for state change*/)
    System.out.print(dice.getPipSum());</pre></b>
  Is this a good or bad thing?
  <p>
  Let's examine the semantics of a local reference variable declared
    <b>final</b>.
  Recall that a local primitive variable decalared <b>final</b> must be
    initialized and cannot have its value changed.
  This rule is exactly the same one for reference variables, but because they
    store state (references that refers to objects that have state), we must
    look at it a bit more closely.
  <p>
  Using <b>final</b> with a reference type variable DOES mean that once we
    initialize it, it always refers to the same object
  It DOES NOT mean that the state of the object remains unchanged: we can still
     call mutator/command methods on a <b>final</b> variable, changing not its
     state but the the state of the object it refers to. 
  So, if we declare <b>final DiceEnsemble d = new DiceEnsemble(2,6);</b> we
     CAN write <b>d.roll();</b>, but we CANNOT write
     <b>d = new DiceEnsemble(1,6);</b> which attempts to change the reference
     stored in the <b>final</b> variabls <b>d</b>).
   Again, the difference between what is stored in a variable (a reference)
     and what is stored in the object it refers to (the object's state) is
     crucial to understanding this distinction.
  <p>
  Finally, if a variable stores <b>null</b>, it refers to no object.
  So calling a method on that variable cannot ever work correctly: when Java
     uses the variable to find the object it refers to (so that it can call the
     method using the state of that object), it fails to find any object at
     all, so it automatically throws a <b>NullPointerException</b>; it should
     really be called a null "reference" exception, because we don't use the
     word "pointer" in Java; that is a C/C++ word.
</td>
</tbody>
</table>



<!-- Fields -->

<a name="UsingFields">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Fields</b></td>
<td width ="80%">
  Because most fields are instance variables, and most instance variables are
    defined to be <b>private</b>, we do not really need to know anything about
    them to understand how to use a class: only the person writing the class
    can use its <b>private</b> members.
  Later, when we learn how to write our own classes, we will investigate and
    manipulate such <b>private</b> fields thoroughly.
  <p>
  If we did declare a field to be <b>public</b> (and programmers rarely do;
    and if they do, they are most likely to declare it <b>final</b> as
    well), say <b>public int sidesPerDie;</b>, and if variable <b>d</b>
    referred to a <b>DiceEnsemble</b> object, then we could write
    <b>System.out.println(d.sidesPerDie);</b> to access the value of that
      member (not too bad) or <b>d.sidesPerDie = -2;</b> to store into that
      member (terrible; it will stop all the other methods from working).
  Thus, by the class-writer declaring this instance variable to be 
    <b>private</b>, he/she has guaranteed that instances of the class cannot
    be corrupted by incompetent or malicious programmers.
  <p>
  When <b>private</b> instance variables were first introduced in programming
    languages (the early 1970s), there was a big debate as to whether they
    were good or bad.
  Many famous computer scientists argued about the advantages and disadvantage
    of hiding information from programmers.
  It was a hot topic.
  But now, in the 21st century, there is almost complete agreement that
    information hiding is good, and that features like <b>private</b> instance
    variables should be used whenever possible.
  We will return to this discussion when we learn how to write classes.
  At that point, we will learn more formally how <b>private</b> instance
    variables help programmers who write classes ensure that all objects obey
    certain class invariants, no matter how the objects are used by other
    programmers.
</td>
</tbody>
</table>


<!-- OOP -->

<a name="OOP">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>OOP Summary</b></td>
<td width ="80%">
  So, what is object-oriented programming (OOP) about?
  Much of it concerns finding useful classes for the problems that we need to
    solve, constructing objects from these classes, and calling methods on
    these objects to help solve our problems.
  We have certainly discussed a large number of technical terms that help
    us talk precisely about what we are doing -but the code that we actually
    have to write in our programs is quite simple.
  <p>
  Let's return to our analogy one last time.
  A class is like a blueprint; the <b>new</b> operator is like a skilled
    worker who can read any blueprints and construct objects from them.
  Because objects don't themselves have names, we store references to
    objects in variables names.
  Sometimes a program constructs just one object from a class; sometimes more
     than one.
  Each constructed object is similar to the others from its class: each has
    the same instance variables (locations to store state), and each can be
    used to call the same methods.
  We use the arguments to a constructor to initialize the state of an object
    once it is built.
  Depending on which methods we call, the values of the instance variables
     might change.
  <p>
  A common mistake for beginners is to confuse the name of a class with the
    name of a variable that refers to an object constructed from that class.
  What really makes the problem insidious, is this second form is exactly 
    what we use when calling <b>static</b> methods!
  So, for example, writing <b>DiceEnsemble.roll();</b> is meaningless:
    <b>DiceEnsemble</b> is the name of a class, not the name of a variable that
     refers to an object constructed from that class; <b>roll</b> is the
     name of a method, but it is not a <b>static</b> method.
  If we declared <b>DiceEnsemble d = new DiceEnsemble(2,6);</b> then writing
    <b>d.roll();</b> is fine.
  And, writing <b>Math.max(3,7)</b> is fine too, because <b>max</b> is the
    name of a <b>static</b> method defined in the <b>Math</b> class.
  Learn to distinguish between these two confusing cases.
  <p>
  We can think of the period (<b>.</b>) as an operator: the member selector
    operator.
  Each period is prefixed by the name of a class (or a reference to an object
    constructed from that class) and suffixed by the member name selected from
    the relevant class.
  In fact, we can augment our precedence table with this operator (level 15)
    and the <b>new</b> operator (level 13); for completeness, I have also
    included <b>?</b> and <b>:</b> (the operators for
    <b>conditional expression</b> when used in combination, which have very
    low precedence, at level 2).
  <p>
  <table cellspacing="0" cellpadding="5" border="1" rules="all">
  <thead>
  <tr align="left">
  <th>Operator</th><th>Name</th><th>Precedence</th><th>Associativity</th>
  </thead>
  <tbody>
  <tr align="left"><td><pre><b>.<br>++ --</b></pre></td><td>member selector<br>postfix increment/decrement</td><td>15</td><td>left<br>none: all unary</td>
  <tr align="left"><td><pre><b>+ - ! ++ --</b></pre></td><td>unary plus/minus/negate<br>prefix increment/decrement</td><td>14</td><td>none: all unary</td>
  <tr align="left"><td><pre><b>new<br>(type)</b>expression</pre></td><td>constructor operator<br>casting (see below)</td><td>13</td><td>left</td>
  <tr align="left"><td><pre><b>* / %</b></pre></td><td>multiply divide remainder</td><td>12</td><td>left</td>
  <tr align="left"><td><pre><b>+ -</b></pre></td><td>add, subtract</td><td>11</td><td>left</td>
  <tr align="left"><td><pre><b>< <= > >=</b><pre><b>instanceof</b></pre></td><td>inequality relational</td><td>9</td><td>left</td>
  <tr align="left"><td><pre><b>== !=</b></pre></td><td>equality relational</td><td>8</td><td>left</td>
  <tr align="left"><td><pre><b>&&</b></pre></td><td>logical and</td><td>4</td><td>left</td>
  <tr align="left"><td><pre><b>||</b></pre></td><td>logical or</td><td>3</td><td>left</td>
  <tr align="left"><td><pre><b>?:</b></pre></td><td>conditional expression</td><td>2</td><td>none</td>
  <tr align="left"><td><pre><b>= += -= *= /= %=</b></pre></td><td>state change</td><td>1</td><td>right</td>
  </td>
  </tbody>
  </table>
<p>
Note that in the cascaded call <b>dice.roll().getRollCount();</b>
  first <b>roll</b> is called on <b>dice</b>, and then <b>getRollCount</b>
  is called on the result that <b>roll</b> returns (a reference to 
  <b>dice</b> with its state updated).
This is because period (<b>.</b>) is left associative.
</td>
</tbody>
</table>



<!-- Importing Packages -->

<a name="ImportingPackages"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Importing Classes from Packages</b></td>
<td width ="80%">
  Large software systems, like the standard Java library, comprise thousands
    of different classes.
  Programmers often need some way to organize these classes, and Java
    provides a <b>package</b> mechanism for this purpose.
  In this section we will learn how to access classes that declared in
    packages.
  First, we have the following EBNF rule that describes package names.
  <p>
  &nbsp &nbsp <i>package-name</i> <= <i>identifier</i>{.<i>identifier</i>}
  <p>
  For example, <b>java.lang</b> is one important package name for anyone
    using Java; <b>edu.uci.ics.pattis.introlib</b> is an important package
    name for anyone IN THIS COURSE using Java (that is the package in which
    the <b>Prompt</b> class is declared).
  Package names must be unique; one way to guarantee uniqueness is by using a
    variant of an internet address (pattis@ics.uci.edu) which are guaranteed 
    (by the people runing the internet) to be unique.
  <p>
  The Javadoc for a class tells us in which package it is declared.
  We can always use the <b>full name</b> of a class, prefacing the class name
    with its package name.
  Thus, we could refer to the <b>BigInteger</b> class by
    <b>java.math.BigInteger</b> and the <b>Prompt</b> class by
    <b>edu.uci.ics.pattis.introlib.Prompt</b>; OK, it is pretty obvious we need
    a shortcut.
  <p>
  To be able to write a class name by itself, we must import it with an
    <i>import-declaration</i>, whose EBNF rule appears below (<b>import</b>
    is a keyword).
  Once a class is imported, we can use the class name by itself, without
    its package name as a prefix.
  <p>
  &nbsp &nbsp <i>import-declaration</i> <= <b>import</b> <i>package-name</i>.*; &nbsp | &nbsp <b>import</b> <i>package-name</i>.<i>identifier</i>;
  <p>
  The first alternative imports ALL classes declared in a package; the second
    imports just the single class in that package named by <i>identifier</i>.
  I prefer writing the pair of imports
  <pre><b>  import edu.uci.ics.pattis.introlib.Prompt;
  import edu.uci.ics.pattis.introlib.DiceEnsemble;</b></pre>
  instead of the shorter and equivalent
  <pre><b>  import edu.uci.ics.pattis.introlib.*;</b></pre>
  because it explicitly identifies the names of all the classes that I am using
    from a package.
  By commenting-out one of these imports, the compiler will generate errors in
    every statement where that class is used (it is sometimes very useful to
    know all the places in your code where a class is used).
  <p>
  Here is another interesting facet of package and class names.
  The standard Java library declares a class named <b>Timer</b> in its
    <b>java.util</b> package.
  Without knowing about this class, I wrote a <b>Timer</b> class in my  
    <b>edu.uci.ics.pattis.introlib</b> package, which does something very
    different.
  If I want to use only one of these classes, in a program, I just import it.
  But if I want to use both, I cannot import both: the compiler will detect
    and report an error if I try to import the same class name from two
    different packages.
  What I can do is import one class (say, the one I use most often)
    and then just refer to the other class by its full name.
  So long as package names are different, even if class names are the same,
    there is a way to specify to Java exactly what we want to do (although
    it might be a bit verbose).
  <p>
  Note that both the <b>Math</b> and <b>String</b> classes are declared in the
    <b>java.lang</b> package.
  What makes this package so special, is that we never have to import its
    classes explicitly; they are automatically available.
  It is as if every program implicitly contains <b>import java.lang.*;</b>
</tbody>
</table>


<!-- JavaDoc -->

<a name="JavaDoc">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>JavaDoc</b></td>
<td width ="80%">
  One of the foremost reasons that I like teaching Java is Javadoc.
  Javadoc is a system for documentation that was developed at the same
    time as Java; it is included with the standard Java distribution.
  The thousands of classes in the standard Java library are all documented
    using Javadoc.
  In this lecture we learn about Javadoc as consumers: how to read the output
    of Javadoc, so that we can learn how to explore and use prewritten classes.
  In a later lecture we will learn more about Javadoc, as producers: how to
    write the input to Javadoc, so that we can document the classes that we
    write.
  <p>
  Java was one of the first languages developed after the popularization of
    web browsers.
  In a dramatic departure from the past, where there were few documentation
    systems -much less official ones- for languages, Java and Javadoc were
    developed together synergistically.
  The Javadoc system takes as input annotated (with special comments, tags,
    and links) Java classes and produces easy-to-read web pages documenting
    them.
  Their format, always the same, is designed to include a tremendous amount
    of useful information about each class and all its members.
  Javadoc also automatically highlights and cross-indexes information about
    the use and meaning of each member available in a class.
  <p>
  In this section, we will discuss most aspects of browsing Javadoc, using the
    the <b>Math</b> and <b>DiceEnsemble</b> classes as examples.
  To start, let's examine the web page that first appears for the
    <a href="http://java.sun.com/javase/6/docs/api/" target="_blank">
    Javadoc of Sun's API</a>.
  It will be useful for you to click this link now, so you can follow
    (dynamically on the web) along with the static screen-shots presented in
    this document
   (if you are like me, you are going to try to click them and get really
     frustrated:).
  You should see the following.
</td>
</tbody>
</table>
  <img src="images/standard.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
Use the small upper-left hand (Package) pane for selecting from which package
  you want to see the classes: it determines what information is displayed in
  the narrow lower-left hand (Class) pane, which is a list -in alphabetical
  order- of all the classes in the selected package.
Initially, the package pane has <b>All Classes</b> selected, which appears at
  its top, selected.
You can try clicking other packages (e.g., <b>java.awt</b>, <b>java.io</b>,
  <b>java.lang</b>, <b>java.util</b>, etc.), but
  before continuing, make sure <b>All Classes</b> is selected.
<p>
The big (Documentation) pane on the right initially overviews (see the word
  <b>Overview</b> highlighted in the header of this pane) information about
  the packages available; but, as we will soon see, it mostly is used to
  display the documentation for specific classes and interfaces.
To display the documentation for the <b>Math</b> class, scroll the
  class pane so that the <b>Math</b> link is visible, and then click it.
(another way to find this link is to click inside the lower left window,
  then type <b>control f</b> and then type in the <b>Find</b> window
  the word <b>Math</b> and then click <b>Next</b>).
You should see
</td>
</tbody>
</table>
  <img src="images/mathmain.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
Now the word <b>Class</b> is highighted in the header and the rest of this
  pane shows the documentation of the <b>Math</b> class.
Right under the header it shows in bold-face the package that this class comes 
  from (<b>java.lang</b>), followed by the word <b>Class</b> and the name of
  the class (<b>Class Math</b>) in a big bold-face font.
The information directly underneath is related to the class-hierarchy -
  the ancestors of this class is <b>java.lang.object</b>: when we learn about
  inheritance, we will study Javadoc again and return to this section for a
   more detailed study.
<p>
Directly underneath the line, Javadoc displays information that is used to
  define the basic features of a class.
When we learn about writing classes, interfaces, and inheritance, we will
  study Javadoc again and return to this section for a more detailed study.
This information is followed by an textual overview of the class.
<p>
Scroll down in the actual Javadoc window (the window on this web page is
  just a picture: you cannot scroll it) you will see the <b>Since</b>
  information, which identifies the release of Java when this class was added
   to the standard Java library.
<p>
The rest of this web page is divided into two major sections: <b>Summary</b>
  and <b>Detail</b>.
We will start by examining the summary information.
Scroll down on the documentation pane until you see
</td>
</tbody>
</table>
  <img src="images/mathsummaries.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
The summary section normally includes tables for fields, constructors, and
  methods.
But, because every member of this class is <b>static</b>, there is no need
  for a constructor, so that table is omitted.
These tables display information for all the <b>public</b> members defined in
   the class, and only the <b>public</b> members.
Note, you won't see the access modifier <b>public</b> appearing in any summary
  box on the left, because these boxes display only <b>public</b> members;
  if a member is declared <b>private</b>, it doesn't appear in these tables.
<p>
Let's start at the field summary.
First of all, these members always appear in alphabetical order.
Each field is described in a horizontally split box: it displays, on the
  left, some of its access modifiers (not all) and its type; on the right it
  displays its name and a one sentence description of the field.
<p>
Likewise for the method summary (which also appear in alphabetical order).
Each method is described in a horizontally split box: it displays, on the
  left, some of its access modifiers and its return type; on the right it
  displays its signature and a one sentence description of the method (the
  same one from the <b>Summary</b>.
As is the case with fields, each method name is hyperlinked to a more detailed
  description of that member that appears in the <b>Detail</b> section.
For now, scroll to the end of the <b>Summary</b> section until you see the
  following (or, alternatively, click the <b>E</b> in the field summary
  and scoll up a bit).
</td>
</tbody>
</table>
  <img src="images/mathinherited.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
This part of the page starts by displaying the summary of the <b>toDegrees</b>
  method, and the <b>ulp</b> method ends the <b>Summary</b> section.
Next it shows a small box headed by a hyperlink to the class that this one
  extends; its contents contain hyperlinks to all the methods in that class.
Again, when we learn about writing classes, interfaces, and inheritance, we
  will study Javadoc again and return to this section for a more detailed
  study.
<p>
Finally, the <b>Detail</b> sections start: first for fields, then for
  constructors (but there aren't any in this class), and finally for methods.
Each field's name is displayed in a big bold-face font, followed by all
  the fields's access modifiers and its name again, followed by a more
  detailed description of the field.
The description always starts with the one sentence appearing in the summary;
  because the fields in the <b>Math</b> class are so simple, there is no more
  detail in their descriptions.
Finally, at the bottom of this page, the <b>Detail</b> section for the
  methods start.
Scroll down again, until you see
</td>
</tbody>
</table>
  <img src="images/mathdetail.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
Each method is easily reachable via a hyperlink from its listing in the
  <b>Summary</b> section.
As you scroll down, you will notice that these methods DO NOT appear in 
  alphabetical order; instead they appear in the same order as the
  methods were defined in the <b>.java</b> file from which this Javadoc
  was created.
If a programmer clusters together related methods in the <b>.java</b> file,
  these methods will be clustered in the <b>Detail</b> section of Javadoc too;
   of course, if these methods appear in alphabetical order in the file, they
   will appear in alphabetical order here too: the programmer chooses
   (recall the <b>Summary</b> section always alphabetizes its members)
<p>
Each methods's name is displayed in a big bold-face font, followed by all
  the method's access modifiers and its signature, followed by a more
  detailed description of the method.
The description always starts with the one sentence that appears in the 
 summary, which acts as the "topic sentence" for the larger descritioon hear
After this description is a section of highlighted information including
  short descriptions of the method's <b>Parameters</b>, what exceptions it
  <b>Throws</b> (none here), and what value it <b>Returns</b>.
<p>
I encourage you to explore the web page for this class; you might also
  want to examine the web pages for the <b>StringTokenizer</b> and
  <b>BigInteger</b> classes, which we will discuss soon; both are defined
  and documented in the standard Java library.
Scroll to the top or bottom of the page and click the <b>Package</b>,
  <b>Tree</b>, <b>Index</b>, and <b>Help</b> links to see other
  interesting views of this library.
<p>
Next, lets examine web page that first appears for the 
    <a href="../../../common/classes/doc/index.html" target="_blank">
    Javadoc of Course API</a>.
Click this link and you should see the following.
</td>
</tbody>
</table>
  <img src="images/classlib.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
This page has a similar layout; it is simpler because it documents just
  one packages, comprising about a dozen classes.
Click the <b>DiceEnsemble</b> link and you should see.
</td>
</tbody>
</table>
  <img src="images/dicemain.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
Notice the standard features shown for all classes: their package name, the
  class name, and the prose description.
This class has no <b>public</b> fields, so the <b>Summary</b> section
  includes just constructor and method tables.
Examine the constructor summary: each entry includes its signature and a one
  sentence description.
Look further down to the methods table: recall that these appear
  in alphabetical order.
Now, click the hyperlink for the second, overloaded version of the
  <b>DiceEnsemble</b> constructor.
You should see
</td>
</tbody>
</table>
  <img src="images/dicedetail.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
Each constructor's name (they all have the same name!) is displayed in a big
  bold-face font, followed by all its access modifiers and its signature;
  notice how multiple parameters are displayed, and notice the
  <b>throws IllegalArgumentException</b> after the signature.
This is followed by a more detailed description of the constructor.
The description always starts with the one sentence appearing in the summary,
  but can be much longer.
After this description is a section of highlighted information including
  short descriptions of the constructor's <b>Parameters</b> and what
   exceptions it <b>Throws</b>.
<p>
I encourage you to explore the web page for this class and others.
If you want run a driver program for this class, and experiment
  calling its methods, download, unzip, and run the
  <a href="../../programs/dicedemo.zip">Dice Demo</a> project folder.
You might also want to examine the web pages for the <b>Prompt</b> class,
  which we have used extensively, and the <b>Timer</b> class, which we will
   discuss soon;; both are defined and documented in the course library.
Suppose you are interested in exactly what <b>IllegalArgumentException</b>
  is -it is another class is the standard Java Library; just click on its
   hyperlink (whoops, for some reason there isn't a hyperlink to it! I'll try
   to fix this, meanwhile look up <b>IllegalArgumentException<b> in the
   standard Java Library -the same way we located the <b>Math</b> class)
   and you should see
</td>
</tbody>
</table>
  <img src="images/iae.gif"></image>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%">&nbsp</td>
<td width ="80%">
Now you know that this is a class in the <b>java.lang</b> package (the one
  that every program automatically imports).
It has lots of ancestor classes.
There is some information about interfaces and subclasses (we will cover
  these later in the quarter).
At the bottom is the <b>Summary</b> section for constructors.
Note that many entries on this page are hyperlinked, so you can click
  them to get more information, exploring the Javadoc for the standard
  Java library further.
<p>
Well, that completes our first tour of Javadoc.
The ability to read Javadoc easily is one of those skills that is
  tough to acquire, but doing so will pay for itself many times
  over.
Whenever I am programming in Java, I always immediately open a 
  Javadoc browser to help me.
In subsequent sections we will discuss more Java classes.
Please examine their Javadoc while reading this material.
In addition, use Javadoc to check out the many features of the <b>String</b>
  class.
</td>
</tbody>
</table>



<!-- Programming By Contract -->

<a name="Contract">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Programming by Contract</b></td>
<td width ="80%">
  In this section we discuss the idea of preconditions and postconditions,
    and how they relate to constructors and methods.
  When we learn how to write classes, we will also discuss data invariants,
    which is a related topic.
  <p>
  We say that a constructor has a <b>precondition</b> if some properties
    must be true of its arguments.
  We say that a constructor has a <b>postcondition</b> if it guarantees
    that some property is true about the object's state after the object is
    constructed  (assuming that all its arguments satisfy their preconditions).
  <p>
  We say that a method has a <b>precondition</b> if some properties
    must be true of the object it is called on and its arguments.
  We say that a method has a <b>postcondition</b> if it guarantees
    that some property is true about the returned value and the object's
    states after the method returns (assuming that all its arguments satisfy
    their preconditions).
  <p>
  In <b>DiceEnsemble</b> constructor, there is a precondition that the
    arguments matching the <b>numberOfSides</b> and <b>sidesPerDie</b>
    parameters must be at least 1: it doesn't make sense for 0 or negative
    numbers to be transmitted to these parameters.
  The constructor checks these preconditions first: if it determines that
    either precondition fails, it cannot construct the required object;
    instead, it throws an <b>IllegalArgumentException</b>.
  <p>
  Likewise, the <b>getPips</b> method has a precondition that the dice have
    been rolled at least once, and the <b>dieIndex</b> parameter actually
    specifies one of the dice in the ensemble.
  If this method is called before the <b>roll</b> method is called, it throws
    an <b>IllegalStateException</b>: the state of the object is not correct for
    returning the values of any pips, if it has not been rolled yet.
  Likewise, if this method is called with an argument for <b>dieIndex</b> that
    is not in the correct range, it throws an <b>IllegalArgumentException</b>.
  <p>
  In the real world, for example, a microwave oven may beep at you (indicating
    an illegal operation in the current state) if you try to start it when the
    door is open. 
  <p>
  By understanding this form of stylized documentation, we can view every
     method as making a contract with the programmer: if the programmer calls
     the method on an object whose state satisfies the required
     preconditions, and with arguments that satisfy the required preconditions,
     then the method will work correctly, producing a result that satisfies its
     postcondition.
  If the object's state or argument values fail to satisfy their preconditions,
    the method will mostly likely discover this fact, and throw an exception,
    although in such cirumstances it is allowed to return a result that does
    not satisfy the postcondition.
  Certainly, it is better for a method to throw an exception when it knows it
    cannot satisfy its postcondition, than to return an incorrect answer
    (with no indication that it is incorrect).
  But in a contract, if the the preconditions aren't satisfied, anything
    is allowable.
  <p>
  If you gave a task to a person who couldn't perform it,would you rather have
    that person say, "I cannot do it," or instead botch the job?
  Likewise, would you rather someone answer a question with, "I don't know",
    or give you a wrong answer?
</td>
</tbody>
</table>


<!-- Other Useful Classes -->

<a name="OtherClasses">
<hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Other Useful Class</b></td>
<td width ="80%">
In this section we will examine a few other classes from both the standard
  Java library and the course library.
We focus on the standard OOP approach: constructing objects and then calling
  methods on them to perform interesting operations.
<p>
First, you should use Javadoc to examine the <b>Prompt</b> class in
  the course library and the <b>String</b> class in the standard
  Java library.
You are already familiar with these classes: the former has all <b>static</b>
  methods for prompting the user on the console screen, and the later
  has very many methods for operating on strings.
Note that the <b>String</b> class has no mutator/command methods; every
  method is an accessor/query.
Such a class is called <b>immutable</b>.
Once the state of an object is initialized by a constructor from an immutable
  class, it can never change.
But methods can return new objects whose state is based on old objects
  (e.g., the <b>toUpperCase</b> and <b>replace</b> methods).
<p>
While examining the <b>String</b> class, look at methods like <b>charAt</b>,
  <b>endsWith</b>, <b>indexOf</b>, <b>lstIndexOf</b>, <b>length</b>,
  <b>startsWith</b>, <b>subsequence</b>, <b>toLowerCase</b>,
  <b>toUpperCase</b>, <b>trim</b>
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>StringTokenizer</b></td>
<td width ="80%">
Now let's examine some interesting code that uses the <b>StringTokenizer</b>
  class, from the standard Java library (in the <b>java.util</b> package</b>).
This class has three constructors and six methods, although the most
  interesting and generally useful members are defined by
<b><pre>  public StringTokenizer(String str){...}

  public int     countTokens  ()                               {...}
  public boolean hasMoreTokens()                               {...}
  public String  nextToken    () throws NoSuchElementException {...}</pre></b>
Here is a typical example of how we can coordinate these to solve a 
  simple task: finding the average length of all the words in a sentence.
<b><pre>  String          sentence   = Prompt.forString("Enter sentence");
  StringTokenizer st         = new StringTokenizer(sentence);
  int             numTokens  = st.countTokens();
  int             numLetters = 0;
  while (st.hasMoreTokens())
    numLetters += st.nextToken().length();
  System.out.println("In the sentence: " + sentence + "\n" +
                     "Average word length = " + numLetters/numTokens);</pre></b>
For the input <b>To be or not to be</b>, the calculated output is <b>2</b>
 (thirteen letters in six words: <b>13/6</b>).
Notice that <b>sentence</b> is used only as an argument in the constructor to
  <b>StringTokenizer</b> and in the final output: it never changes its state.
It is <b>st</b> that is manipulated from that point onwards.
<p>
First, we use the <b>countTokens</b> methods to count and store the number of
  tokens initially in <b>st</b>: here, whitespace separates tokens
  (it DOES NOT use the technical definition of Java tokens).
Then a loop continues so long as <b>st</b> still has more tokens to process;
  if so, the next token is taken out of <b>st</b> by calling <b>nextToken</b>
  (a mutator/command that also returns a copy of the <b>String</b> token that
  it extracts); then a cascaded call to <b>length</b> on the returned
  <b>String</b> returns an <b>int</b> that is accumulated in <b>numLetters</b>.
<p>
Eventually, there will be no more tokens remaining in <b>st</b>, so the
  loop terminates and the result is calculated and printed.
Note that if we call <b>st.countTokens()</b> after the loop terminates, it will
  return <b>0</b>, because this method returns the number of tokens that
  ARE STILL in <b>st</b>; at the end, no tokens remain.
<p>
Note that  if we ever try to call <b>nextToken</b> when <b>hasMoreTokens</b>
  returns <b>false</b> (or equivalently, <b>countTokens</b> returns <b>0</b>),
  this method throws <b>NoSuchElementException</b>: there is no next value
  to return.
We can use this behavior, along with our knowledge of <b>try-catch</b>, to
  write an equivalent loop to process all the tokens and then terminate.
<b><pre>  String          sentence   = Prompt.forString("Enter sentence");
  StringTokenizer st         = new StringTokenizer(sentence);
  int             numTokens  = st.countTokens();
  int             numLetters = 0;
  for (;;)
    try {
      numLetters += st.nextToken().length();
    }
    catch (NoSuchElementException nsee){break;}
  System.out.println("In the sentence: " + sentence + "\n" +
                     "Average word length = " + numLetters/numTokens);</pre></b>
Generally, programmers would prefer the former code, which explicitly
  checks for <b>hasMoreTokens</b>, but you should certainly understand
  the <b>for</b>/<b>try-catch</b> code above.
<p>
Finally, examine the following code closely, which is supposed to accomplish
  the same task as above.
<b>IT DOES NOT WORK CORRECTLY</b> and it is important for you to determine why
  by hand simulting the code.
<b><pre>  String          sentence   = Prompt.forString("Enter sentence");
  StringTokenizer st         = new StringTokenizer(sentence);
  int             numTokens  = st.countTokens();
  int             numLetters = 0;
  for (int i=0; i&lt;st.countTokens(); i++)
    numLetters += st.nextToken().length();
  System.out.println("In the sentence: " + sentence + "\n" +
                     "Average word length = " + numLetters/numTokens);</pre></b>
Hand simulate this code (slowsly and carefully) on a <b>String</b> with five or
  six tokens in it and be ready to answer a question about this code in class.
<p>
When using a <b>StringTokenizer</b> prefer a loop calling <b>hasMoreTokens</b>
  explcitly (to check whether your code should be callling <b>nextToken</b>
  and not "obvious" -but often wrong- counting code).
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Timer</b></td>
<td width ="80%">
Now let's examine some interesting code that uses the <b>Timer</b>
  class, from my course library.
This class allows us to use its objects like stopwatches, to time various
  parts of code.
It has one parameterless constructor and four methods (besides
  <b>toString</b>)
<b><pre>  public Timer(){...}

  public void   start()      {...}
  public void   stop()       {...}
  public void   reset()      {...}
  public double getElapsed() {...}</pre></b>
See Javadoc for a detailed explanation of what these members do.
Here is a typical example of how we can coordinate these to solve a 
  simple task: finding the the time it takes for the user to enter an
  answer to a question.
<b><pre>  Timer answerTimer = new Timer();
  answerTimer.start();
  Prompt.forString("What is big and red and eats rocks?");
  answerTimer.stop();
  System.out.println("Time = " + answerTimer.getElapsed() + " seconds");</pre></b>
It actually doesn't matter whether the user gets the right or wrong answer
  to the question: the returned <b>String</b> is not checked; all we are
  interested in here is the time it took to answer this question.
<p>
All newly constructed timers have the same state: they are turned off, with 0
  elapsed seconds recorded.
When the <b>start</b> method, a mutator/command, is called the timer is turned
  on (just like a stopwatch).
When the <b>stop</b> method, also a mutator/command, is called the timer is
  turned off (ditto; note that both of these methods return <b>void</b>).
When the <b>getElapsed</b> method, an accessor/query, is called the timer
  returns the total number of seconds that elapsed while the timer was on; this
  value is is accurate to 1 millisecond.
We can call this method whether the <b>Timer</b> object is current turned on
  or off.
<p>
We can turn the timer on and then off as many times as we want; it accumulates
  time only when it is on (of course, we can call the <b>reset</b> method also,
  to reset the timer to its initial  state of being off and having zero elapsed
  seconds).
We can use objects from the <b>Timer</b> class to time any computer activity
  that takes at least 1 millisecond, such as how long it takes to execute
  some complicated loop in a program.
</td>
</tbody>
</table>
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>BigInteger</b></td>
<td width ="80%">
Finally, let's examine some interesting code that uses the <b>BigInteger</b>
  class, from the standard Java library (in the <b>java.math</b> package</b>).
This class allows us to compute with integers of an arbitrary size (not limited
  to the size of <b>int</b> values).
The operations on <b>BigInteger</b> objects are are all specified via method
  calls (not operators).
And the class, like <b>String</b> is immutable: all method calls do not change
  the state any existing objects, but they can produce new <b>BigInteger</b>
  objects whoses states are based on the state of the objects used to call the
   methods.
<p>
This class has three public fields (representing the <b>BigInteger</b>
  constants 1, 10, and 0), many constructors, and many many methods that
  act like operators on <b>int</b> values), although we need only the following
   members for our application below.
<b><pre>
  public static final BigInteger ONE = new BigInteger("1");

  public BigInteger(String val) throws NumberFormatException {...}

  public BigInteger multiply(BigInteger val){...}
  public String     toString()              {...}</pre></b>
<p>
Here is a typical example of how we can coordinate these to solve a 
  simple task: finding the factorial of a large <b>int</b> value; say
  something like <b>1000!</b> (which has tens of thousands of digits).
The following simple code works for inputs up to about 10, but after that 
  <b>result</b> gets too big to store as an <b>int</b>.
That's the bad news; but the good news is that we can take this code and
  easily generalize it for <b>BigInteger</b> results..
<b><pre>  int x      = Prompt.forInt("Enter x for x!");
  int answer = 1;
  for (int i=2; i<=x; i++)
    answer = answer * i;
  System.out.println(x+"! = " + answer);</pre></b>
Now, let's do the generalization.
The important thing to know about the main constructor for <b>BigInteger</b>
  is that it takes a <b>String</b> parameter that stores an optional plus or
  minus, followed by all the digits in the <b>BigInteger</b> we want; if it
  contains any other characters, this constructor throws the
  <b>NumberFormatException</b>.
So, we could write <b>new BigInteger("1000000000000")</b> to construct
  the <b>BigInteger</b> value one-trillion (which is not representable as
  an <b>int</b>; this is peanuts compared to the thousands of digits in
  <b>1000!</b>).
<p>
Hint, here is an important <b>idiom</b>: if <b>i</b> is declared to be an
   <b>int</b> and stores an <b>int</b> value, then the expression <b>""+i</b>
   stores a <b>String</b> representation of that <b>int</b>: <b>""+10</b> is
   <b>"10"</b>; so if we want to construct a <b>BigInteger</b> from an
   <b>int</b>, we use the constructor on the <b>int</b> catenated with the
   empty string.
<p>
Finally, the <b>multiply</b> method multiplies two <b>BigInteger</b>s
  producing a third, whose state is the product of the states of its
  arguments.
Note that we must call this method using object notation.
Remember the <b>.equals</b> method (which was like a binary operator)?
  <b>multiply</b> is simlar: called as <b>x.multiply(y)</b>.
<p>
Now, let's change our code to use <b>BigInteger</b>s only where needed: to
  accumulate the huge product.
<b><pre>
  int        x      = Prompt.forInt("Enter x for x!");
  BigInteger answer = BigInteger.ONE;
  for (int i=2; i<=x; i++)
    answer = answer.multiply(new BigInteger(""+i));
  System.out.println(x+"! = " + answer);</pre></b>
Notice that Java calls the <b>toString</b> method implicitly, when it needs to
  convert <b>answer</b> into a <b>String</b> for catenation in the final
  output.
It might be interesting to use a <b>Timer</b> to see how long this process
  takes for large values of <b>x</b>.
<p>
Briefly examine the Javadoc for <b>BigInteger</b>, it includes arithmetic
  operations as <b>methods</b> (e.g., <b>add</b>, <b>subtract</b>,
  <b>multiply</b>, <b>divide</b>, <b>remainder</b>) which parallel the
   arithmetic <b>operators</b> for <b>int</b> values.
Also briefly examine methods like <b>abs</b>, <b>max</b>, <b>min</b>,
  and <b>gcd</b>, which could be, but are NOT, static methods in <b>Math</b>
  class (the methods in the <b>Math</b> class operate on primitive types only).
<p>
Finally, examine the <b>compareTo</b> method which takes the place of all
  the different relational operators (recall the Law of Trichotomy, because
  what happens here is similar).
If we declare <b>BigInteger x,y;</b> and initialize these values, calling
  <b>x.compare(y)</b> returns an <b>int</b> with the following properties:
  the value is &lt; 0 if <b>x</b> is less than <b>y</b>;
  the value is = 0 if <b>x</b> is the same as <b>y</b>;
  the value is &gt; 0 if <b>x</b> is greater than <b>y</b>.
So, to check whether <b>x</b> is less than or equal to  <b>y</b>,
  we would write the boolean expression <b>x.compareTo(y) &lt;= 0</b>.
Note the arithmetic law: <b>x.compareTo(y) = -y.compareTo(x)</b>
Can you explain why it is true using the Law of Trichotomy.
<p>
Also, see the <b>compareTo</b> and <b>compareToIgnoreCase</b> methods in the
  <b>String</b> class: they also return an <b>int</b> value with the same
  semantics: comparing two <b>String</b>s according to their order in an
  alphabetized dictionary.
<p>
We have now learned members in about a half-dozen interesting class in Java,
  seeing how to construct objects and call methods on them to get interesting
  tasks done.
I hope that you have also examined the Javadoc for all these classes, so
  that you feel comfortable using this documentation system.
Feel free to cut/paste the code here into the <b>Application.java</b> 
  file of some project; remember, though, to add the correct <b>import</b>
  statements to your code.
<p>
You can also download, unzip, and run
<a href="../../programs/crapsstatistics.zip">Craps Statistics</a> (uses
  <b>DiceEnsemble</b> and <b>Timer</b>).
<!--- Turned into an assignment
 or
<a href="../../programs/collatzwithobjects.zip">Collatz Conjecture</a> (uses
  <b>BigInteger</b> and <b>Timer</b>) to examine programs that use these
  classes.
--->
Finally, you can download, unzip, and run
  <a href="../../programs/classexamples.zip">Class Examples</a> project folder,
  which has short snippets of code using a dozen different classes.
These examples show that it is easy to experiment with these (and other)
  classes in any Java libraries.
</td>
</tbody>
</table>


<!-- Java File I/O -->

<a name="RealFileIO"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Java File I/O</b></td>
<td width ="80%">
  There are dozens of classes that handle file I/O in Java; using various 
    combination of these classes, we can efficiently achieve many kinds of
    interesting  behavior: buffered vs. non-buffered;
    binary vs. text-files; sequential vs. random access; etc.
  I have written the <b>TypedBufferReader</b> and <b>TypedBufferWriter</b>
    classes (using classes in the standard Java library) to present a simple,
    easy to understand and use, interface to the concept of file processing.
  These classes are powerful enough for use in all the programs in this course.
  <p>
  After we are more familiar with reading/using classes (including
     inheritance), we will
    <ul>
      <li>overview the standard Java classes for file I/O
      <li>re-examine the code that implements the <b>TypedBufferReader</b> and 
            <b>TypedBufferWriter</b> classes.
    </ul>
  By the end of the course, you will have the skills needed to investigate
    fancier file I/O by yourself.
</td>
</tbody>
</table>



<!-- File Input Pattern -->

<a name="FileInputPattern"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Simple File Input Patterns</b></td>
<td width ="80%">
  Reading a sequence of values from a file (until there are no more) is a
    simple and useful operation.
  This section shows a standard file input pattern to accomplish this task,
    and applies it twice, without much variation, to files containing
    different kinds of information.
  <p>
  Note that the contructor for the <b>TypedBufferReader</b> class requires a
    <b>String</b>, but this <b>String</b> DOES NOT SPECIFY the name of the file
    to be read.
  Instead, it specifies how the user is to PROMPTED to enter a file name.
  In fact, the constructor will continually reprompt the user with this
    message until he/she enters a valid file name.
  Of course, this information -and more- is all in its Javadoc.
  I encourage you to browse the appropriate page while reading the rest of
    this lecture.
  <p>
  Once we construct a <b>TypedBufferReader</b> object, we call methods on
    it to attempt to read information from the file.
  Again we follow standard OOP practice: construct an object and call its
     methods to aid in performing some complicated task.
  <p>
  For a simple example, let us assume that we want to add together all the
    <b>int</b> values in a file.
  The relevant method in the <b>TypedBufferReader</b> class is
  <b><pre>  public int readInt() throws EOFException,NumberFormatException</pre></b>
  We can use the following code to process this file according to these
    specifications.
<pre><b>  TypedBufferReader inputFile = new TypedBufferReader("Enter file name ");
  int sum = 0;
  for (;;)
    try {
      int value = inputFile.readInt();  //or just the single line
      sum += value;                     //sum += inputFile.readInt();
    }
    catch (EOFException eofe) {break;}

  inputFile.close();
  System.out.println("Sum = " + sum);</b></pre>
  Notice that the <b>try-catch</b> is the single statement inside the
     <b>for</b> loop.
  This code works as follows:
  In each iteration, the first statement in the <b>try</b> block attempts to
    read an <b>int</b> from the file.
  If it is successful, that value is stored into <b>value</b> and then added
     to <b>sum</b>; the <b>try-catch</b> is finished, and the <b>for</b> loop
     executes it again.
  <p>
  But, if there are no more values in the file, the <b>readInt</b> method
    throws <b>EOFException</b>.
  Then, the <b>try</b> block is abandoned and the <b>catch</b> clause for this
    exception is found; its matching block contains a <b>break-statement</b>,
    which terminates the loop.
  Now the <b>for</b> loop is finished, so Java continues by executing the
    remaining statements after it: the first closes the file (that has had all
    its values read) and the second prints the answer.
  <p>
  Now, let's examine very similar code that solves a more complicated problem.
  Imagine that a file contains many lines, each of which contains a name,
    three scores, and boolean telling whether the name and average of the
    scores should be printed.
  Such a file might look like <pre><b>  Fred    20  23  19 true
  Barney  24  22  20 false
  Wilma   21  24  25 false
  Betty   23  19  22 true</b></pre>
  and when processed should print the following (note that only <b>Fred</b>
   and <b>Betty</b> specify that the average is to be printed)
 <pre><b>  Fred has average 20
  Betty has average 21
  4 values processed (some might not be printed)</b></pre>
  We can use the following code to process this file according to these
    specifications.
<pre><b>  TypedBufferReader inputFile = new TypedBufferReader("Enter file name");
  int count = 0;
  for (;;)
    try {
      String  name    = inputFile.readString();
      int     s1      = inputFile.readInt();
      int     s2      = inputFile.readInt();
      int     s3      = inputFile.readInt();
      boolean printIt = inputFile.readBoolean();
      count++;
      if (printIt)
        System.out.println(name + " has average " + (s1+s2+s3)/3); 
    } 
    catch (EOFException eofe) {break;}

  inputFile.close();
  System.out.println(count + " values processed (some might not be printed");</b></pre>
  Although this code has more complicated processing within the <b>try</b>
     block, it is essentially the same pattern that we used before: continue
     reading values until the <b>EOFException</b> is thrown, which breaks out
     of the reading loop.
</td>
</tbody>
</table>


<!-- File Output Pattern -->

<a name="FileOutputPattern"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>A Simple File Output Pattern</b></td>
<td width ="80%">
  In this section, we will combine the previous code with some more code that
    writes output  files.
  We construct a <b>TypedBufferWriter</b> object, which requires a
    <b>String</b> parameter specifying the name of a file.
  Note the difference in the use of the parameter for the constructor between
    this class and the <b>TypedBufferReader</b>.
  In the larger code fragment below, we could write
<pre><b>  TypedBufferWriter outputFile 
  = new TypedBufferWriter( Prompt.forString("Enter output file name") );</b></pre>
  to promput the user for the file name; but instead we automatically derive
    the output file name from the input file name.
  <p>
  Once we have a variable refering to this object, we can use all the
    <b>print</b> and <b>println</b> methods that we have used with
    <b>System.out</b>.
  Most important are the methods that print a <b>String</b>, because we
    frequently use this type as a by-product of catenating many values
    together.
<pre><b>  TypedBufferReader inputFile 
    = new TypedBufferReader("Enter name of file ");
  TypedBufferWriter outputFile 
    = new TypedBufferWriter(inputFile.getFileName()+".output"));
  int count = 0;
  for (;;)
    try {
      String  name    = inputFile.readString();
      int     s1      = inputFile.readInt();
      int     s2      = inputFile.readInt();
      int     s3      = inputFile.readInt();
      boolean printIt = inputFile.readBoolean();
      count++;
      if (printIt)
        outputFile.println(name + " has average " + (s1+s2+s3)/3); 
    } 
    catch (EOFException eofe) {break;}

  inputFile.close();
  outputFile.close();
  System.out.println(count + " values processed (see " + 
                     outputFile.getFileName() + " for contents");</b></pre>
  Here, the name of the output file is constructed automatically, by catenating
    together the name of the input file (retrieved through the
    <b>getFileName</b> accessor/query) and the <b>".output"</b> literal.
  Inside the loop, the information that was originally printed on
    <b>System.out</b> is now printed to the output file.
  Finally, like the input file, the output file is also closed after
    everything is written in it.
  Note too that the summary output still appears on the  user's console;
    if we wanted to, we could have also printed this information into the file.
  <p>
  IMPORTANT: if you do not close an output file, it may lose the last few
    lines sent to it.
  To be safe, always close any input and output files whenever you are done
    using them.
  This also stop further informtion from being read from/written to the file.
</td>
</tbody>
</table>



<!-- Error Detection  -->

<a name="ErrorDetection"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Error Detection in Input Files</b></td>
<td width ="80%">
  All the file reading code up to this point has assumed that files had the
     correct type of data in them.
  In this section and the next, we will begin to explore simple ideas in error
    detection and recovery when reading input files.
  We are just scratching the surface of this topic in this discussion; a more
    complete discussion is beyond the scope of this course.
  <p>
  If we call a method to read some type of information out of a file, but a
     value of that type is not there in the next position to be read, then the
     method throws a <b>NumberFormatException</b> (even if what we are
     trying to read is not a number, for uniformity).
  The simplest thing to do in this case is abandon reading the file and process
    whatever information has been already read correctly.
  The following code implements this goal.
<pre><b>  TypedBufferReader inputFile = new TypedBufferReader("Enter name of file ");
  int count = 0;
  for (;;)
    try {
      String  name    = inputFile.readString();
      int     s1      = inputFile.readInt();
      int     s2      = inputFile.readInt();
      int     s3      = inputFile.readInt();
      boolean printIt = inputFile.readBoolean();
      count++;
      if (printIt)
        System.out.println(name + " has average " + (s1+s2+s3)/3); 
    } 
    catch (EOFException eofe) {break;}
    catch (NumberFormatException noe) {
      System.out.println("  Error reading file " + inputFile.getFileName() +
                         " on line " + inputFile.getLineNumber() +
                         "; problem token: " + inputFile.getLastTokenUntyped());
      System.out.println("Processed all earlier file entries");
      break;
    }

  inputFile.close();
  System.out.println(count + " values processed");</b></pre>
  Here, the exception thrown by failure to read the correct type of
    information, <b>NumberFormatException</b> is caught; in this case, it
    prints an error message, but then executes a <b>break</b> and continues
    with the rest of the code following the loop (so only the earlier values
    are correctly processed).
</td>
</tbody>
</table>



<!-- Error Recovery  -->


<a name="ErrorRecovery"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Error Recovery in Input Files</b></td>
<td width ="80%">
  We can go one step further and not only detect the error, but try to recover
    from it.
  Recovery means ignoring the bad line of input and continuing to process
    those after it.
  The following code implements this goal.
<pre><b>  TypedBufferReader inputFile = new TypedBufferReader("Enter name of file ");
  int count = 0;
  for (;;)
    try {
      String  name    = inputFile.readString();
      int     s1      = inputFile.readInt();
      int     s2      = inputFile.readInt();
      int     s3      = inputFile.readInt();
      boolean printIt = inputFile.readBoolean();
      count++;
      if (printIt)
        System.out.println(name + " has average " + (s1+s2+s3)/3); 
    } 
    catch (EOFException eofe) {break;}
    catch (NumberFormatException nfe) {
      System.out.println("  Error reading file " + inputFile.getFileName() +
                         " on line " + inputFile.getLineNumber() +
                         "; problem token: " + inputFile.getLastTokenUntyped());
      inputFile.ignoreRestOfLine();
      System.out.println("  Ignoring this line");
    }

  inputFile.close();
  System.out.println(count + " values processed");</b></pre>
  Here, the exception thrown by failure to read the correct type of information
    is caught; in this case it prints an error message, but then does not
     execute a <b>break</b>; instead it calls a method that skips the rest of
     the information on the current line being read.
  So, the <b>for</b> loop  does not terminate, but continues reading and
    processing values from the next line: it terminates the loop only when the
    <b>EOFException</b> is thrown.
  <p>
  This code, and one file to test it on (you can edit the file to create your
    own tests) is available in 
    the <a href="../../programs/fileinput.zip">File Input</a> project folder.
  Note the declaration <b>import java.io.EOFException;</b>
  Unlike most of the other exceptions that we have seen
   (e.g., <b>NumberFormatException</b>, <b>IllegalArgumentException</b>,
    <b>IllegalStateException</b>) this exception is not in the <b>java.lang</b>
    package, from which classes are implicitly imported into every program.
  So, we must use it a bit differently;
  We could omit the import but write the exception handler as
  <pre><b>  catch (java.io.EOFException eofe) {break;}</b></pre>
  but this approach would soon lead to very verbose code; better to import
    this class explicitly.
  <p>
</td>
</tbody>
</table>


<!-- Buffering -->

<a name="Buffering"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Buffering</b></td>
<td width ="80%">
  In this section we will explore how the term <b>buffer</b> applies to file
    I/O.
  Typically a file that we are reading or writing (big or small) is stored on
    a hard disk.
  As a memory device, a hard disk has two key properties
  <ol>
    <li>It takes a large amount of time to read/write a small amount of
          information to a hard disk (when compared to accessing a 
          computer's memory).
    <li>It takes only a bit more time to read/write a large amount of
          information to a hard disk.
  </ol>
  That is, it takes an appreciable amount of time to find the place to get/put
    the information on the disk, but it can quickly get/put lots of information
     once this place has been found.
  <p>
  Let's examine the implications fo these properites when applied to output.
  We often write small amounts of information into a file repeatedly.
  If every time we write (even a small amount of) information to a file it
     goes immediately to the  hard disk, the process will go quite slowly.
  <p>
  Instead we can use a buffer.
  A buffer is a medium-sized block of memory that we use to collect output for
     a file; a typical buffer can contain thousands of characters.
  Then, instead of writing output directly into the file, it is more quickly
     put into the memory buffer.
  But typically not all the information going to the file can fit in such a
    buffer (typically we use a buffer smaller than the ultimate file size).
  When the buffer is full, the computer senses this fact and then writes all
    the information currently in the buffer into the output file; now that the
    buffer is empty, we can continue putting more information into it.
  <p>
  Using such a buffer minimizes the number of times information is written to
    a file; each time information is written, a large amount is written
    (which takes just a bit more time than writing a small amount; and
     much less time than repeatedly writing a small amount).
  Note also that such an output buffer might be partially filled when a
    program terminates: in this case the information is lost: it never makes
    it from the buffer to the output file.
  But, if the program executres the <b>close</b> method on an output file, it
    knows to force the remaining contents of the buffer to be written into the
    otuput file (which is why it is important to close all output files).
  <p>
  Likewise, when an input file is read, a large part of it is transferred to
    the memory buffer, where subsequent reading gets information, until all the
    information in the buffer is read.
  At this point, another large part of the file is transferred into the buffer
    from the file, for the next batches of reads.
</td>
</tbody>
</table>



<!-- Problem Set -->

<a name="ProblemSet"><hr align="left" width="33%">
<table cellspacing="0" cellpadding="5" border="0" rules="none" width="100%">
<tbody>
<tr valign="top">
<td width ="20%"><b>Problem Set</b></td>
<td width ="80%">
  To ensure that you understand all the material in this lecture, please solve
    the the announced problems after you read the lecture.
  <p>
  If you get stumped on any problem, go back and read the relevant part of the
     lecture.
  If you still have questions, please get help from the Instructor, a CA, a Tutor,
    or any other student.
  <ol>
     <li>Draw the picture resulting from the following declarations.
<pre><b>
  String s1 = new String("ABC");
  String s2 = new String("XYZ");
  String s3 = new String("abc");
  String s4 = s1;
  String s5 = new String("XYZ");
  s2 = new String("ABC");
</b></pre>
      <li>Give the resulting picture from problem 1, determine the result of the
            following tests:
              <b>s1==s1</b>, 
              <b>s1==s2</b>, 
              <b>s1==s4</b>, 
              <b>s1.equals(s4)</b>, 
              <b>s1.equals(s2)</b>, 
              <b>s1.equals(s3)</b>, 
              <b>s1.equalsIgnoreCase(s3)</b>, 
              <b>s1==s5</b>, and
              <b>s1.equals(s5)</b> 

      <p>
      <li>Describe what it means for two objects to be identical, such that <b>==</b> (the
           object identity operator) has a result of <b>true</b>.
          Explain what value is produced by writing: <b>(new String("abc")) == (new String("abc"))</b>
      <p>

     <li>We defined an EBNF rule for access modifiers as
     <p>
       <i>access-modifiers</i> <= [public|private] [static] [final]
     <p>
     How many different access modifiers (combinations of these words) are legal?
     <p>

     <li>Write the result that each code fragment below prints. Drawing pictures is invaluable.
<pre><b>  DiceEnsemble dice = new DiceEnsemble();
  dice.roll();                                    //or dice.roll().roll();
  dice.roll();
  System.out.println(dice.getRollCount());


  DiceEnsemble dice = new DiceEnsemble();
  dice.roll();
  dice = new DiceEnsemble();
  dice.roll();
  System.out.println(dice.getRollCount());


  DiceEnsemble dice1 = new DiceEnsemble();
  dice1.roll();
  DiceEnsemble dice2 = dice1;
  dice2.roll();
  System.out.println(dice1.getRollCount());</b></pre>
     <p>

     <li>What is wrong with each of the following code fragments? Will the compiler detect
           and report either error?
<pre><b>  DiceEnsemble dice;
  dice.roll();


  DiceEnsemble dice = null;
  dice.roll();</b></pre>
    <p>

    <li>
    Browse the Javadoc for the <b>BigInteger</b> class.
    Assume that we have declared <b>BigInteger x,y;</b>
      and initialized these variables to refer to appropriate objects.
      <ul>
        <li>Examine the <b>abs</b> method in this class.
            Assume <b>x</b> refers to a <b>BigInteger</b> with a negative
              value.
            If we write <b>x.abs()</b>, explain why <b>x</b> does not refer
              to a <b>BigInteger</b> with a positive value.
            Show how to accomplish this task.
            <p>
        <li>Examine the <b>min</b> method in this class.
            Show how to write a declaration for a third <b>BigInteger</b>
              named <b>z</b>, and how to initialize this variable to refer
              to an object that is the bigger of <b>x</b> and <b>y</b>.
            After <b>z</b> is initialized, does it share an object with
              either <b>x</b> or <b>y</b>?
            <p>
        <li>Examine the <b>compareTo</b> method in this class.
            Show how to write a <b>boolean</b> expression that evaluates to
              <b>true</b> if <b>x<=y</b>.
            Note that the relational operators do not work on any reference
              types.
      </ul>
    <p>

    <li>
      Extend the file-reading code above so that after reading each name, it processes any number of scores 
        for that student (the list of scores is ended by a sentinel of -1).
     This time, if any score is not an integer, just ignore it (don't increment the running count 
        or sum) but keep processing other scores.
     You will need nested control structures.

    <p>
    <li>What does the following code print when it reads a file containing: <b>1 2 3 x x 4 5 6</b>?
        Do this hand simulation carefully, paying close attention to the details of exception processing.
<pre><b>  for (;;)
    try {
      int a = inputFile.readInt();
      int b = inputFile.readInt();  
      System.out.print(a + "" + b);
    }catch (NumberFormatException nfe ) {System.out.print("B");}
     catch (EOFException          eofe) {System.out.print("E"); break;}
  System.out.println("D");</b></pre>

    <p>
    <li>
      Modify the error detection code so that it prints a special message if it discovers an end of file
        while trying to read any data but the <b>String</b> information (meaning that the last set of values 
        in the input file is not complete).
      <p>

    <li>
      Modify the error recovery code so that it will also terminate the loop (printing an appropriate
        message), if more than ten <b>NumberFormatException</b>s occur.
      <p>

    <li>
      Modify the error recovery code so that it will also terminate the loop (printing an appropriate
        message), if more than ten <b>NumberFormatException</b>s occur <b>in a row</b>; this means ten
        occur on ten consecutive lines in the file, without reading one line in the file correctly.
      <p>
<li>
Read the Javadoc for the <b>Random</b> class (in the standard Java library)
  and write a code fragment that prints 100 random numbers between <b>0</b>
  and <b>10</b> inclusive.
<p>
<li>
Read the Javadoc for the <b>ModularCounter</b> class (in the course Java
  library) and rewrite the following code fragment (which we we have
  studied before), declarations and all, which uses primitive types.
Describe why the just-written code fratment in simpler.
<b><pre>  int minute; //in the range [0,59] inclusive
  int hour;   //in the range [0..23] inclusive
  ...
  minute++;
  if (minute == 60} {
    minute = 0;
    hour++;
    emitBeeps(hour);
    if (hour == 24)
      hour = 0;
    if (minute != 59)
      minute++;
  }</b></pre>
<!---
  ModularCounter minute = new ModularCounter(60);
  ModularCounter hour   = new ModularCounter(24);
  ...
  minute.inc()
  if (minute.getValue() == 0) {
    emitBeeps(hour.getValue()+1);
    hour.inc();
  }
--->
</ol>
</td>
</tbody>
</table>


</body>
</html>

</body>
</html>


<!--
  EBNF of call: arguments etc.
 ---> 
