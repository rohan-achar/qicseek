<html>
  <head>
    <title>ICS 22/CSE 22 - Project #3: What's Simple is True</title>
    <LINK href="../../style.css" rel="StyleSheet" type="text/css">
  </head>
  <body bgcolor="DCFBFB" text="5C4033" >


  <div id="content">

    <h1>Project #3: <i>What's Simple Is True</i></h1>

    <p><b>Due date and time:</b> <i>Friday, April 29, 6:59pm</i></p>
    <p><i>This project is to be done individually</i></p>

    <h1>Introduction</h1>



    <p>The first programming language I learned was a simple language called BASIC.
    BASIC was a good teaching tool for its day: versatile and easy-to-learn.
    For this project, you will implement a limited version of BASIC called
    Facile, which supports only eleven kinds of statements.  You'll be building a
    Facile <i>interpreter</i>.  The project will give you additional practice with
    inheritance and polymorphism, allow you to implement a linked-list-based stack,
    and provide you with some design experience, since you will be responsible for designing
    parts of this project.</p>

    <h1>Reminder: Do not partner up</h1>

    <p>For this project, your work is expected to be completed individually, so <i>do not</i> partner up, and <i>do not</i> follow the pair programming model as in the previous projects.  Pair programming is a great technique, but to prepare you for your work in future courses where individual work will be expected, I'd like you to have the opportunity this quarter to work on a couple of projects individually.</p>

    <h1>The Facile language</h1>

    <p>We'll discuss the requirements for your interpreter later in the write-up.  First, let's talk about the Facile language.</p>

    <p>A Facile program is a sequence of <i>statements</i>, one per line.  Here's an example of a Facile program:</p>

    <pre>
    LET A 3
    PRINT A
    GOSUB 7
    PRINT A
    PRINT B
    GOTO 10
    LET A 4
    LET B 6
    RETURN
    PRINT A
    END
    .
    </pre>

    <p>Each line contains exactly one statement (i.e., there may be no blank lines).  Facile assigns a <i>line number</i> to each of the lines, where the first line of the program is numbered 1, the second line is numbered 2, and so on.  The last line of the program is a period (.) on a line by itself.  Execution of a Facile program always begins at line number 1.  There is no predefined limit on the number of lines in a Facile program.</p>

    <h2>Variables</h2>

    <p>A Facile program has 26 variables, named by the capital letters A through Z.  Each variable is capable of storing an integer value.  Variables do not need to be declared like they do in Java; all 26 of them are created automatically at the beginning of the program, and each is given the value 0 initially.</p>

    <p>The value of a variable may be changed with a LET statement.  A LET statement changes the value of one variable.  Some examples are:</p>

    <ul>
    <li><b>LET A 3</b> - changes the value of the variable A to 3</li>
    <li><b>LET Z -9</b> - changes the value of the variable Z to -9</li>
    </ul>

    <p>You can print the value of a variable to the console by using a PRINT statement.  A PRINT statement prints the value of one variable, followed by a newline.</p>

    <p>So, consider the following short Facile program:</p>

    <pre>
    LET A 3
    LET Z -9
    PRINT A
    PRINT Z
    .
    </pre>

    <p>Its output would be:</p>

    <pre>
    3
    -9
    </pre>

    <h2>Execution of a Facile program</h2>

    <p>A Facile program is executed one line at a time, beginning at line number 1.  Ordinarily, execution proceeds forward, so that line 1 will execute first, followed by line 2, followed by line 3, and so on.  Execution continues until either an END statement is reached, or until it reaches the "." line that appears at the end of the program.</p>

    <p>Like any programming language, it is possible in Facile to write programs that execute out of sequence, though the mechanisms are a bit more primitive than they are in a language like Java.  A GOTO statement causes execution to "jump" immediately to the given number.  For example, the statement <b>GOTO 4</b> jumps execution to line 4.  Here's an example Facile program that uses GOTO:</p>

    <pre>
    LET A 1
    GOTO 4
    LET A 2
    PRINT A
    .
    </pre>

    <p>In this program, line 1 is executed first, setting the variable A's value to 1.  Then the GOTO statement will immediately jump execution of the program to line 4, skipping the second LET.  Line 4 prints the value of A, which is 1.  So, the output of the program is 1.</p>

    <p>A GOTO statement may jump either forward or backward, meaning that the following program is a legal Facile program.  See if you can figure out what its output would be.  (Remember that the value of a variable that hasn't yet been assigned with a LET is 0.)</p>

    <pre>
    LET Z 5
    GOTO 7
    LET C 4
    PRINT C
    PRINT Z
    END
    PRINT C
    PRINT Z
    GOTO 3
    .
    </pre>

    <p>GOTO statements are not permitted to jump beyond the boundaries of the program, to lines before line 1 or lines after the "." that completes the program.  If such a GOTO statement is encountered while a program is executed, the interpreter terminates with an error message.</p>

    <h2>Mathematical operations</h2>

    <p>Facile provides the typical mathematical operations that can be performed on variables: addition, subtraction, multiplication, and division.  Each operation is provided as a statement that changes the value of the given variable.  Here are examples of their use:</p>

    <pre>

    LET A 4
    ADD A 3
    PRINT A
    LET B 5
    SUB B 3
    PRINT B
    LET C 6
    MULT C 7
    PRINT C
    LET D 7
    DIV D 2
    PRINT D
    .
    </pre>

    <p>In the example above, the ADD statement adds 3 to the value of A, storing the result in A.  So, printing A will display 7 on the console.  The output of the program above is:</p>

    <pre>
    7
    2
    42
    3
    </pre>

    <p>It is important to note that, since all variables in Facile are integers, the DIV statement implements integer division, meaning that its result is the floor (or integral part) of the quotient.  So, in the example above, 7 / 2 = 3.  The second operand may not be zero, meaning that the statement <b>DIV A 0</b> is illegal.  When a Facile program encounters a division by zero, it immediately terminates with an error message.</p>

    <h2>The IF statement</h2>

    <p>Facile provides an IF statement, which acts like a conditional GOTO.  It compares the value of some variable to some value, and jumps execution of the program to the given line number if the comparison is true.  The comparison can use one of the typical relational operators: &lt;, &lt;=, &gt;, &gt;=, = (equal to), or &lt;&gt; (not equal to).</p>

    <pre>
    LET A 3
    LET B 5
    IF A &lt; 4 THEN 5
    PRINT A
    PRINT B
    .
    </pre>

    <p>In the program above, the variables A and B are given the values 3 and 5, respectively.  An IF statement then compares A to 4.  Since A is less than 4, execution jumps to line 5.  B's value is printed out.  So this program's output is simply:</p>

    <pre>
    5
    </pre>

    <p>The IF statement in Facile is substantially less flexible than its Java equivalent.  In an IF statement in Facile, the token IF must be followed by exactly five tokens.  The first must be the name of a variable.  The second must be one of the relational operators (&lt;, &lt;=, &gt;, &gt;=, =, or &lt;&gt;).  The third must be an integer constant.  The fourth must be the word THEN. The fifth must be a line number.  They behave in the way you might expect.  For example: <b>IF C &lt;&gt; 0 THEN 4</b> means "jump to line 4 if C is not equal to 0".</p>

    <p>Like GOTO statements, IF statements are not permitted to jump beyond the boundaries of the program.  An attempt to do so should cause the Facile program to terminate with an error message.</p>

    <h2>Subroutines</h2>

    <p>There are no methods or functions in Facile, but there is a simplified mechanism called a <i>subroutine</i>.  A subroutine is a chunk of Facile code that can be "called" by issuing a GOSUB statement.  GOSUB is much like GOTO; it causes execution to jump to a particular line.  However, GOSUB also causes the Facile program to remember where it jumped from.  Subsequently, when a RETURN statement is reached, execution continues at the line following the GOSUB statement that caused the jump.  Here's an example:</p>

    <pre>
    LET A 1
    GOSUB 6
    PRINT A
    PRINT B
    END
    LET A 2
    LET B 3
    RETURN
    .
    </pre>

    <p>In the program above, line 1 is executed first, setting the value of A to 1.  Next, a GOSUB statement is reached.  Execution jumps to line 6, but Facile also remembers that when a RETURN statement is reached, execution should jump back to the line following the GOSUB &mdash; in this case, line 3.  Line 6 is executed next, setting A to 2, then line 7 sets B to 3.  Now we reach a RETURN statement, causing execution to jump back to the line number that we're remembering &mdash; line 3.  Line 3 prints the value of A (which is 2), then line 4 prints the value of B (which is 3).  Next, we reach line 5, which is an END statement, so the program ends.</p>

    <p>Subroutines can be used very similarly to Java methods, except they do not take parameters or return a value.  Consider the following example, which contains a subroutine that prints the values of A, B, and C each time it's called:</p>

    <pre>
    LET A 3
    GOSUB 10
    LET B 4
    GOSUB 10
    LET C 5
    GOSUB 10
    LET A 1
    GOSUB 10
    END
    PRINT A
    PRINT B
    PRINT C
    RETURN
    .
    </pre>

    <p>Subroutines may call other subroutines, meaning that two or more GOSUB's may be reached before a RETURN is reached.  The rules for this are very similar to methods that call other methods in Java; for each GOSUB that is reached, Facile will remember the line to which it should return.  When a RETURN is reached, execution will move to the line remembered from the <i>most recent</i> GOSUB.  Here's an example:</p>

    <pre>
    LET A 1
    GOSUB 7
    PRINT A
    END
    LET A 3
    RETURN
    PRINT A
    LET A 2
    GOSUB 5
    PRINT A
    RETURN
    .
    </pre>

    <p>In this example, execution begins at line 1 by setting the variable A to 1.  Next, we jump to line 7 with a GOSUB, but remember that we should jump back to line 3 when we encounter a RETURN.  Line 7 prints A (which is 1), then line 8 changes A's value to 2.  Now we've reached line 9, which is another GOSUB statement.  At this point, execution will jump to line 5, but we'll also need to remember to jump back to the line following this GOSUB &mdash; line 10 &mdash; when we reach a RETURN.  But we also need to remember the line from the previous GOSUB &mdash; line 3.</p>

    <p>Line 5 sets A to 3, then we encounter our first RETURN statement.  We're remembering two lines &mdash; line 3 and line 10.  But line 10 is the most recently remembered line, so execution jumps to line 10.  Line 10 prints A (which is 3).  Now we encounter another RETURN statement on line 11.  We're remembering the line 3 from the first GOSUB.  So execution jumps to line 3, printing A (which is still 3), then ending the program on line 4.</p>

    <p>So, the output of this program is:</p>

    <pre>
    1
    3
    3
    </pre>

    <p>Like GOTO statements, GOSUB statements are not permitted to jump beyond the boundaries of the program, to lines before line 1 or lines after the "." that completes the program.  If such a GOSUB statement is encountered while a program is executed, the interpreter terminates with an error message.</p>

    <p>It is also an error for a RETURN statement to be encountered when there has been no previous GOSUB.  The Facile program will immediately terminate and print an error message in this case, as well.</p>

    <h2>Whitespace</h2>

    <p>While Facile programs may not have blank lines in them, the amount and placement of blank space between the words on each line is considered irrelevant.  So, the following is a legal Facile program:</p>

    <pre>

    LET    Z  5
    GOTO   7
    LET C   4
    PRINT C
    PRINT         Z
    END
    PRINT C
    PRINT  Z
    GOTO      3
    .
    </pre>

    <h1>Do you want to experiment with Facile?</h1>

    <p>An <i>interpreter</i> is a program that is capable of executing a program written
    in some programming language.  Microsoft's first-ever software project, back when
    Bill Gates was still a college student in the 1970's, was a BASIC interpreter for a computer called the Altair.  The software allowed people to write and execute BASIC programs on the Altair, making it one of the first legitimate personal computers in history, and launching Microsoft on its path to becoming one of the largest and most powerful companies in the world.</p>


    <p>We providing you with  a Facile interpreter for Windows for you to try out
    sample programs.  (For those of you
    who don't ordinarily use Windows, remember that our machines in the ICS labs run
    Windows, so you'll have ample opportunity to experiment with Facile.  You might
    even want to "pair program" while you experiment!)
    This <a href="Facile.zip">Zip archive</a> contains the interpreter
    (Facile.exe) and all of the Facile programs that appear in this write-up,
    along with a few additional ones that demonstrate fatal errors (division
    by zero, a RETURN statement without a corresponding GOSUB, and a GOTO to
    a non-existent line).  Feel free to write your own, as well.  Unzip the
    archive into one folder, then double-click the program.  From there,
    it's fairly self-explanatory.  A word of warning about the interpreter:
    It does not make a serious attempt at handling syntax problems,
    so it assumes that the input file is a legal Facile program.
    If you attempt to run an input file that is not legal Facile,
    you may see the message "ERROR IN PROGRAM", but it's also
    possible that it may simply crash.</p>

    <p>The interpreter is provided so you can experiment with the language as
    you have questions about it.  Once you're comfortable with it, it'll be
    your turn to implement a Facile interpreter.  (Bear in mind that the Facile
    interpreter implements much of the optional work described in the
    "Additional challenges" section below, but it will behave correctly
    on the samples given in this write-up.)</p>

    <h1>The program</h1>

    <p>For this project, you'll be building your own <i>Facile interpreter</i>, which is a program that is capable of executing a Facile program, generating the correct output according to the specification in the previous sections.  Since you're all somewhat familiar with Java, you'll write your Facile interpreter in Java.  (Since Java runs on many operating systems, that means, once completed, you'll be able to use your interpreter to run Facile programs on Windows, Mac OS X, Linux, Unix, and several other platforms.  Not too shabby!  I can't promise, however, that this will provide you with the foundation for a multi-billion-dollar company.)
    You will be provided  with a starting point, but  not  a complete skeleton for your program, so you'll have a bit more design work to do this time around.  Don't worry; plenty of design advice is available below and, of course, we're happy to answer questions as you encounter problems.</p>

    <p>The Facile interpreter that is provided runs in a (very simple) graphical user interface.  Your program, on the other hand, should read one Facile program from an input file, then execute it, writing any output from the Facile program to the console (i.e., <b>System.out</b>).</p>

    <p>So that we can keep everything straight during the grading process,
    please write your <b>main( )</b> method in a class called <b>Facile</b>.
    This way t we can run your program using the following command:</p>

    <pre>
    java Facile program1.f
    </pre>

    <p>where the name of the input file is specified as a command-line argument to the program.  If we ran your interpreter with the command above, it would execute the Facile program in the file <b>program1.f</b>.</p>

    <h1>Starting point</h1>

    <p>As with the previous projects, you are provided wtih
    some code to get you started.  This time, you will be provided with some of the underlying code,
    but you will have to design part of the program on your own, including the class that contains the <b>main( )</b> method.  Bear in mind that your <b>main( )</b> method will need to be in a class called Facile, and that <b>main( )</b> method must expect the filename of the Facile program to be passed as a command-line argument, as discussed in the previous section.</p>

    <p>The provided code is available as a <a href="Simple.zip">Zip archive</a>.</p>

    <h1>How does an interpreter work?</h1>

    <p>A typical interpreter will execute a program one statement at a time, keeping track of what we might call the <i>program state</i> as it goes along.  In the case of a Java interpreter, you might imagine that there would be quite a bit of work to be done.  The interpreter would need to keep track of all of the objects &mdash; creating new ones and garbage-collecting old ones as necessary &mdash; as well as maintain the "call stack," along with various other tasks required by Java programs.  Implementing an efficient, complete Java interpreter is a project that would easily take many programmer-years.</p>

    <p>A Facile interpreter is a much simpler program, since Facile is a much simpler programming language.  Your interpreter will need to execute a Facile program one statement at a time, updating the program state as necessary, until either an END statement or the "." is reached.  (The "." can simply be treated as an END statement, if you'd like.)  The program state consists of the following information:</p>

    <ul>
    <li>what line of code is currently executing (you might call this the <i>program counter</i>)</li>
    <li>the integer value in each of the 26 variables</li>
    <li>the line numbers remembered because of any GOSUB statements; since each RETURN jumps back to the line following the most recent GOSUB, it makes sense to store these line numbers in a stack</li>
    </ul>

    <p>Each statement has a different effect on the program state.  For example, a LET statement will cause the value of one of the variables to change, then cause the program counter to be incremented (since, after a LET statement, execution continues on to the next statement), a GOTO statement will cause the program counter to be changed to the line number specified in the statement, and so on.</p>

    <h1>Reading the program from an input file and representing it in memory</h1>

    <p>Your program will need to begin by reading the Facile program from an input file and representing it in memory.  There are a number of ways to solve this problem.  One way is to read the program into memory as a collection of Strings, with each of the Strings containing one line of the input program.  Every time a particular line is executed, it would need to be parsed (to see what kind of statement it was), then executed.  As you might imagine, this is a terribly inefficient way to implement an interpreter, since the same statement may need to be parsed over and over again.  You are not permitted to use this approach for your interpreter.</p>

    <p>A better approach &mdash; one that I'm requiring you to use instead &mdash; is to read the input program once, parse it once, and represent it as objects.  Inheritance and polymorphism provide a very natural design approach for this problem.</p>

    <ul>
    <li>An abstract class called Statement contains any functionality common to all statements.
    You are provided with such an abstract class as part of the starting point.  The only common functionality for all statements is that they can be executed, though what happens when they are executed is different depending on the type of the statement.
    This is represented in the Statement class  provided as an abstract method called <b>execute( )</b>.</li>
    <li>For each kind of statement (e.g., LET, PRINT, etc.), a subclass of Statement can be designed (e.g., LetStatement, PrintStatement).  Each class contains fields that store the information needed to execute the statement.  In the case of a LET statement, for example, the necessary information is the name of the variable and the value to assign into it.  Also needed in each of these Statement subclasses is an actual implementation of the <b>execute( )</b> method.
    As an example, you are provided with a partially-complete LetStatement class in the starting point.  You'll need to design and implement the others.</li>
    </ul>

    <p>There needs to be code that can parse the input file and create the appropriate sequence of Statement objects.
    As part of the starting point, you are provided with a skeletal implementation of a class called Parser that does just that: it reads the input file and returns an ArrayList&lt;Statement&gt; containing all the statements in the program.  Note that line numbers in Facile start at 1, not 0, so I suggest storing null as the first element in the ArrayList, then storing the actual statement objects with indices beginning at 1.  (An alternative, storing the statements beginning at index 0, will require the error-prone practice of adding or subtracting one when converting between line numbers and ArrayList indices, which can easily lead to chaos.)</p>

    <p>You may assume that the input file contains a syntactically legal Facile program.  It's acceptable for your program to either print an error message, ignore lines that aren't understood, or even crash in the event that it's given an input file that is not legal Facile.  (It's a good thing Java compilers don't behave this way.)  We will only test your interpreter with syntactically legal Facile programs, though the programs may have run-time errors in them.  As was discussed above, there are three kinds of run-time errors: division by zero, a RETURN statement without a corresponding GOSUB, and a GOTO/GOSUB/IF..THEN to a line outside of the boundaries of the program.  Your interpreter will need to behave reasonably in these cases, by printing a meaningful error message and terminating gracefully.</p>

    <h1>Designing your interpreter</h1>

    <p>As the size of a program increases, one of the most difficult obstacles that programmers
    face is the need to separate their concerns.  One of the primary strategies that programmers
    use to separate their concerns is to break a large program into a set of smaller pieces.
    The obvious mechanism for breaking up a program in an object-oriented language such as
    Java is the use of classes.</p>

    <p>It is especially difficult for novice programmers to keep their concerns separate.
    The temptation is always to try to think about the complete picture, since this strategy
    works well for the short programs that you write when you're first starting out.
    As programs become larger, confusion naturally sets in, as the complete picture can
    be difficult to keep in your brain all at once.  Even moderately small Java programs
    are typically built out of many classes and encompass a great deal of complexity.
    It is a good design principle to break up your program into classes that are relatively
    small in size, even if it means creating a lot of classes. This will
    allow you to concentrate your efforts on one largely in the absence of the others.
     This project will encourage you to begin thinking about your programs
    the same way, which will give you the ability to write much larger programs than
    you could before.</p>

    <p>The main tasks that your program must perform are:</p>

    <ul>
    <li>Read the contents of the input file, parsing each line, and storing an object into memory that represents the Facile statement appearing on that line.</li>
    <li>Create a representation of the initial program state, then begin executing the program one statement at a time.  The execution of each statement will cause the program state to be changed, and may also cause output to appear on the console.</li>
    <li>Continue executing the program until an END statement or the "." is reached.</li>
    </ul>

    <p>I suggest breaking up your program in the following way:</p>

    <ul>
    <li><b>Facile</b>.  This class will contain your <b>main( )</b> method.
    I suggest that it does very little, other than creating an Interpreter object, passing the program's command-line argument to the constructor.  It should print an error message if no command-line argument is passed to the program.</li>
    <li><b>Interpreter</b>.  This class will oversee the execution of the interpreter on one input file.  Interpretation requires following the sequence of steps above: parsing the input file, creating an initial program state, then executing one statement at a time until the program ends.  Most of the actual work is delegated to other classes, with Interpreter acting as a manager.</li>
    <li><b>Parser</b>.  This class parses the input file and returns an ArrayList of objects representing statements.</li>

    <li><b>Stack&lt;E&gt;</b>.  A generic stack, which you'll use to store the return points from GOSUB statements.  Since there is no maximum number of GOSUB's that may be encountered during a program, you must implement your stack as a linked-list-based stack.</li>
    <li><b>ProgramState</b>.  This class represents the state of an executing Facile program.  It contains the program counter, the values in each of the 26 variables, and a stack of return points from GOSUB statements.</li>
    <li><b>Statement</b>.  This (abstract) class represents a Facile statement.  Subclasses such as LetStatement, PrintStatement, etc., implement the actual statements.</li>
    </ul>

    <p>I've provided portions of many, but not all, of these classes in the starting point.</p>

    <p>It's a good idea to build as many of the underlying pieces as you need to implement a couple of the statements, say LET and PRINT, first.  Afterward, add new kinds of statements one or two at a time, making any changes required in the underlying pieces.</p>

    <h1>Implementing your stack generically</h1>

    <p>As part of the starting point for this project, you are provided with
    a skeleton for a generic Stack&lt;E&gt; class.  You are required to implement your stack generically using this skeleton.  It is required that you implement it as a linked list.  I suggest using your LinkedList&lt;E&gt; class from the previous project as the underlying implementation, though you may rebuild the linked list functionality directly into the Stack&lt;E&gt; class if you prefer.</p>

    <h1>How to use a Stack&lt;E&gt; to store integers</h1>

    <p>Generic classes are very versatile, in that they can be used to store any kind of object.  A Stack&lt;String&gt; stores Strings, while a Stack&lt;ArrayList&lt;Voter&gt;&gt; stores ArrayLists of Voters.  However, there is one wrinkle: values of primitive types like <b>int</b> and <b>char</b> are not objects!  This brings up the question of how to store <b>int</b>s into generic classes such as ArrayList or Stack, since it isn't legal to create an ArrayList&lt;int&gt; or a Stack&lt;char&gt;.</p>

    <p>There are classes, such as Integer and Character, in the Java library that define object wrappers for each primitive type.  An Integer object is an object that stores an <b>int</b> within it.  Java 5.0 is very adept at converting <b>int</b>s to Integer objects and back again automatically, using a new feature called <i>autoboxing</i> and <i>autounboxing</i>.  Autoboxing means automatically wrapping a primitive value into an object; autounboxing means automatically unwrapping an object and giving you back the primitive value inside of it.</p>

    <p>The tricky part is knowing how to declare a generic class appropriately to allow it to store these "boxed" primitive values for you.  Suppose you want to store an ArrayList of integers.  Here's how you create one:</p>

    <pre>
    // Notice the use of Integer instead of int
    ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();
    </pre>

    <p>Thanks to automatic conversions from <b>int</b> to Integer and back, you can now treat the ArrayList as though it contained <b>int</b>s instead of Integers.  Here are a couple of examples:</p>

    <pre>
    // This statement adds the int 3 to the ArrayList.  It turns out that
    // Java will automatically wrap the int with an Integer object, but this
    // is only relevant from a performance perspective (wrapping takes time).
    a.add(3);

    // When fetching values out of the ArrayList, you can fetch an int instead
    // of an Integer object, with Java automatically unwrapping the object for
    // you.
    int i = a.get(0);
    </pre>

    <p>This approach will be handy in your program, since you'll need a stack of integers.  I suggest declaring it as a Stack&lt;Integer&gt;, after which you can essentially treat it as though it were really a Stack&lt;int&gt;.</p>

    <h1>Command-line arguments: passing parameters to an entire program</h1>

    <h2>What are command-line arguments?</h2>

    <p>In Java, methods can take <i>parameters</i>, which allow the caller to configure what job the method should do.  For example, the get( ) method in the ArrayList class allows us to ask for one of the elements in the ArrayList; it requires an integer parameter, which specifies the index of the element that the caller wants.  If we want the first element in the list, we call get( ) with a parameter of 0.</p>

    <p>Programs, too, can take parameters.  Why we want them is the same reason why we want method parameters: if programs can take parameters, we can use them to configure how the program behaves.  In ICS 21 / CSE 21, you may have used a program called <b>javac</b>, a Java compiler, to compile your Java source files.  Say, for example, you had a file called MusicList.java and you wanted to compile it; from the command line, you'd run this command:</p>

    <pre>
    javac MusicList.java
    </pre>

    <p>In this case, <b>javac</b> is the name of the program.  If you just typed <b>javac</b>, you'd be telling the Java compiler to run, but you wouldn't be telling it what file you wanted to compile!  After the name of the program, the remaining elements of the command are called <i>command-line arguments</i>; in this case, <b>MusicList.java</b> is a command-line argument that's interpreted by the program as the name of the file to be compiled.</p>

    <p>Java programs can take command-line arguments, as well.  When you run a Java program from the command line using the <b>java</b> command, you typically write a command line this:</p>

    <pre>
    java Facile
    </pre>

    <p>where, in this case, <b>Facile</b> is the name of the class that contains your main( ) method.</p>

    <p>If you want to pass a command-line argument to a Java program from the command line, you do so by just adding them to the command, just like you do when you use <b>javac</b>.  For example, if you want to pass the filename <b>prog1.f</b> as a parameter to your Facile interpreter, you could do so from the command line like this:</p>

    <pre>
    java Facile prog1.f
    </pre>

    <p>The command line arguments are made available to your program, which can use them to configure its behavior.</p>

    <h2>Accessing command-line arguments within a Java program</h2>

    <p>Have you ever wondered why the signature of the main( ) method is this?</p>

    <pre>
    public static void main(String[] args)
    </pre>

    <p>In particular, have you ever wondered what the <b>args</b> array is all about?  Well, it's no mystery anymore: <b>args</b> contains the command-line arguments.</p>

    <p>For example, if you run a Java program this way on the command line:</p>

    <pre>
    java MyProgram alex is happy today
    </pre>

    <p>the MyProgram class' main( ) method will be called, and its <b>args</b> array will look like this:</p>

    <table>
    <tr class="shade">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    </tr>
    <tr>
    <td>alex</td>

    <td>is</td>
    <td>happy</td>
    <td>today</td>
    </tr>
    </table>

    <p>So, if you accessed <b>args[0]</b> in main( ) in this example, you'd get <b>alex</b>; if you access <b>args[1]</b>, you'd get <b>is</b>, and so on.  Also, since arrays can tell you their length if you access their <b>length</b> field, <b>args.length</b> will tell you how many command-line arguments there were.  In the example above, <b>args.length</b> will be 4.</p>

    <p>In your program, you'll want to pass the value of args[0] &mdash; which is expected to be the filename &mdash; from your main( ) method into the Interpreter class, which can then use that information to know what file it should be parsing and interpreting.  You'll also want, in your main( ) method, to check whether the number of arguments in anything other than 1; if it is, you'd want to print an error message and return from main( ) without doing anything else.</p>

    <h2>Setting the command-line arguments in Eclipse</h2>

    <p>There's one other issue for us, since we use Eclipse, rather than the command line.  When you run a Java program from within Eclipse, you don't type a command on the command line; you right-click a file in the Package Explorer and select <b>Run As</b>, then <b>Java Application</b>.  So, how do you set the command-line arguments?  The answer is that you have to run your program a little bit differently.</p>

    <p>To run your program with command-line arguments, use this procedure instead:</p>

    <ul>
    <li>As you would do normally, right-click on the .java file in your Package Explorer window that contains your main( ) method.  (In this case, Facile.java.)</li>
    <li>On the ensuing menu, select <b>Run As</b>, also as you would do normally.</li>
    <li>Instead of then selecting <b>Java Application</b>, select <b>Run Configurations...</b>.</li>

    <li>This will cause a window to pop up with a number of options that you can set.  (Don't let yourself get lost in all the options; there's only one thing you'll want to set.)  On that window, choose the <b>Arguments</b> tab.</li>
    <li>In the <b>Program arguments</b> field, type your arguments.  In this case, type the name of the filename you'd like your interpreter to run (e.g., <b>prog1.f</b>).</li>
    <li>Click the <b>Run</b> button in the lower-right corner of the window.  Eclipse will now execute the program as though you had typed this command from the command line:
    <pre>

    java Facile prog1.f
    </pre>
    </li>
    </ul>

    <p>To allow Eclipse to find your Facile files, place them in the folder within your Eclipse workspace that corresponds to this project.  So, for example, if your project is called <b>Project3</b>, find the folder called <b>Project3</b> within your Eclipse workspace and put the Facile files there.  (Note that you shouldn't put them in the <b>bin</b> or <b>src</b> folders within your project.)</p>

    <p>Be aware that, once you've done this, every time you run your program, it will have the same arguments until you use this procedure to change them.  Other programs, like the ones you wrote in previous projects, will not be affected, though.</p>

    <h1>Testing</h1>

    <p>To satisfy the testing portion of this project, you're required to implement a programmatic unit test program, as you did in the previous project.  Your tester should test, at minimum, the Stack&lt;E&gt; and ProgramState classes, though you may include tests for other classes if you wish.  (You may well find that additional testing helps you to get your program working.)</p>

    <p>Remember that the tester should be a separate program &mdash; a separate class with a separate main( ) method &mdash; from the Facile interpreter.  When executing the Facile interpreter, the tests should not run.</p>

    <h1>Facile quick reference</h1>

    <p>Here is a list of all of the Facile statements that should be supported by your interpreter, with a brief description of the effect of each.  In each of the statements below, <i>var</i> may be the name of a variable (A, B, C, ..., Z), <i>int</i> may be an integer constant (e.g., 1, -3, 15), and <i>linenum</i> may be a line number (1..1000).</p>

    <table>
    <tr>
    <th>Statement</th>
    <th>Description</th>
    </tr>
    <tr>
    <td>LET <i>var</i> <i>int</i></td>
    <td>Changes the value of the variable <i>var</i> to the integer <i>int</i>.</td>

    </tr>
    <tr>
    <td>PRINT <i>var</i></td>
    <td>Prints the value of the variable <i>var</i> to the console.</td>
    </tr>
    <tr>

    <td>ADD <i>var</i> <i>int</i></td>
    <td>Adds <i>int</i> to the value of the variable <i>var</i>.</td>
    </tr>
    <tr>

    <td>SUB <i>var</i> <i>int</i></td>
    <td>Subtracts <i>int</i> from the value of the variable <i>var</i>.</td>
    </tr>
    <tr>

    <td>MULT <i>var</i> <i>int</i></td>
    <td>Multiplies the value of the variable <i>var</i> by the integer <i>int</i>.</td>
    </tr>
    <tr>

    <td>DIV <i>var</i> <i>int</i></td>
    <td>Divides the value of the variable <i>var</i> by the integer <i>int</i>.</td>
    </tr>
    <tr>

    <td>GOTO <i>linenum</i></td>
    <td>Jumps execution of the program to the line numbered <i>linenum</i>.</td>
    </tr>
    <tr>
    <td>IF <i>var</i> <i>op</i> <i>int</i> THEN <i>linenum</i></td>

    <td>Compares the value of the variable <i>var</i> to the integer <i>int</i> using the relational operator <i>op</i> (=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=).  If the comparison is true, jumps execution of the program to the line numbered <i>linenum</i>.  If not, this statement has no effect.</td>

    </tr>
    <tr>
    <td>GOSUB <i>linenum</i></td>
    <td>Temporarily jumps to the line numbered <i>linenum</i>.  A RETURN statement will cause execution to jump back to the line following the GOSUB.</td>
    </tr>
    <tr>

    <td>RETURN</td>
    <td>Jumps execution of the program back to the line following the most recently-executed GOSUB statement.</td>
    </tr>
    <tr>
    <td>END</td>
    <td>Ends the program immediately.</td>
    </tr>

    <tr>
    <td>.</td>
    <td>Special marker that indicates the end of the program text.  Behaves as an END statement when encountered.</td>
    </tr>
    </table>
    <p></p>

    <h1>Deliverables</h1>

    <p>You must submit all of your <b>.java</b> files, including those that were provided to you.  Please do not turn in the <b>.class</b> files, or other files generated by your development environment.</p>

    <p>Follow <a href="../submittingprojects.html">this link</a> for a discussion of how to submit your project.</p>

    <h1>Limitations</h1>

    <p>You must implement your own stack class.  Furthermore, you must use a linked-list-based implementation.  You may not store the stack elements in an array or ArrayList, and you may not use the existing java.util.Stack class.  You also may not use the existing java.util.LinkedList class.</p>

    <p>That said, you <i>may</i> (and, in fact, should) use an ArrayList to store the objects that represent the statements in the program.  Remember that the program is not to be stored in a stack; the stack is for storing return points from GOSUB statements.  Of course, you should use a generic ArrayList appropriately specialized (e.g., ArrayList&lt;Statement&gt;).</p>

    <h1>Additional challenges</h1>

    <p>The Facile interpreter you have been provided with
    implements some additional features.  If you want to work further on your interpreter, you might try supporting these additional features, though they are not required, and no extra credit is offered for them.</p>

    <p>Firstly, you can include two additional statements:</p>

    <table>
    <tr>
    <th>Statement</th>
    <th>Description</th>
    </tr>
    <tr>
    <td>INC <i>var</i></td>
    <td>Adds 1 to the value of the variable <i>var</i>.  For example, the statement <b>INC A</b> adds one to the value of A.</td>

    </tr>
    <tr>
    <td>DEC <i>var</i></td>
    <td>Subtracts 1 from the value of the variable <i>var</i>.  For example, the statement <b>DEC A</b> subtracts one from the value of A.</td>
    </tr>

    </table>

    <p>Including these statements in Facile does not dramatically increase its power, but it does allow for convenient incrementing and decrementing, which can be handy for constructing simple "loops."</p>

    <p>There is another  improvement that increases the expressiveness of the language quite a bit.  Consider a statement such as LET.  As defined above, the LET statement sets the value of some variable to some integer constant.  But imagine that you wanted to set the value of some variable to be equal to the value of some other variable.  Facile, as defined above, does not allow this fundamental operation.
    But there's no reason it couldn't; and, in fact, the interpreter that  you have been provided with does.</p>

    <p>In many places where an integer constant may normally
    appear in a Facile program, it would be possible to allow the name of a variable to appear instead.
    In the case of PRINT, you could also allow an integer constant instead of a variable name.  So, for example, these statements may be given to my interpreter:</p>

    <ul>
    <li><b>LET A B</b> - Sets the value of A to be equal to the value of B.</li>

    <li><b>PRINT 3</b> - Prints the integer constant 3 to the console.</li>
    <li><b>ADD B C</b> - Adds the value of C to the value of B, storing the result in B.</li>
    <li><b>SUB B C</b>, <b>MULT B C</b>, <b>DIV B C</b> - similar to the ADD statement above</li>

    <li><b>IF A &lt;= B THEN 4</b> - Jumps to line 4 if A is less than or equal to B.</li>
    <li><b>IF 3 &lt;= B THEN 4</b> - Jumps to line 4 if 3 is less than or equal to B.</li>
    <li><b>IF 4 &lt;= 9 THEN 4</b> - Jumps to line 4 is 4 is less than or equal to 9.</li>

    </ul>

    <p>This is the extent of Facile, as it is supported by the interpreter that has been
    provided for you.  If you're interested in discussing approaches for implementing the suggestions above, I'd be happy to chat with you about it.</p>

    <p>You might also consider designing and implementing some new statements to accomplish some of these important goals, or others of your own choosing:</p>

    <ul>
    <li>Allow Facile programmers to put comments into their code.  (This could bring up an interesting question about the design of the language: how should line numbers be counted if not all lines contain code?)</li>
    <li>Define additional variables that can store string values instead of integers.  The BASIC language names such variables with trailing $ characters.  So you might have the variables A$, B$, C$, ..., Z$, each of which is capable of storing a string.</li>

    <li>Add a statement, or perhaps a variant of the PRINT statement, to output a string of text (a string literal or the value of a string variable) to the console.</li>
    <li>Allow the IF statement to compare two string variables, or to compare a string variable to a string literal.</li>
    <li>Add a statement to read an integer and/or string from the console and store it in a variable.</li>
    </ul>

    </div>

       <h3>Acknowledgements</h3>
	      <ul class="nomarker">
	          <li>Imported from Eric Hennigan's ICS 22 which was in turn adapted from Alex Thornton's version which he
	      developed over many years.</li>
    </ul>
  </body>
</html>
 
