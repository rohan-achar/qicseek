<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="course2.css" type="text/css" />

<title>ICS 142 Winter 2004, Midterm Answer Sheet</title>
</head>

<body>

<div class="navbar">

<p>
ICS 142 Winter 2004 |
<a href="index.html">News</a> |
<a href="CourseReference.html">Course Reference</a> |
<a href="Schedule.html">Schedule</a> |
<a href="LabManual">Lab Manual</a> |
<a href="news:ics.142">ics.142 newsgroup</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 142 Winter 2004<br />
   Midterm Answer Sheet</p>

</div>

<div class="section">

<hr />

<p class="title">Introduction</p>

<p>There were three versions of the exam.  Though all three asked essentially the same questions, some minor changes were made to distinguish them from one another.  The answers for all three versions appear below; it should be evident from your exam sheet which answers are relevant for your version.</p>

<p>If you're wondering about your score, have a look at the <a href="MidtermScores.html">Midterm scores</a>.</p>

</div>

<div class="section">

<hr />

<p class="title">The answers</p>

<p class="subtitle">Problem 1</p>

<p>Results on this problem were mixed, with an average score of 4.6 out of 8.  Many people lost a point on the first part, as they didn't answer the question that was asked.  Several others didn't write regular expressions, but instead wrote grammars or some other kind of notation that we couldn't unscramble.</p>

<p><i>a)</i></p>

<p>The answers here were:

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr><td>a+b+</td><td>x+y+</td><td>y+x+</td></tr>
</table>

<p>Other equivalent regular expressions, such as <b>aa*bb*</b> were accepted, as well.  The most common wrong answer was one of the form <b>ab+</b>, which was awarded half-credit.</p>

<p><i>b)</i></p>

<p>There are certainly multiple reasonable solutions to this problem (which mimicked a problem you faced on one of the lab assignments), but straightforward answers were:</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>[A-Z] [a-z]* ($ [A-Z] [a-z]*)*</td>
    <td>[A-Z] [a-z]* (- [A-z] [a-z]*)*</td>
    <td>[a-z] [A-Z]* (^ [a-z] [A-Z]*)*</td>
  </tr>
</table>

<p>Other answers that were equivalent were accepted.  Of the three points possible, one was allocated to the first part (building one word) and two more were allocated to the second part (the subsequent words, separated by the appropriate character).</p>

<p><i>c)</i></p>

<p>Again, more than one answer was acceptable here.  Some students used JFlex-style shorthands; if we could decipher them (i.e. they were clear and <i>were not recursive!</i>), we still tried to award credit when we could.  This question was the same on all three versions, and one possible good answer was:</p>

<table class="normal">
  <tr class="top">
    <td>All Three Versions</td>
  </tr>
  <tr>
    <td>(0 | [1-9] [0-9]*) (. (0 | [0-9]* [1-9]))?</td>
  </tr>
</table>

<hr />

<p class="subtitle">Problem 2</p>

<p>This problem asked for the output of a JFlex script, given a set of patterns with actions that called System.out.println.  It essentially tested whether you understood the greedy matching algorithm used by JFlex (i.e. one that always takes the longest possible match).  By and large, students did very well on this question, averaging 4.5 out of 6 points.</p>

<p>Roughly speaking, one point was deducted for each kind of mistake found, such as matching substrings of a-e and 1-5 separately, not matching the longest one, etc.  Also, 1 point was deducted for an output format not matching the requirements, such as a long sequence of numbers (e.g. "245341353").</p>

<p>The JFlex script was the same on the three versions, though the input strings were different.  The correct answers were:</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      2 abcd<br />
      4 77<br />
      5 cabc234<br />
      3 Q<br />
      4 7<br />
      1 abc<br />
      3 J<br />
      5 3c2a1<br />
      3 H
    </td>
    <td>
      2 abcd<br />
      4 00<br />
      5 babc123<br />
      3 Z<br />
      4 0<br />
      1 abc<br />
      3 G<br />
      5 5a3b4<br />
      3 F
    </td>
    <td>
      2 abcd<br />
      4 99<br />
      5 cbab234<br />
      3 V<br />
      4 9<br />
      1 abc<br />
      3 F<br />
      5 4b2c3<br />
      3 G
    </td>
  </tr>
</table>

<hr />

<p class="subtitle">Problem 3</p>

<p>By and large, students did pretty well on the first part and not well at all on the second part.  The average score overall on the problem was 4.5 out of 8.</p>

<p><i>a)</i></p>

<p>The three versions differed only in terms of the regular expression that appeared in part (a), though all three regular expressions were of a similar form, so I'll just show the answer for one of the versions (for which the regular expression was <b>a | (bc)*</b>).  Since the problem specifically asked you to use Thompson's construction, equivalent NFA's (i.e. NFA's that are different -- including DFA's! -- but accept the same language) were not accepted.</p>

<p class="center"><img src="MidtermAnswer3a.jpg" alt="" /></p>

<p><i>b)</i></p>

<p>This part of the problem was the same on all three versions.  Since the problem specifically asked you to use the subset construction to build the DFA, equivalent DFA's (i.e. DFA's that are different but accept the same language) were not accepted.  Naturally, NFA's were not accepted either.  State names were not considered relevant.</p>

<p class="center"><img src="MidtermAnswer3b.jpg" alt="" /></p>

<p>It should be pointed out that, even though all three of this DFA's are accept states, it still doesn't accept all strings.  Strings such as <b>b</b> or <b>abab</b> are not accepted by it.</p>

<hr />

<p class="subtitle">Problem 4</p>

<p>Answers for this problem (which I graded myself) were all over the map.  The average score on it was 3.9 out of 8, with a substantial portion of that coming from part (a).  Part (b) was a disaster, but it was a great deal more difficult than I'd originally intended.</p>

<p><i>a)</i></p>

<p>This problem had a wide variety of answers, many of which were clearly not LL(1).  Many students tried a variety of transformations that don't make any sense, such as flip-flopping rules like <b>Y &rarr; Ybc</b> to <b>Y &rarr; bcY</b>.  More than one answer was considered correct, but it had to be an LL(1) grammar that accepted the same language.

<p>The straightforward answer, which you could arrive at by performing the transformations we discussed in class on the original grammar, was:</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      X &rarr; Ya | Zbc<br />
      Y &rarr; abaY' | cabaY'<br />
      Y' &rarr; bcY' | &epsilon;<br/ >
      Z &rarr; bZ'<br />
      Z' &rarr; bc | c
    </td>
    <td>
      A &rarr; Bx | Cyz<br />
      B &rarr; xyxB' | zxyxB'<br />
      B' &rarr; yzB' | &epsilon;<br/ >
      C &rarr; yC'<br />
      C' &rarr; yz | z
    </td>
    <td>
      D &rarr; Er | Fst<br />
      E &rarr; rsrE' | trsrE'<br />
      E' &rarr; stE' | &epsilon;<br/ >
      F &rarr; sF'<br />
      F' &rarr; st | t
    </td>
  </tr>
</table>

<p>Partial credit was given for transforming portions of the grammar correctly, even if the entire grammar was not LL(1).  Students were much more commonly able to transform Z &rarr; bbc | bc to Z &rarr; bZ' and Z' &rarr; bc | c than they were able to perform the left recursion elimination on Y correctly.</p>

<p><i>b)</i></p>

<p>This problem actually couldn't be solved using strictly the techniques shown in class.  For that reason, I accepted some answers that were arrived at by applying as many of these transformations as could be applied, even if the final grammar was not LL(1).  (Few students got this far, as it turned out, and the most common score on this part of the problem was 1 out of 4, awarded for attempting to perform some kind of transformation to the grammar.)  A few students applied some ingenuity, reverse engineering the grammar and building a new one.  After inspecting the behavior of the grammar, you can discover that the grammar describes a language that can be described by the regular expression <b>ab (bb | cb)*</b>, from which you can build a grammar.</p>

<p>The incorrect but acceptable answer looked like this:</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      X &rarr; Yb<br />
      Y &rarr; aY'<br />
      Y' &rarr; &epsilon; | bY''<br />
      Y'' &rarr; bY' | cY'
    </td>
    <td>
      A &rarr; By<br />
      B &rarr; xB'<br />
      B' &rarr; &epsilon; | yB''<br />
      B'' &rarr; yB' | zB'
    </td>
    <td>
      D &rarr; Es<br />
      E &rarr; rE'<br />
      E' &rarr; &epsilon; | sE''<br />
      E'' &rarr; sE' | tE'
    </td>
  </tr>
</table>

<p>(These grammars are not LL(1) because, for example, starting with this derivation: X &rArr; Yb &rArr; aY'b &rArr; ...it is not clear now, with the next character of input being a <b>b</b>, whether we should expand by Y' &rarr; bY'', or by Y' &rarr; &epsilon;.)</p>

<p>Correct answers looked like one of these grammars (or something very much like them):</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      X &rarr; abY<br />
      Y &rarr; bbY | cbY | &epsilon;<br />
      <br />
      or<br />
      <br />
      X &rarr; aY<br />
      Y &rarr; bY'<br />
      Y' &rarr; &epsilon; | bbY' | cbY'
    </td>
    <td>
      A &rarr; xyB<br />
      B &rarr; yyB | zyB | &epsilon;<br />
      <br />
      or<br />
      <br />
      A &rarr; xB<br />
      B &rarr; yB'<br />
      B' &rarr; &epsilon; | yyB' | zyB'
    </td>
    <td>
      D &rarr; rsE<br />
      E &rarr; ssE | tsE | &epsilon;<br />
      <br />
      or<br />
      <br />
      D &rarr; rE<br />
      E &rarr; sE'<br />
      E' &rarr; &epsilon; | ssB' | tsB'
    </td>
  </tr>
</table>

<p>The answers are inspired by two different regular expressions: <b>ab (bb | cb)*</b> and <b>a (bb | bc)* b</b>.</p>

<hr />

<p class="subtitle">Problem 5</p>

<p>After the homework assignment I gave on this topic, students seem to have gotten the point about FIRST and FOLLOW sets.  The average score on this problem was 7.8 out of 9.</p>

<p><i>a)</i></p>

<p>The first five sets had only one element each; they were worth a total of one point.  The others were worth one point each.</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      FIRST(&epsilon;) = { &epsilon; }<br />
      FIRST(a) = { a }<br />
      FIRST(b) = { b }<br />
      FIRST(c) = { c }<br />
      FIRST(d) = { d }<br />
      FIRST(S) = { b, c, d, a, &epsilon; }<br />
      FIRST(X) = { b, c }<br />
      FIRST(Y) = { d, a, &epsilon; }
    </td>
    <td>
      FIRST(&epsilon;) = { &epsilon; }<br />
      FIRST(x) = { x }<br />
      FIRST(y) = { y }<br />
      FIRST(z) = { z }<br />
      FIRST(w) = { w }<br />
      FIRST(S) = { y, z, w, x, &epsilon; }<br />
      FIRST(A) = { y, z }<br />
      FIRST(B) = { w, x, &epsilon; }
    </td>
    <td>
      FIRST(&epsilon;) = { &epsilon; }<br />
      FIRST(r) = { r }<br />
      FIRST(s) = { s }<br />
      FIRST(t) = { t }<br />
      FIRST(v) = { v }<br />
      FIRST(S) = { s, t, v, r, &epsilon; }<br />
      FIRST(D) = { s, t }<br />
      FIRST(E) = { v, r, &epsilon; }
    </td>
  </tr>
</table>

<p><i>b)</i></p>

<p>Results were strong here, too, with some of the most common mistakes being including &epsilon; and not including eof.  These were worth one point each.</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      FOLLOW(S) = { eof }<br />
      FOLLOW(X) = { eof, d, a }<br />
      FOLLOW(Y) = { eof, c }
    </td>
    <td>
      FOLLOW(S) = { eof }<br />
      FOLLOW(A) = { eof, w, x }<br />
      FOLLOW(B) = { eof, z }
    </td>
    <td>
      FOLLOW(S) = { eof }<br />
      FOLLOW(D) = { eof, v, r }<br />
      FOLLOW(E) = { eof, t }
    </td>
  </tr>
</table>

<p><i>c)</i></p>

<p>This was worth two points, all or nothing.  The answer was <b>Yes!!!</b> (though the exclamation marks were not required :) ).</p>

<hr />

<p class="subtitle">Problem 6</p>

<p>Students didn't do particularly well on this question, with the average score being 4.4 out of 9.  As with most other questions on the exam, a wide variety of answers were given.</p>

<p>For all three parts of the problem, the following rubric was used for grading (and marks were made accordingly with the notation shown in parentheses):</p>

<ul>
  <li>-0.25 points for each wrong or missing lookahead (WL / NL)</li>
  <li>-1 point for not computing the closure of a set (NC)</li>
  <li>-0.5 points for missing an item in a set (MI)</li>
  <li>-2 points for a wrong set of LR(1) items in part b (TWS, WS)</li>
  <li>-1 point for missing the first item in goto in part b (MFI)</li>
  <li>-2 points for missing first set of LR(1) items in part b (N1S)</li>
  <li>-2 points for missing second set of LR(1) items in part b (N2S)</li>
  <li>-2 points for missing third set of LR(1) items in part b (N3S)</li>
  <li>If many more items than needed were listed, no credit was given.</li>
</ul>

<p><i>a)</i></p>

<p>The initial state of the parser consisted of six LR(1) items.  Each was worth a half-point.</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      { [Goal &rarr; &bull; S, eof], <br />
      [S &rarr; &bull; YY, eof], <br />
      [Y &rarr; &bull; fY, f], <br />
      [Y &rarr; &bull; fY, g], <br />
      [Y &rarr; &bull; g, f], <br />
      [Y &rarr; &bull; g, g] }
    </td>
    <td>
      { [Goal &rarr; &bull; S, eof], <br />
      [S &rarr; &bull; BB, eof], <br />
      [B &rarr; &bull; eB, e], <br />
      [B &rarr; &bull; eB, f], <br />
      [B &rarr; &bull; f, e], <br />
      [B &rarr; &bull; f, f] }
    </td>
    <td>
      { [Goal &rarr; &bull; S, eof], <br />
      [S &rarr; &bull; EE, eof], <br />
      [E &rarr; &bull; gE, g], <br />
      [E &rarr; &bull; gE, h], <br />
      [E &rarr; &bull; h, g], <br />
      [E &rarr; &bull; h, h] }
    </td>
  </tr>
</table>

<p><i>b)</i></p>

<p>If we apply goto to S<sub>z</sub>, we can reach three distinct parse states.</p>

<table class="normal">
  <tr class="top"><td>Version A</td><td>Version B</td><td>Version C</td></tr>
  <tr>
    <td>
      goto(S<sub>z</sub>, Y) = { [S &rarr; YY &bull;, eof] }<br />
      <br />
      goto(S<sub>z</sub>, f) = { [Y &rarr; f &bull; Y, eof],<br />
      [Y &rarr; &bull; fY, eof], [Y &rarr; &bull; g, eof] }<br />
      <br />
      goto(S<sub>z</sub>, g) = { [Y &rarr; g &bull;, eof] }
    </td>
    <td>
      goto(S<sub>z</sub>, B) = { [S &rarr; BB &bull;, eof] }<br />
      <br />
      goto(S<sub>z</sub>, e) = { [B &rarr; e &bull; B, eof],<br />
      [B &rarr; &bull; eB, eof], [B &rarr; &bull; f, eof] }<br />
      <br />
      goto(S<sub>z</sub>, f) = { [B &rarr; f &bull;, eof] }
    </td>
    <td>
      goto(S<sub>z</sub>, E) = { [S &rarr; EE &bull;, eof] }<br />
      <br />
      goto(S<sub>z</sub>, g) = { [E &rarr; g &bull; E, eof],<br />
      [E &rarr; &bull; gE, eof], [E &rarr; &bull; h, eof] }<br />
      <br />
      goto(S<sub>z</sub>, h) = { [E &rarr; h &bull;, eof] }
    </td>
  </tr>
</table>

<p class="subtitle">Problem 7</p>

<p>This problem was thrown out, as it had at least one mistake on every version, and at least one more mistake on at least one of the versions.  Ugh!</p>

</div>

</body>
</html>

